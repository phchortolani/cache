<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="CACHE" ts="2001-01-01 00:00:00">
<Routine name="WWWTRnew" type="MAC" languagemode="0" timestamp="58440,0"><![CDATA[
WWWTRnew(pblnToInternal,penumDataType,pValue,pintShowDecs)
#include WWWConst
#include COMSYS
	;-------------------------------------------------------------------------------
	; Legacy Entry Point - DEPRECATED - use $$Convert^WWWTR rather than $$^WWWTR
	;-------------------------------------------------------------------------------
	quit $$Convert($get(pblnToInternal),$get(penumDataType),$get(pValue),$get(pintShowDecs))
	
	
Convert(pblnToInternal,penumDataType,pValue,pintShowDecs)
	;-------------------------------------------------------------------------------
	; Description of Function :
	;		Convert between Literal and Internal data formats
	;		
	;  s YINHALT=$$^WWWTR(0,8,"1000")         ; display = 1.000,25 or 1,000.25  from internal 1000.25
	;  s YINHALT=$$^WWWTR(1,8,"1.000,00")     ; storage = 1000.25  from literal  1.000,25 or 1,000.25
	;  s YINHALT=$$^WWWTR(0,1,$horolog)       ; display DD.MM.YYYY or DD/MM/YYYY or MM/DD/YYYY or...
	;  s YINHALT=$$^WWWTR(1,1,"01.01.2000")   ; store in $horolog FORMAT
	;
	; Inputs : 
	;  pblnToInternal	Direction of transformation
	;  					= 1 Literal  to Internal format - Store
	;  					= 0 Internal to Literal  format	- Display
	;  
	;  penumDataType	DataType as in ^WWW100(0,"FELDTYP",SPRACHE,DataType,1)
	;     				  with format in WWW101(0,"FELDFORMAT",SPRACHE,DataType,1) overriding
	;     				  system setting in ^WWW100
	;  pValue			Value to be transformed 
	;  pintShowDecs		Number of Decimal Places (applied to 12-Floating and 18-Exchange Rate only)
	;
	; ByRef :
	;	YDECIMAL		Decimal point as comma or period
	;	YDECIMALLEN		Number of decimal places (applied to 8-Currency only)
	;	SPRACHE			User's Language - for Locale-based conversions
	;	YWHR			Set Currency Code
	;
	; Returns :
	;	Updated pValue
	;
	; History :
	; History:
	; 26-Mar-2009	GRF		SR16452: Added type 19 - Sequential Key
	; 29-Jan-2009	GRF		SR15525: Specific Entry Point rather than through
	; 							heading; retain legacy entry for now.
	; 13-Jun-2007	GRF		SR15525: General clean up
	; 11-Apr-2007	GRF		SRBR014310: Doco; braces
	; 11-Dec-2005	RPW		SR14144: The system was not allowing a zero exchange rate, we do now.
	; 22-Dec-2005	JW		SR13195: Edited memo and checkbox types for input.
    ; 28-Oct-2005	JW		SR13074: Exchange Rate type. Invert depending on system setup.
	; 27-Oct-2005	SS/JW	SR13745: Added pintShowDecs (Dec. Places) parameter
	; 30-May-2005	RPW		SR12056: Attempt at Performance Increase
	; 15.Jan.1998	DT
	;-------------------------------------------------------------------------------
	new YFORMAT,YPR
	
	;---------------------------------------
	; If Input value is null then return null.
	; No need to check later
	;---------------------------------------
	if $get(pValue)="" quit ""
	
	set pblnToInternal = +$get(pblnToInternal)
	if '$data(penumDataType) set penumDataType = 6       ; "Text' by default
	set:$get(YDECIMAL)="" YDECIMAL = $extract($$GetNumberDelimiters^COMUtilLocale(SPRACHE),2)   ; SR15525
	
	if pblnToInternal {
		do ToInternal(.pValue,penumDataType,YDECIMAL,$get(pintShowDecs))
	} else {
		do ToLiteral(.pValue,penumDataType,YDECIMAL,$get(pintShowDecs))
	}
	
	quit pValue
	
	
ToInternal(&pValue,penumDataType,YDECIMAL,pintShowDecs)
	;-------------------------------------------------------------------------------
	; Input -> Storage
	;
	; Inputs:
	; 	pValue			Value to be converted
	; 	penumDataType	Data Type
	;	YDECIMAL		Decimal point as comma or period
	; 	pintShowDecs	Required No of Decimal Places
	;
	; ByRefs:
	; 	YWHR			Currency Code
	; 	YDECIMALLEN		Number of Decimal Places
	; 	YFORM			Calling form
	;
	; Returns:
	;
	; History:
	; 11-Apr-2007	GRF		SRBR014310: Naked References
	; 05-Apr-2007	RPW		Fixed IPAddress checks.
	; 27-Nov-2006	JW		SR15101: Convert invalid currency entry to 0
	;-------------------------------------------------------------------------------
	set pValue=$translate(pValue,Y,"-")
	; FIXME : <GRF> Will treat Y_"123" as "-123".  Better than adding 2 pieces into
	;               one in record but may be other solutions.  (special char?)
	
	if penumDataType=3 {
		set pValue = $$InMemo(pValue)
		
	} else {
		if ($get(YFORM)'="") && ($extract($get(YFORM),1,3)'="WWW") && ($extract($get(YFORM),1,3)'="APM") {
		;	set pValue=$translate(pValue,""""_"'<>","´´()")              ;ANFÜHRUNGSZEICHEN NICHT UMSETZTEN ;FIS;19.02.03
			if $$$WWW120DoNotConvertQuotes($get(^WWW120(0,YFORM,1)))'=$$$YES {
				set pValue=$translate(pValue,""""_"'","´´")
				if (pValue["<") && (pValue[">") do ^WWWUML(pValue,2)  ;only where HTML tag present
			}
		}
		
	;---------------------------------------
	; Commented types are left as-is
	;---------------------------------------
		if penumDataType= 1       { set pValue = $$InDate(pValue)
	;	} elseif penumDataType=0  { set pValue = $$InHidden(pValue)
		} elseif penumDataType= 2 { set pValue = $$InBoolean(pValue)
	;	} elseif penumDataType= 3 { set pValue = $$InMemo(pValue)
		} elseif penumDataType= 4 { set pValue = $$InInteger(pValue,YDECIMAL)
	;	} elseif penumDataType= 5 { set pValue = $$InPassword(pValue)
	;	} elseif penumDataType= 6 { set pValue = $$InText(pValue)
		} elseif penumDataType= 7 { set pValue = $$InTime(pValue)
		} elseif penumDataType= 8 { set pValue = $$InCurrency(pValue,YDECIMAL,$get(YDECIMALLEN),$get(YWHR))
	;	} elseif penumDataType= 9 { set pValue = $$InCounter(pValue)
	;	} elseif penumDataType=10 { set pValue = $$InFileName(pValue)
	;	} elseif penumDataType=11 { set pValue = $$InDraw(pValue)
		} elseif penumDataType=12 { set pValue = $$InFloating(pValue,YDECIMAL,pintShowDecs)
		} elseif penumDataType=13 { set pValue = $$InIPFormat(pValue)
		} elseif penumDataType=14 { set pValue = $$InTimeStamp(pValue)
	;	} elseif penumDataType=15 { set pValue = $$InCollection(pValue)
	;	} elseif penumDataType=16 { set pValue = $$InEmbedded(pValue)
		} elseif penumDataType=17 { set pValue = $$InDateYMD(pValue)
		} elseif penumDataType=18 { set pValue = $$InForEx(pValue,YDECIMAL,pintShowDecs)
		} elseif penumDataType=19 { set pValue = $$InSeqKey(pValue)
		}
	}
	
	quit
	
ToLiteral(&pValue,penumDataType,YDECIMAL,pintShowDecs)
	;-------------------------------------------------------------------------------
	;	Convert internal format to literal format.
	;	OUTPUT VOM DISK ZUM USER
	; 
	; Inputs:
	; 	pValue			Value to be converted
	; 	penumDataType	Data Type
	;	YDECIMAL		Decimal point as comma or period
	; 	pintShowDecs	Required No of Decimal Places
	;
	; ByRef:
	;	YWHR			Currency Code
	; 	YDECIMALLEN		Number of Decimal Places
	; 
	; History:
	; 15-May-2007	GRF	SRBR014469: Correction to Floating Point/Exchange Rate types
	; 					(12/18) to strip trailing zeros after the decimal place.
	;-------------------------------------------------------------------------------
	
	;---------------------------------------
	; Commented types are left as-is
	;---------------------------------------
	if penumDataType= 1        { set pValue = $$^WWWDATE(pValue)              ;$$OutDate(pValue)
	;} elseif penumDataType=0  { set pValue = $$OutHidden(pValue)
	} elseif penumDataType= 2  { set pValue = $$OutBoolean(pValue)
	;} elseif penumDataType= 3 { set pValue = $$OutMemo(pValue)
	} elseif penumDataType= 4  { set pValue = $$OutInteger(pValue)
	;} elseif penumDataType= 5 { set pValue = $$OutPassword(pValue)
	;} elseif penumDataType= 6 { set pValue = $$OutText(pValue)
	} elseif penumDataType= 7  { set pValue = $$OutTime(pValue)
	} elseif penumDataType= 8  { set pValue = $$OutCurrency(pValue,$get(YDECIMALLEN),$get(YWHR))
	;} elseif penumDataType= 9 { set pValue = $$OutCounter(pValue)
	;} elseif penumDataType=10 { set pValue = $$OutFileName(pValue)
	;} elseif penumDataType=11 { set pValue = $$OutDraw(pValue)
	} elseif penumDataType=12  { set pValue = $$OutFloating(pValue,YDECIMAL,pintShowDecs)
	;} elseif penumDataType=13 { set pValue = $$OutIPFormat(pValue)
	} elseif penumDataType=14  { set pValue = $$OutTimeStamp(pValue)
	;} elseif penumDataType=15 { set pValue = $$OutCollection(pValue)
	;} elseif penumDataType=16 { set pValue = $$OutEmbedded(pValue)
	} elseif penumDataType=17  { set pValue = $$OutDateYMD(pValue)
	} elseif penumDataType=18  { set pValue = $$OutForEx(pValue,YDECIMAL,pintShowDecs)
	} elseif penumDataType=19  { set pValue = $$OutSeqKey(pValue)
	}
	
	quit
	
	/*
InHidden(pValue)      ; Not in use
	;-------------------------------------------------------------------------------
	; penumDataType = 0
	;-------------------------------------------------------------------------------
	quit pValue
	
OutHidden(pValue)     ; Not in use
	quit pValue
	*/
	
InDate(pValue)
	;-------------------------------------------------------------------------------
	; penumDataType = 1
	; Literal   : depends on location specification e.g. 15/01/2001
	; Internal  : +$horolog  e.g. 65000
	;-------------------------------------------------------------------------------
	if pValue="." {
		set pValue=+$horolog
	} else {
		if $extract(pValue)="-" set pValue = $horolog-$extract(pValue,2,9)
		if $extract(pValue)="+" set pValue = $horolog+$extract(pValue,2,9)
		set pValue=$$^WWWDATE1(pValue)
	}
	
	quit pValue
	
	/*  use directly
OutDate(pValue)
	quit $$^WWWDATE(pValue)
	*/
	
InBoolean(pValue)
	;-------------------------------------------------------------------------------
	; penumDataType = 2
	; "CHECKED" and "UNCHECKED" may be set in the Return Value
	;-------------------------------------------------------------------------------
	if $find(pValue,$$$YES) set pValue=$$$YES   ; strange interpretation - "ABC1" => $$$YES, "ABC2" => $$$NO
	if pValue="CHECKED"     set pValue=$$$YES
	if pValue'=$$$YES       set pValue=""       ; includes "UNCHECKED"
	quit pValue
	
OutBoolean(pValue)
	; NOTE : Can not have pValue="" since stopped earlier but leave in case that changes.
	quit $select(pValue=-1:$$$YES,pValue="":$$$NO,1:pValue)
	
InMemo(pValue)
	;-------------------------------------------------------------------------------
	; penumDataType = 3
	; FIXME : <GRF> Are we supposed to search only for CRLF or should simple CR be
	;               translated as well?   UNIX 13 / MAC 10 / PC 13,10  ?
	;-------------------------------------------------------------------------------
	set pValue = $translate(pValue,$char(13,10),"|")
	quit pValue
	
	/*
OutMemo(pValue)       ; Not in use
	quit pValue
	*/
	
InInteger(pValue,YDECIMAL)
	;-------------------------------------------------------------------------------
	; penumDataType = 4   Involves truncation
	;         
	; WARNING : Some data fields have type INTEGER when they should be FLOATING
	;           or something else.   (INTEGER was originally NUMBER - stricter
	;           interpretation)
	;-------------------------------------------------------------------------------
	set pValue = +$$ConvertLocaleNumber(pValue,YDECIMAL)     ; temp
	;set pValue = $$ConvertLocaleNumber(pValue,YDECIMAL)\1   ; final - needs action before swapping TODO : <GRF>
	quit pValue
	
OutInteger(pValue)
	;-------------------------------------------------------------------------------
	; NOTE : Literal form will now have thousands separator.
	;-------------------------------------------------------------------------------
	set pValue=$$^WWWZAHL(pValue,0,0)
	quit pValue
	
	/*
InPassword(pValue)    ; Not in use
	;-------------------------------------------------------------------------------
	; penumDataType = 5
	;-------------------------------------------------------------------------------
	quit pValue
	
OutPassword(pValue)   ; Not in use
	quit pValue
	
InText(pValue)        ; Not in use
	;-------------------------------------------------------------------------------
	; penumDataType = 6
	;-------------------------------------------------------------------------------
	quit pValue
	
OutText(pValue)       ; Not in use
	quit pValue
	*/
	
InTime(pValue)
	;-------------------------------------------------------------------------------
	; penumDataType = 7
	; Literal   : HH:MM or HH:MM:SS
	; Internal  : 86399
	;-------------------------------------------------------------------------------
	if pValue="." {   set pValue = $piece($horolog,",",2)
	} else        {   set pValue = $$^WWWTIME1(pValue)
	}
	quit pValue
	
OutTime(pValue)
	set pValue=$$^WWWTIME(pValue)
	quit pValue
	
InCurrency(pValue,YDECIMAL,YDECIMALLEN,pstrSetCurr)
	;-------------------------------------------------------------------------------
	; penumDataType = 8
	;	
	; Inputs:
	; 	pValue			Literal Value
	; 	pstrSetCurr		(YWHR) Explicitly set currency code
	; 	YDECIMALLEN		Number of Decimal Places
	; 
	; Returns:
	; 	curValue		May be simple float or foreign currency string
	; 	
	;-------------------------------------------------------------------------------
	;	If pstrSetCurr is null, the only conversion is from Locale-based
	;	                        thousands/decimal literal format to an
	;	                        internal format.
	;	If it is not null,      the following conversion is made in addition
	;	                        to the Locale-based changes.
	;-------------------------------------------------------------------------------
	;   	        pValue					Returns for pstrSetCurr = "USD"
	;	 	    ""		   not transformed
	; Category 1
	;	 	   "0"								0
	;	 	        "@USD9.87@1.25"			0@USD9.87@1.25			(not expected)
	;	 	 "abcdef"							0					(not expected)
	; Category 2
	;		"USD12.34"						15.43@USD12.34@1.25
	;		"USD12.34@1.25"					15.43@USD12.34@1.25
	;		"USD12.34@XYZ9.87@1.25"			15.43@USD12.34@1.25
	; Category 3
	;		   "12.34@XYZ9.87@1.25"			15.43@XYZ9.87@1.25		(not expected ? - inconsistent figures)
	;		   "12.34@1.25"					15.43@1.25				(not expected)
	;		   "12.34"							15.43				(Sup Inv matching?)
	;
	;		curValue @ strCurrCalc
	;		               |
	;	           strCurrCode_fltForeignCur@fltRate
	;-------------------------------------------------------------------------------
	new curValue,fltForeignCur,fltRate,fltSetRate,strCurrCalc,strCurrCode
	
	if YDECIMALLEN="" set YDECIMALLEN=2
	
	set curValue    = $piece(pValue,"@",1)
	set strCurrCalc = $piece(pValue,"@",2,99)
	
	set curValue    = $translate(curValue," ;:_#`'")                 ;SR13745
	set curValue    = $$ConvertLocaleNumber(curValue,YDECIMAL)                 ; Internal formats
	set strCurrCalc = $$ConvertLocaleNumber(strCurrCalc,YDECIMAL)
	
	set:$extract(curValue)="=" curValue = $$PerformCalculation(curValue)
	
	if (pstrSetCurr'="") {
		if +curValue=0 {
			set strCurrCode = $zconvert($zstrip(curValue,"*E'A"),"U")
			if $ascii(strCurrCode)=128 set strCurrCode="EUR"
			
			if (strCurrCode="") || '$data(^WWWWAE(0,strCurrCode)) {
	;---------------------------------------
	;	Category 1
	;---------------------------------------
				set curValue = 0                                         ; SR15101
			} else {
	;---------------------------------------
	;	Category 2 - recalculate AND rebuild
	;		curValue @ strCurrCalc	strCurrCode_fltForeignCur@fltRate
	;		"USD12.34"					"USD"  _   "12.34"
	;		"USD12.34@1.25"				"USD"  _   "12.34"   @  "1.25"
	;		"USD12.34@XYZ9.87@1.25"		"USD"  _   "12.34"   @  "1.25"
	;---------------------------------------
		;		if strCurrCode="DM" set strCurrCode = "DEM"              ; obsolete
				if strCurrCode="EU" set strCurrCode = "EUR"
				
				set fltForeignCur = $zstrip(curValue,"*A","$"_$char(128))
				if +fltForeignCur=0 {
					set curValue = 0
				} else {
					if strCurrCalc'="" {
						if strCurrCalc["@" {
							set fltRate = $piece(strCurrCalc,"@",2)
						} else {
							set fltRate = strCurrCalc
						}
					} else {
						set fltRate = $$$WWWWAEUnitPrice($get(^WWWWAE(0,strCurrCode,1)))
						do GetConversionRate(YFORM,YKEY,.fltRate)
					}						
					
					set strCurrCalc=""
					if (strCurrCode'="") && (+fltForeignCur'=0) {
						set strCurrCalc = strCurrCode_fltForeignCur_"@"_fltRate
					}
					
			;	SR14144 Allow any valid exchange rate to calculate the amount	
					if $isvalidnum(fltRate) {
						set curValue = $justify(fltForeignCur*fltRate,0,YDECIMALLEN)
					} else {
						set curValue = fltForeignCur
					}
				}
			}
	
		} else {
	;---------------------------------------
	;	Category 3 - recalculate, but don't rebuild strCurrCalc
	;---------------------------------------
			set fltSetRate = +$$$WWWWAEUnitPrice($get(^WWWWAE(0,pstrSetCurr,1)))
			if fltSetRate'=0 set curValue = curValue * fltSetRate                 ;UMRECHNEN WÄHRUNGEN
		}
	}
	
	if strCurrCalc'="" {
	;	if curValue is Locale-based then strCurrCalc needs to be as well.
		set curValue = curValue_"@"_strCurrCalc
	}
	
	quit curValue
	
OutCurrency(pValue,YDECIMALLEN,pstrCurrCode)
	new fltRate
	
	if pValue["@" set pValue=$piece(pValue,"@",1)
	
	if pstrCurrCode="" set pstrCurrCode = " "
	set fltRate = +$$$WWWWAEUnitPrice($get(^WWWWAE(0,pstrCurrCode,1)))
	if fltRate'=0 set pValue = pValue/fltRate
	
	if (+pValue'=0) || (pValue="0") {
		if YDECIMALLEN="" set YDECIMALLEN=2   
		set pValue=$$^WWWZAHL(pValue,0,YDECIMALLEN)
	}
	
	quit pValue
	
	/*
InCounter(pValue)     ; Not in use
	;-------------------------------------------------------------------------------
	; penumDataType = 9
	;-------------------------------------------------------------------------------
	; Prior commented code - left as-is
	;if (pValue'="+") set pValue = $piece(+$translate(pValue,",","."),".",1)
	quit pValue
	
OutCounter(pValue)  ; Not in use
	; Prior commented code - left as-is (only needs +pValue'=0 test)
	;if (+pValue'=0) && (pValue'="+") set pValue = +$piece(pValue,".",1)
	quit pValue
	*/
	
	/*
InFileName(pValue)    ; Not in use
	;-------------------------------------------------------------------------------
	; penumDataType = 10
	;-------------------------------------------------------------------------------
	quit pValue
	
OutFileName(pValue)   ; Not in use
	quit pValue
	*/
	
	/*
InDraw(pValue)        ; Not in use
	;-------------------------------------------------------------------------------
	; penumDataType = 11
	;-------------------------------------------------------------------------------
	quit pValue
	
OutDraw(pValue)       ; Not in use
	quit pValue
	*/
	
InFloating(pValue,YDECIMAL,pintShowDecs)
	;-------------------------------------------------------------------------------
	; penumDataType = 12   Also called by InForEx penumDataType=18
	; 
	; possibly also CUR###
	; 
	; Positive number		 nnn.nnn			=+nnn.nnn			=nnn.nnn
	; Negative number		-nnn.nnn			=-nnn.nnn
	; Calculations			=nnn.nnn+nnn.nnn	=nnn.nnn-nnn.nnn	=nnn.nnn*nnn.nnn	=nnn.nnn/nnn.nnn
	;-------------------------------------------------------------------------------
	if YDECIMALLEN="" set YDECIMALLEN=2
	
	set pValue = $translate(pValue," ;:_#`'") ;SR13745
	set pValue = $$ConvertLocaleNumber(pValue,YDECIMAL)
	
	set:$extract(pValue)="=" pValue = $$PerformCalculation(pValue)
 
	;if +pValue=0 IF pValue'=0    set pValue = +$translate(pValue,"abcdefghijklmnopqrstuvwxyz$ABCDEFGHIJKLMNOPQRSTUVWXYZ"_$char(128))
	if (+pValue=0) && (pValue'=0) set pValue = +$zstrip(pValue,"*A","$"_$char(128))
	if $extract(pValue,1,2)="0."  set pValue = +pValue
	set:pintShowDecs'="" pValue = +$justify(pValue,0,pintShowDecs)
	
	quit pValue
	
OutFloating(pValue,YDECIMAL,pintShowDecs)
	;-------------------------------------------------------------------------------
	;	Also called by OutForEx penumDataType=18
	;
	;  - If accuracy is not specified use number of decimals in number.
	;  - Convert to literal format
	;  - If there is a decimal point (locale-based) in the number,
	;  		Remove trailing zeros.
	;  		If last character is the decimal point, remove that too.
	;-------------------------------------------------------------------------------
	if pintShowDecs="" set pintShowDecs = $length($piece(pValue,".",2))          ; SR13745
	
	if (pValue'=0) {
		set pValue = $$^WWWZAHL(pValue,0,pintShowDecs)
		if pValue[YDECIMAL {
			for {
				quit:$extract(pValue,$length(pValue))'=0
				
				set pValue=$extract(pValue,1,$length(pValue)-1)
			}
			if $extract(pValue,$length(pValue))=YDECIMAL set pValue=$extract(pValue,1,$length(pValue)-1)
		}
	}
	
	quit pValue
	
InIPFormat(pValue)
	;-------------------------------------------------------------------------------
	; penumDataType = 13
	;-------------------------------------------------------------------------------
	set pValue=$$^WWWIP1($tr(pValue,"-, :\/#'+*;","..........."))
	quit pValue
	
	/*
OutIPFormat(pValue)   ; Not in use
	quit pValue
	*/
	
InTimeStamp(pValue)
	;-------------------------------------------------------------------------------
	; penumDataType = 14
	; Literal   : DD/MM/YYYY HH:MM:SS
	; Internal  : 60000,40000 ($horolog)
	;-------------------------------------------------------------------------------
	if (pValue=".")                  { set pValue = $horolog
	} elseif $piece(pValue," ",2)="" { set pValue = $$^WWWDATE1(pValue)
	} else                           { set pValue = $$^WWWDATE1($piece(pValue," ",1))_","_$$^WWWTIME1($piece(pValue," ",2,4))
	}
	quit pValue
	
OutTimeStamp(pValue)
	if $piece(pValue,",",2)'=""      { set pValue = $$^WWWDATE(pValue)_" "_$$^WWWTIME(+$piece(pValue,",",2))
	} else                           { set pValue = $$^WWWDATE(pValue)
	}
	quit pValue
	
	/*
InCollection(pValue)  ; Not in use
	;-------------------------------------------------------------------------------
	; penumDataType = 15
	;-------------------------------------------------------------------------------
	quit pValue
 
OutCollection(pValue) ; Not in use
	; vvvvv Disabled Block Start
	;  MULTI FELDER
	;IF '$FIND(pValue,";") IF $LISTGET(pValue,1)'=""  DO
	. NEW Value1,loop
	. SET Value1=pValue
	. SET pValue=""
	. FOR loop=1:1 QUIT:$LISTGET(Value1,loop)=""  SET pValue=pValue_$LISTGET(Value1,loop)_";"  QUIT:$LENGTH(pValue)>30000
	; ^^^^^ Disabled Block End
	quit pValue
	*/
	
	/*
InEmbedded(pValue)    ; Not in use
	;-------------------------------------------------------------------------------
	; penumDataType = 16
	;-------------------------------------------------------------------------------
	quit pValue
	
OutEmbedded(pValue)   ; Not in use
	quit pValue
	*/
	
InDateYMD(pValue)
	;-------------------------------------------------------------------------------
	; penumDataType = 17
	; Literal   : DD.MM.YYYY   or   DD   or   DD.MM   or   DD.MM.YY
	;             alternatively Locale-based
	;             MM.DD.YYYY   or   DD   or   MM.DD   or   MM.DD.YY
	;             (will also accept -/, as delimiters)
	; Internal  : YYYYMMDD
	;-------------------------------------------------------------------------------
	new strDelim,strFormat
	
	do GetDateFormat^COMUtilLocale(.strFormat,.strDelim,SPRACHE)
	set pValue = $translate(pValue,".-/,")
	
	if $extract(strFormat,1)="D" {
		if $length(pValue)=2 set pValue=pValue_$$^WWWMONTH()_$$^WWWYEAR()
		if $length(pValue)=4 set pValue=pValue_$$^WWWYEAR()
		if $length(pValue)=6 set pValue=$extract(pValue,1,4)_$extract($$^WWWYEAR(),1,2)_$extract(pValue,5,6)
		set pValue = $extract(pValue,5,8)_$extract(pValue,3,4)_$extract(pValue,1,2)
	
	} elseif $extract(strFormat,1)="M" {
		if $length(pValue)=2 set pValue=$$^WWWMONTH()_pValue_$$^WWWYEAR()
		if $length(pValue)=4 set pValue=pValue_$$^WWWYEAR()
		if $length(pValue)=6 set pValue=$extract(pValue,1,4)_$extract($$^WWWYEAR(),1,2)_$extract(pValue,5,6)
		set pValue = $extract(pValue,5,8)_$extract(pValue,1,2)_$extract(pValue,3,4)
	
	} else {
		; unrecognised date format (perhaps YYYYMMDD) - return as is
	}
	quit pValue
	
	
OutDateYMD(pValue)
	new strDelim,strFormat
	
	do GetDateFormat^COMUtilLocale(.strFormat,.strDelim,SPRACHE)
	if $extract(strFormat,1)="D" {
		set pValue=$extract(pValue,7,8)_strDelim_$extract(pValue,5,6)_strDelim_$extract(pValue,1,4)
 
	} elseif $extract(strFormat,1)="M" {
		set pValue=$extract(pValue,5,6)_strDelim_$extract(pValue,7,8)_strDelim_$extract(pValue,1,4)
		
	} elseif strFormat="YYYYMMDD" {
		; return as is
		
	} else {
		; unrecognised date format - return as is
	}
	
	quit pValue
	
InForEx(pValue,YDECIMAL,pintShowDecs)
	;-------------------------------------------------------------------------------
	; penumDataType = 18
	; If necessary, invert rate - retaining as much accuracy as possible internally
	; by leaving pintShowDecs as "".
	; 
	; Can contain     "=###-###"   "=###+###"   "=###*###"
	;                 "=###/###"   "=###"       "###"           where ### is a value
	;                 "CUR###"                                        CUR is a currency code
	;-------------------------------------------------------------------------------
	set pValue = $$InFloating(pValue,YDECIMAL,"")    ; Don't limit accuracy before inverting
	if +pValue'=0 {
		if $$$WWWSystemSetupExchangeRatesAsFraction($get(^WWWSystemSetup(0,0,1))) {
			set pValue = 1 / pValue
		}
	}
	set:pintShowDecs'="" pValue = +$justify(pValue,0,pintShowDecs)
	
	quit pValue
	
OutForEx(pValue,YDECIMAL,pintShowDecs)
	;-------------------------------------------------------------------------------
	;  - Invert value if exchange rates are shown that way; limit accuracy to 10dp
	;  - If accuracy is not specified use number of decimals in number.
	;  - Convert to literal format
	;  - If there is a decimal point (locale-based) in the number,
	;  		Remove trailing zeros.
	;  		If last character is the decimal point, remove that too.
	;-------------------------------------------------------------------------------
	if (+pValue'=0) {
		if $$$WWWSystemSetupExchangeRatesAsFraction($get(^WWWSystemSetup(0,0,1))) {
			set pValue = +$justify(1/pValue,0,10)
		}
	}
	set pValue = $$OutFloating(pValue,YDECIMAL,pintShowDecs)
	
	quit pValue
	
InSeqKey(pValue)
	;-------------------------------------------------------------------------------
	; penumDataType = 19   Where an associated line is inserted with +.01 increments
	;                      Internal : "nnn.1"   Literal : "nnn.10"
	; 
	; History:
	; 26-Mar-2009	GRF		SR16452: created
	;-------------------------------------------------------------------------------
	set pValue = +pValue
	
	quit pValue
	
OutSeqKey(pValue)
	;-------------------------------------------------------------------------------
	; History:
	; 26-Mar-2009	GRF		SR16452: created
	;-------------------------------------------------------------------------------
	set pValue = $select(pValue[".":$justify(pValue,0,2),1:pValue)
	quit pValue
	
	
	;=============================================================  COMMON FUNCTIONS
	
	
ConvertLocaleNumber(pstrValue,YDECIMAL)
	;-------------------------------------------------------------------------------
	; Strip thousands delimiters and convert decimal place
	; in literal to internal numeric format change
	; 
	; 	Comma-Dot (English)  : Strip commas                            1,234.56 => 1234.56
	; 	Dot-Comma (European) : Strip dots and convert commas to dots   1.234,56 => 1234.56
	; 	      becomes
	; 	None-Dot  (Internal)
	; 
	; set fltValue = $$ConvertLocaleNumber^WWWTR(pstrValue,YDECIMAL)
	; 
	; History:
	; 23-May-2007	GRF		SR15525: created
	;-------------------------------------------------------------------------------
	new numValue
	
	;---------------------------------------
	; If necessary, calling routine should perform the following first.
	;    set:$get(YDECIMAL)="" YDECIMAL = $extract($$GetNumberDelimiters^COMUtilLocale(SPRACHE),2)
	;---------------------------------------
	
	if YDECIMAL=","  {
		set numValue = $translate(pstrValue,",.",".")      ; European
	} else {
		set numValue = $translate(pstrValue,",")           ; English
	}
	quit numValue
	
PerformCalculation(pstrCalc)
	;-------------------------------------------------------------------------------
	; Convert a calculation string starting with an equals character into an actual value.
	; 
	; = ### op ###                    (without spaces)
	; = ###
	; 
	; Where   op    can be     +, -, * or / 
	; and     ###   is any number
	; 
	; NOTE : doesn't handle leading + or - except in the single number version
	; 
	; History:
	; 08-Jun-2007	GRF		SR15525: created
	;-------------------------------------------------------------------------------
	new numValue
	
	set pstrCalc = $extract(pstrCalc,2,99)
	
	if (pstrCalc["-") {
		set numValue = $piece(pstrCalc,"-",1) - $piece(pstrCalc,"-",2)
		
	} elseif (pstrCalc["+") {
		set numValue = $piece(pstrCalc,"+",1) + $piece(pstrCalc,"+",2)
		
	} elseif (pstrCalc["*") {
		set numValue = $piece(pstrCalc,"*",1) * $piece(pstrCalc,"*",2)
		
	} elseif (pstrCalc["/") {
		if +$piece(pstrCalc,"/",2)'=0 set numValue = $piece(pstrCalc,"/",1) / $piece(pstrCalc,"/",2)
		
	} else {
		set numValue = +pstrCalc
	}
	quit numValue
		
GetConversionRate(pstrYFORM,pstrYKEY,&pstrRate)
	;-------------------------------------------------------------------------------
	; Attempt to execute the code and log an error on failure.
	;
	; Returns:
	;
	; History:
	; 01-Jun-2007	GRF		SR15525: was using YFORM rather than pstrYFORM
	; 15-Feb-2005	RPW		Do not log NOLINE errors at all.
	; 03-Feb-2005	RPW		Modified to show the error on the screen except for
	; 						NOLINE or NOROUTINE errors
	; 28-Jan-2005	RPW		Created (SR10061)
	;-------------------------------------------------------------------------------
	new strCode,strRate
	
	set strCode="set strRate=$$GetFCRate^"_pstrYFORM_"()"
	set $ztrap="ExecuteCodeError^WWWTR"
	xecute strCode
	if strRate'="" set pstrRate=strRate
	
	quit
	
ExecuteCodeError  ; Internal Tag
	new strUser,strError
	
	set $ztrap=""
	
	set strError=$zerror
	
	if ($get(^DebugExecuteCode,0)'=0)&&($find(strError,"<NOLINE>")=0) {
		set strUser=$get(YBED,"UNKNOWN")
		set ^ExecuteCodeError(strUser,$i(^ExecuteCodeError(strUser)),$zdt($h,3),"Code")=strCode
		set ^ExecuteCodeError(strUser,$i(^ExecuteCodeError(strUser)),$zdt($h,3),"Error")=strError
	}
		
	quit
	
Cur(Amount)
	;-------------------------------------------------------------------------------
	; Return Currency Code
	;
	; Returns:
	;
	; History:
	; 11-Apr-2005   PO		SR11349 Copied from ^COMSYSFC
	;-------------------------------------------------------------------------------
	new Base,Foreign,Currency,Rate
	
	do Split(Amount,.Base,.Foreign,.Currency,.Rate)
	
	quit Currency
	
ConvRate(Amount)
	;-------------------------------------------------------------------------------
	; Return Conversion Rate
	;
	; Returns:
	;
	; History:
	; 25-May-2007	GRF		SR15525: missing "@" in $length
	; 16-Jun-2005	PO		SR: Ensure Amount @ preceds FC amount
	; 30-May-2005   PO		SR12050: Created
	;-------------------------------------------------------------------------------
	new Base,Foreign,Currency,Rate
	
	; Convert "USD20@.8" to "@USD20@.8" so aligned correctly for Split
	
	;if $length(Amount)'=3 {                     ; SR15525
	if $length(Amount,"@")'=3 {
		if Amount?1.A.E {
			set Amount="@"_Amount
		}
	}
	
	do Split(Amount,.Base,.Foreign,.Currency,.Rate)
	
	quit Rate
	
FCBase(Amount)
	;-------------------------------------------------------------------------------
	; Return Base Amount
	;
	; Returns:
	;
	; History:
	; 01-Jun-2005   PO		SR12050: Created
	;-------------------------------------------------------------------------------
	new Base,Foreign,Currency,Rate
	
	do Split(Amount,.Base,.Foreign,.Currency,.Rate)
	
	quit Base
	
FCAmount(Amount)
	;-------------------------------------------------------------------------------
	; Return Foreign Amount
	;
	; Returns:
	;
	; History:
	; 25-May-2007	GRF		SR15525: missing "@" in $length
	; 16-Jun-2005	PO		SR: Ensure Amount @ preceds FC amount
	; 11-Apr-2005   PO		SR11349 Copied from ^COMSYSFC
	;-------------------------------------------------------------------------------
	new Base,Foreign,Currency,Rate
	
	; Convert "USD20@.8" to "@USD20@.8" so aligned correctly for Split
	
	;if $length(Amount)'=3 {    ; SR15525
	if $length(Amount,"@")'=3 {
		if Amount?1.A.E {
			set Amount="@"_Amount
		}
	}
	
	do Split(Amount,.Base,.Foreign,.Currency,.Rate)
	
	quit Foreign
	
Split(Amount,Base,Foreign,Currency,Rate)	
	;-------------------------------------------------------------------------------
	; Split FC Amount to Base Amount, Foreign Amount, Currency Code, Rate
	; 
	; By Ref : Base,Foreign,Currency,Rate
	; Returns:
	;
	; History:
	; 11-Apr-2005   PO		SR11349 Copied from ^COMSYSFC
	;-------------------------------------------------------------------------------
	new FC
	
	set Base = $piece(Amount,"@",1)
	set FC   = $piece(Amount,"@",2)
	set Rate = $piece(Amount,"@",3)
	
	set Foreign  = $translate(FC,"abcdefghijklmnopqrstuvwxyz$ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	set Currency = $translate(FC," -1234567890,.")
	
	quit
	
TestAll(pnumNewDP="")
	new SPRACHE,YDECIMAL
	do ^WWWVAR
	if pnumNewDP'="" set YDECIMALLEN=+pnumNewDP
	
	set SPRACHE="EN"      ; DD/MM/YYYY   ,.   NN:NN
	set YDECIMAL="."
	do Test
	set SPRACHE="FR"      ; MM/DD/YYYY   ,.   NN:NN
	set YDECIMAL="."
	do Test
	set SPRACHE="DE"      ; DD.MM.YYYY   .,   NN:NN:NN
	set YDECIMAL=","
	do Test
	set SPRACHE="PT]]><![CDATA["      ; DD/MM/YYYY   .,   NN:NN
	set YDECIMAL=","
	do Test
	set SPRACHE="PT"
	set YDECIMAL="."
	do Test
	set SPRACHE="JP"      ; YYYYMMDD     ,.   NN:NN
	set YDECIMAL="."
	do Test
	quit
	
Test
	new intShowDecs
	write !!,"(",SPRACHE,":",YDECIMAL,")",!
	/*
	; OUT
	w !!,"*** OUT ***"
	
	w !," 1>",$$Convert^WWWTRnew(0,1,"65432"),"<"             ; Date     23/02/2020
	
	w !," 2>",$$Convert^WWWTRnew(0,2,""),"<"                  ; Boolean
	w !," 2>",$$Convert^WWWTRnew(0,2,"0"),"<"
	w !," 2>",$$Convert^WWWTRnew(0,2,"1"),"<"
	w !," 2>",$$Convert^WWWTRnew(0,2,"-1"),"<"
	w !," 2>",$$Convert^WWWTRnew(0,2,"5"),"<"
	w !," 2>",$$Convert^WWWTRnew(0,2,"ABC1"),"<"
	w !," 2>",$$Convert^WWWTRnew(0,2,"ABC2"),"<"
	w !," 2>",$$Convert^WWWTRnew(0,2,"CHECKED"),"<"
	w !," 2>",$$Convert^WWWTRnew(0,2,"UNCHECKED"),"<"
	
	w !," 4>",$$Convert^WWWTRnew(0,4,"12345"),"<"             ; Integer
	w !," 4>",$$Convert^WWWTRnew(0,4,"0"),"<"
	w !," 4>",$$Convert^WWWTRnew(0,4,"12345.67"),"<"
	w !," 4>",$$Convert^WWWTRnew(0,4,"-12345"),"<"
	
	w !," 7>",$$Convert^WWWTRnew(0,7,"54321"),"<"             ; Time
	
	set YWHR="USD"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34"),"<"             ; Currency
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34@5.67"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34@USD10@1.234"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12345.6789"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12345"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,".6789"),"<"
	set YWHR="XYZ"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34"),"<"             ; Currency
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34@5.67"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34@USD10@1.234"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12345.6789"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12345"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,".6789"),"<"
	set YWHR=""
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34"),"<"             ; Currency
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34@5.67"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12.34@USD10@1.234"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12345.6789"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,"12345"),"<"
	w !," 8>",$$Convert^WWWTRnew(0,8,".6789"),"<"
	
	for intShowDecs="",2,5,8 {
		w !,"12>",$$Convert^WWWTRnew(0,12,"123456",intShowDecs),"<"   ; Floating
		w !,"12>",$$Convert^WWWTRnew(0,12,"123456.789123",intShowDecs),"<"
		w !,"12>",$$Convert^WWWTRnew(0,12,".789123",intShowDecs),"<"
	}
	
	w !,"14>",$$Convert^WWWTRnew(0,14,"65432,54321"),"<"      ; TimeStamp
	w !,"14>",$$Convert^WWWTRnew(0,14,"65432"),"<"
	
	w !,"17>",$$Convert^WWWTRnew(0,17,"20070605"),"<"         ; DateYMD
	
	for intShowDecs="",2,5,8 {
		w !,"18>",$$Convert^WWWTRnew(0,18,".8",intShowDecs),"<"       ; ForEx
		w !,"18>",$$Convert^WWWTRnew(0,18,"1.234567",intShowDecs),"<"
	}
	*/
	
	; IN
	w !!,"*** IN ***"
	/*
	w !," 1>",$$Convert^WWWTRnew(1,1,"."),"<"                  ; Date
	w !," 1>",$$Convert^WWWTRnew(1,1,"05.06.2007"),"<"         ;  5 June = 60786   6 May = 60756
	w !," 1>",$$Convert^WWWTRnew(1,1,"05/06/2007"),"<"
	w !," 1>",$$Convert^WWWTRnew(1,1,"15.06.2007"),"<"         ; 15 June = 60796  16 May = 60766
	w !," 1>",$$Convert^WWWTRnew(1,1,"05.16.2007"),"<"
	w !," 1>",$$Convert^WWWTRnew(1,1,"20070605"),"<"
	
	w !," 2>",$$Convert^WWWTRnew(1,2,""),"<"                   ; Boolean
	w !," 2>",$$Convert^WWWTRnew(1,2,"0"),"<"
	w !," 2>",$$Convert^WWWTRnew(1,2,"1"),"<"
	w !," 2>",$$Convert^WWWTRnew(1,2,"-1"),"<"
	w !," 2>",$$Convert^WWWTRnew(1,2,"5"),"<"
	w !," 2>",$$Convert^WWWTRnew(1,2,"ABC1"),"<"
	w !," 2>",$$Convert^WWWTRnew(1,2,"ABC2"),"<"
	w !," 2>",$$Convert^WWWTRnew(1,2,"CHECKED"),"<"
	w !," 2>",$$Convert^WWWTRnew(1,2,"UNCHECKED"),"<"
	
	w !," 3>",$$Convert^WWWTRnew(1,3,"ABC"_$c(13,10)_"DEF"),"<"    ; Memo
	
	w !," 4>",$$Convert^WWWTRnew(1,4,"123456"),"<"             ; Integer
	w !," 4>",$$Convert^WWWTRnew(1,4,"123,456"),"<"
	w !," 4>",$$Convert^WWWTRnew(1,4,"123.456"),"<"
	w !," 4>",$$Convert^WWWTRnew(1,4,"123456.789"),"<"
	w !," 4>",$$Convert^WWWTRnew(1,4,"123456,789"),"<"
	w !," 4>",$$Convert^WWWTRnew(1,4,"123,456.789"),"<"
	w !," 4>",$$Convert^WWWTRnew(1,4,"123.456,789"),"<"
	*/
	w !," 7>",$$Convert^WWWTRnew(1,7,"03:45"),"<"             ; Time
	w !," 7>",$$Convert^WWWTRnew(1,7,"03:45:10"),"<"
	w !," 7>",$$Convert^WWWTRnew(1,7,"23:45"),"<"
	w !," 7>",$$Convert^WWWTRnew(1,7,"23:45:10"),"<"
	/*
	set YWHR="USD"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12.34"),"<"              ; Currency
	w !," 8>",$$Convert^WWWTRnew(1,8,"USD12.34"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12.34@USD10@1.234"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12345.6789"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12345"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,".6789"),"<"
	set YWHR="XYZ"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12.34"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"USD12.34"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12.34@USD10@1.234"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12345.6789"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12345"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,".6789"),"<"
	set YWHR=""
	w !," 8>",$$Convert^WWWTRnew(1,8,"12.34"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"USD12.34"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12.34@USD10@1.234"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12345.6789"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,"12345"),"<"
	w !," 8>",$$Convert^WWWTRnew(1,8,".6789"),"<"
	
	
	for intShowDecs="",2,5,8 {
		w !,"12>",$$Convert^WWWTRnew(1,12,"123456",intShowDecs),"<"        ; Floating
		w !,"12>",$$Convert^WWWTRnew(1,12,"123,456",intShowDecs),"<"
		w !,"12>",$$Convert^WWWTRnew(1,12,"123.456",intShowDecs),"<"
		w !,"12>",$$Convert^WWWTRnew(1,12,"123456.789123",intShowDecs),"<"
		w !,"12>",$$Convert^WWWTRnew(1,12,"123.456,789123",intShowDecs),"<"
		w !,"12>",$$Convert^WWWTRnew(1,12,"123,456.789123",intShowDecs),"<"
	
		w !,"12>",$$Convert^WWWTRnew(1,12,".789123",intShowDecs),"<"
		w !,"12>",$$Convert^WWWTRnew(1,12,",789123",intShowDecs),"<"
	}
	
	
	w !,"13>",$$Convert^WWWTRnew(1,13,"123.012.210.001"),"<"  ; IPFormat
	w !,"13>",$$Convert^WWWTRnew(1,13,"123/012;210-001"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"256.123.210.542"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"255.255.255.255"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"0.0.0.0"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"000.000.000.000"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"000.000.000.001"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"001.001.001.001"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"127.000.000.001"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"127.0.0.1"),"<"
	w !,"13>",$$Convert^WWWTRnew(1,13,"10.0.0.55"),"<"
	
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.06.2007"),"<" ; TimeStamp
	w !,"14>",$$Convert^WWWTRnew(1,14,"05/06/2007"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"15.06.2007"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.16.2007"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"20070605"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.06.2007 03:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05/06/2007 03:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"15.06.2007 03:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.16.2007 03:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"20070605 03:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.06.2007 03:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05/06/2007 03:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"15.06.2007 03:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.16.2007 03:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"20070605 03:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.06.2007 23:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05/06/2007 23:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"15.06.2007 23:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.16.2007 23:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"20070605 23:45:10"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.06.2007 23:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05/06/2007 23:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"15.06.2007 23:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"05.16.2007 23:45"),"<"
	w !,"14>",$$Convert^WWWTRnew(1,14,"20070605 23:45"),"<"
	
	w !,"17>",$$Convert^WWWTRnew(1,17,"05.06.2007"),"<" ; DateYMD
	w !,"17>",$$Convert^WWWTRnew(1,17,"05/06/2007"),"<"
	w !,"17>",$$Convert^WWWTRnew(1,17,"15.06.2007"),"<"
	w !,"17>",$$Convert^WWWTRnew(1,17,"05.16.2007"),"<"
	w !,"17>",$$Convert^WWWTRnew(1,17,"20070605"),"<"
	*/
	for intShowDecs="",2,5,8 {
		w !,"18>",$$Convert^WWWTRnew(1,18,".8",intShowDecs),"<"       ; ForEx
		w !,"18>",$$Convert^WWWTRnew(1,18,"1.234567",intShowDecs),"<"
	}
	
	quit	
	
]]></Routine>
</Export>