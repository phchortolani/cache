<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="CACHE" ts="2001-01-01 00:00:00">
<Routine name="INRECReverse" type="MAC" languagemode="0" timestamp="58440,0"><![CDATA[
INRECReverse
#include COMSYS
#include INConst
#include FINConst
	
#define LogR(%1,%2) 	;
#define LogRx(%1)		;
#;define LogR(%1,%2) 	$$$JournalOff s ^zzLogR($g(YBED,"UNK"),$i(^zzLogR))= %1_"^INRECReverse("_%2_") : "_$zh $$$JournalOn
#;define LogRx(%1)		$$$JournalOff s ^zzLogR($g(YBED,"UNK"),$i(^zzLogR))=%1 $$$JournalOn
	;-------------------------------------------------------------------------------
	; History:
	; 04-Nov-2010	shobby	SR17599: Remove OldReverseTxn and OldReverseTxn2
	; 25-Mar-2009	GRF		SR16447: variable prefixes & common naming across tags
	;-------------------------------------------------------------------------------
	
	/*
oldReversible(pidRec) ; SR17262 replaced
	;-------------------------------------------------------------------------------
	; Is this record reversible?
	;
	; Params: pidRec	INREC key
	;
	; Returns: status
	;
	; History:
	; 23-Mar-2010	Petik	-: Name of the parameter is incorrect
	; 06-Jan-2010	GRF		SR17080: Check stocktake locking
	; 26-Feb-2009	DavidR	SR16020: moved the quit:$$$ISERR(strStatus) inside the 
	; 							for loop for lines check for QTYOH
	; 05-Feb-2009	DavidR	SR16020: Added a further check to ensure that the amount 
	; 							to be reversed is not greater than the amount that
	; 							is available to reverse, cannot return nil stock to
	; 							supplier
	; 07-Nov-2005	JW		SR13222: Created
	;-------------------------------------------------------------------------------
	new fltTotQty,idItem,idLine,idLocn,objREC,objRecLine,strStatus
	
	quit:$$$NoKey(pidRec) $$$OK
	set objREC = $get(^INREC(YM,pidRec,1))
		
	set strStatus = $$Editable^INREC(objREC,$$$EnumINRECSupplierReversal)

	; SR17080
	if $$$ISOK(strStatus) && (objREC'="") {
		if $$IsLockedStockLocation^INLocking($$$INRECLocation(objREC),$$$INRECStockLocation(objREC)) {
			set strStatus = $$ReasonLocked^INLocking($$$INRECLocation(objREC),$$$INRECStockLocation(objREC),"") ; blank string is dummy
		}
	}
		
	if $$$ISOK(strStatus) {	
		if '$data(^INRECLine(YM,pidRec)) {
			set strStatus = $$$MakeStatus("IN00371") ; "No receipts to reverse"
			
		} else {
			set strStatus = $$UpdateStatus(pidRec)	// Update the status of the lines
			
			if $$$ISOK(strStatus) {
				set idLine = ""
				for {
					set idLine = $order(^INRECLine(YM,pidRec,idLine))
					quit:idLine=""
					
					set objRecLine = $get(^INRECLine(YM,pidRec,idLine,1))
					set idItem     = $$$INRECLineItem(objRecLine)
					set idLocn     = $$$INRECLineLocation(objRecLine)
					set fltTotQty  = $$GetQuantityOnHand^INARTMENGE(idItem,idLocn)
				;	set fltBOHQty  = ##class(alSOH.iSOH).GetQtyOnHand(idItem,idLocn,"",$$$NO)  ; this is in case INARTMENGE is returning the wrong amount <DavidR>
					
					if $$$INRECLineQuantity(objRecLine) > fltTotQty {  ; "Cannot reverse line %1: Not enough items in storage"
						set strStatus = $$$MakeStatus("IN00372",idLine,$$$Text("IN00897"))
					}
					
					if $$$ISOK(strStatus) && '$$Reversible^INRECReverseLine(objRecLine) {  ; "Cannot reverse line %1: %2"
					;	set strStatus = $$$MakeStatus("IN00372",idLine,$$$AppEnum("INRECREVESESTATUS",$$$INRECLineReverseStatus(objRecLine))) ;Petik 23/03/2010
						set strStatus = $$$MakeStatus("IN00372",idLine,$$$AppEnum("INRECREVERSESTATUS",$$$INRECLineReverseStatus(objRecLine)))
					}
					quit:$$$ISERR(strStatus)
				}
			}
		}
	}
	
	if $$$ISOK(strStatus) {
		set YQ = $$$QSave
	} else {
		set YQ = $$$QDontSave_" "_$$$Text(strStatus)
	}
	quit strStatus
	*/
	
Reversible(pidRec)
	;-------------------------------------------------------------------------------
	; Is this record reversible?
	;
	; Params: pidRec	INREC key
	;
	; Returns: status
	;
	; History:
	; 27-Apr-2010	Karine	SR17262: Specific quantity match rather than total qty
	; 23-Mar-2010	Petik	-: Name of the parameter is incorrect
	; 26-Feb-2009	DavidR	SR16020: moved the quit:$$$ISERR(strStatus) inside the 
	; 							for loop for lines check for QTYOH
	; 05-Feb-2009	DavidR	SR16020: Added a further check to ensure that the amount 
	; 							to be reversed is not greater than the amount that
	; 							is available to reverse, cannot return nil stock to
	; 							supplier
	; 07-Nov-2005	JW		SR13222: Created
	;-------------------------------------------------------------------------------
	new dteUseByDate,fltQtyOH,idItem,idLine,idLocn,idStore
	new objREC,objRecLine,strStatus,strLotNumber
	
	quit:$$$NoKey(pidRec) $$$OK
	set objREC = $get(^INREC(YM,pidRec,1))
		
	set strStatus = $$Editable^INREC(objREC,$$$EnumINRECSupplierReversal)
	
	if (+$$$WWWClientParamCoreChangesHEVA($get(^WWWClientParam(0,0,1)))) {
		if $$$ISOK(strStatus){
			set strStatus = $$ValidaRecTypeofReceiving^VARINRECReverse(objREC)
		}
		if $$$ISOK(strStatus){
			set strStatus = $$ValidaRecFContabil^VARINRECReverse(objREC)
		}
	}
		
	if $$$ISOK(strStatus) {	
		if '$data(^INRECLine(YM,pidRec)) {
			set strStatus = $$$MakeStatus("IN00371") ; "No receipts to reverse"
			
		} else {
			set strStatus = $$UpdateStatus(pidRec)	// Update the status of the lines
			
			if $$$ISOK(strStatus) {
				set idLine = ""
				for {
					set idLine = $order(^INRECLine(YM,pidRec,idLine))
					quit:idLine=""
					
					set objRecLine   = $get(^INRECLine(YM,pidRec,idLine,1))
					set idItem       = $$$INRECLineItem(objRecLine)
					set idLocn       = $$$INRECLineLocation(objRecLine)
					set idStore      = $$$INRECLineStockLocation(objRecLine)  ; SR17262
					set strLotNumber = $$$INRECLineLotNumber(objRecLine)      ; SR17262
					set dteUseByDate = $$$INRECLineExpirationDate(objRecLine) ; SR17262
					
				;	set fltTotQty = $$GetQuantityOnHand^INARTMENGE(idItem,idLocn)
				;	set fltBOHQty = ##class(alSOH.iSOH).GetQtyOnHand(idItem,idLocn,"",$$$NO)  ; this is in case INARTMENGE is returning the wrong amount <DavidR>
					set fltQtyOH  = $$GetQtyOnHand(idItem,idLocn,idStore,strLotNumber,dteUseByDate) ; SR17262
					
				;	if $$$INRECLineQuantity(objRecLine) > fltTotQty {  ; "Cannot reverse line %1: Not enough items in storage" ; SR17262
					if $$$INRECLineQuantity(objRecLine) > fltQtyOH {   ; "Cannot reverse line %1: Not enough items in storage"
						set strStatus = $$$MakeStatus("IN00372",idLine,$$$Text("IN00897"))
					}
					
					if $$$ISOK(strStatus) && '$$Reversible^INRECReverseLine(objRecLine) {  ; "Cannot reverse line %1: %2"
					;	set strStatus = $$$MakeStatus("IN00372",idLine,$$$AppEnum("INRECREVESESTATUS",$$$INRECLineReverseStatus(objRecLine))) ;Petik 23/03/2010
						set strStatus = $$$MakeStatus("IN00372",idLine,$$$AppEnum("INRECREVERSESTATUS",$$$INRECLineReverseStatus(objRecLine)))
					}
					quit:$$$ISERR(strStatus)
				}
			}
		}
	}
	
	if $$$ISOK(strStatus) {
		set YQ = $$$QSave
	} else {
		set YQ = $$$QDontSave_" "_$$$Text(strStatus)
	}
	quit strStatus
	
	
Reverse(pidRec)
	;-------------------------------------------------------------------------------
	; Reverse the record
	;
	; Params: pidRec	INREC key
	;
	; Returns: status
	;
	; History:
	; 
	; 29-Mar-2006	JW		SR14422: Increment date, added INREC links
	; 01-Nov-2005	JW		SR13222: Created
	;-------------------------------------------------------------------------------
	new strStatus
	
	set strStatus = $$Transaction^COMTransaction("ReverseTxn^INRECReverse("""_pidRec_""")",$$$YES)
	if $$$ISOK(strStatus) {
		do ReloadForm^COMUtilForm()
	}
	quit strStatus
	
	
ReverseTxn(pidReceipt)
	;-------------------------------------------------------------------------------
	; For the Supplier Receipt Reversal specified by pidReceipt, reverse the original
	; Supplier Receipt quantity and update original Supplier Receipt for all lines
	;
	; Params: pidReceipt : key for reversal INREC record
	;
	; Returns:
	;
	; History:
	; 15-Feb-2010	GRF		SR17178: Perform cost adjustment AFTER CreateMovement
	; 							since that was updating avg cost based on new figure
	; 29-Oct-2009	GRF		SR16871: INStockValCCAdj with cost centre replaces
	; 							INStockValAdjust; explicit switch
	; 13-Oct-2009	GRF		SR16932: don't trim time from dteReceipt; pass original
	; 							receipt details to CacheReceiptReversal; call
	; 							LinkOrigReceipt
	; 06-Oct-2009	GRF		SR16928: ^CacheTempRECReverse only referenced by INWEAUF
	; 							(no longer used); stop on error from CreateMovement;
	; 							Include curEach and curTotal; error "IN01133"
	; 02-Oct-2009	GRF		SR16361: Implement changed code
	; 16-Sep-2009	GRF		SR16361: Original to OldReverseTxn; Remove INWEAUF(VOR)
	; 							processing; extend INARTAVG reference string
	; 27-Aug-2008	HQN		SR15829: Now call modified SAVE^INWEAUFVORS with
	; 							INWE/INARTHISTL removed, process V2 via movement
	; 							which back-populates INWE/INARTHISTL
	; 25-Aug-2008	HQN		SR15829: Added documentation header
	; 07-Apr-2008	shobby	SRBR014754: CacheTempHistoryTracking to leave an audit
	; 							trail in INARTHISTL
	;-------------------------------------------------------------------------------
	new curEach,curTotal,dteOrigRec,dteReceipt,fltQty,idAdj,idCostCentre,idItem
	new idLocn,idOrder,idOrdLine,idOrigLine,idOrigRecNo,idRecLine,idStore,idSupplier
	new objREC,objReceipt,objRecLine,strRecptRef,strStatus
	
	$$$LogR("ReverseTxn",$get(pidReceipt))
	
	quit:$get(pidReceipt)="" $$$MakeStatus("IN01133")  ; "No Receipt Number - unable to process"  SR16928
	
	set strStatus = $$Reversible(pidReceipt)
	
	if $$$ISOK(strStatus) {
		set ^CacheTempHistoryTracking(YUCI,YUSER,"SourceForm") = $$GetLineForm^INTFRInterface($get(YFORM),"INRECReverseLine")
		set idRecLine = ""
		for {
			set idRecLine = $order(^INRECLine(YM,pidReceipt,idRecLine))
			quit:idRecLine=""
			
			set ^CacheTempHistoryTracking(YUCI,YUSER,"SourceId") = pidReceipt_","_idRecLine
			
			set objRecLine  = $get(^INRECLine(YM,pidReceipt,idRecLine,1))
			set idOrder     = $$$INRECLineOrder1(objRecLine)
			set idOrdLine   = $$$INRECLineOrderLine(objRecLine)
			set idLocn      = $$$INRECLineLocation(objRecLine)
			set idStore     = $$$INRECLineStockLocation(objRecLine)
			set dteOrigRec  = $$$INRECLineReceiptDate(objRecLine)
			set idItem      = $$$INRECLineItem(objRecLine)
			set idOrigRecNo = $$$INRECLineReversesREC(objRecLine)     ; SR16932
			set idOrigLine  = $$$INRECLineReversesLine(objRecLine)
			
		;	set dteReceipt   = +$horolog                              ; SR16932
			set dteReceipt   = $horolog
			set idCostCentre = $$GetCostCentre^INCostCentre(idLocn)   ; SR16871
			
		;	set ^CacheTempRECReverse(YUSER,idOrder,idOrdLine,idLocn,idStore,dteReceipt) = dteOrigRec  ; DEPRECATED - INWEAUF replaced
		;	set strRecptRef = idOrder_","_idOrdLine_","_idLocn_","_idStore_","_dteReceipt_","_pidReceipt_","_idRecLine  ; SR16361
			
			if idItem'="" {  ; SR16928
				set idSupplier = $$$INRECLineSupplier(objRecLine)
				do RevOrderLine(pidReceipt,idRecLine,idOrder,idOrdLine,idItem,idSupplier,idLocn,dteOrigRec,objRecLine)
			}
	; SR17178 moved down
	;		// Cost adjustment
	;		set idAdj = $$$INRECLineAdjustmentReference(objRecLine)
	;		if idAdj'="" {
	;	;		set strStatus = $$Adjust^INStockValAdjust($$$INRECLineItem(objRecLine)_","_idAdj,,$$$NO)  ; SR16871
	;			set strStatus = $$Adjust^INStockValCCAdj($$$INRECLineItem(objRecLine)_$$$COMMA_idCostCentre_$$$COMMA_idAdj,$$$NO,$$$NO)
	;		}
			
			if $$$ISOK(strStatus) {    ; SR16932
				set strStatus = $$CacheReceiptReversal^INRECReceive(pidReceipt,idRecLine,
				                                                    $$$Index(idOrder),$$$Index(idOrdLine),
				                                                    dteReceipt,objRecLine,
				                                                    idOrigRecNo,idOrigLine)
			}
			
			if $$$ISOK(strStatus) && (idOrigRecNo'="") && (idOrigLine'="")  {    ; SR16932
				set strStatus = $$LinkOrigReceipt(pidReceipt,idRecLine,idOrigRecNo,idOrigLine)
			}
			
		;	if $$$ISOK(strStatus) set strStatus = $$CreateMovement(pidReceipt_","_idRecLine) ; SR16928 vvv
			if $$$ISOK(strStatus) {
				set fltQty      = $$$INRECLineQuantity(objRecLine)
				set curEach     = $$$INRECLineEach(objRecLine)
				set curTotal    = $$$INRECLineTotal(objRecLine)

				set strStatus   = $$CreateMovement(pidReceipt,idRecLine,idOrder,
				                                   idOrdLine,idItem,idLocn,
				                                   idStore,dteOrigRec,idOrigRecNo,
				                                   idOrigLine,fltQty,curEach,curTotal)
			}

	; SR17178 moved here
			if $$$ISOK(strStatus) {   // Cost adjustment
				set idAdj = $$$INRECLineAdjustmentReference(objRecLine)
				if idAdj'="" {
					set strStatus = $$Adjust^INStockValCCAdj($$$INRECLineItem(objRecLine)_$$$COMMA_idCostCentre_$$$COMMA_idAdj,$$$NO,$$$NO)
				}
			}
			


			quit:$$$ISERR(strStatus)     ; SR16928 ^^^
		}
		if $$$ISOK(strStatus) {
			set strStatus = $$UpdateHeader^INRECPost(pidReceipt)
		}
	}
	
	kill ^CacheTempHistoryTracking(YUCI,YUSER)
	quit strStatus
	
	
LinkOrigReceipt(pidReceipt,pidRecLine,pidOrigRecNo,pidOrigLine) private
	;-------------------------------------------------------------------------------
    ; Record the Reverse Receipt transaction line in the original Receipt line
    ; 
    ; Called By: ReverseTxn
    ; 
    ; History:
    ; 15-Oct-2009	GRF		SR16941: include 4th parameter in $$$Save
    ; 13-Oct-2009	GRF		SR16932: Created
	;-------------------------------------------------------------------------------
	new objOriginal,strStatus
	
	set objOriginal = $get(^INRECLine(0,pidOrigRecNo,pidOrigLine,1))
	set $$$INRECLineReversedByREC(objOriginal)  = pidReceipt
	set $$$INRECLineReversedByLine(objOriginal) = pidRecLine
	
	set strStatus = $$$Save("INRECLine",pidOrigRecNo_$$$COMMA_pidOrigLine,objOriginal,$$$YES)
	
	quit strStatus
	
	
RevOrderLine(pidReceipt,pidRecLine,pidOrder,pidOrdLine,pidItem,pidSupplier,pidLocn,pdteOrigRec,pobjRecLine) private
	;-------------------------------------------------------------------------------
	; Reverses a ReceiptOrderLine generated from a prior ReceiptLine
    ;
    ; ByRef: blnREVERSE
    ; 
    ; Called From: ReverseTxn()
    ;              (prev. SAVE^INWEAUFVORS() => Reverse^INWEAUFV2 based on INWEAUF
    ; 
    ; History:
    ; 11-Dec-2009	GRF		SR16962: Resets Completed switch but doesn't save; needs
    ; 							$$$INAUFPIncomingGoodsQuantity for testing
    ; 13-Oct-2009	GRF		SR16932: Quantity in INRECLine will always be positive
    ; 							so must reverse; keep qty in inventory units
	; 							separate for Purchase Journal; update Line Completed
	; 							flag in INAUFP (D60)
    ; 07-Oct-2009	GRF		SR16928: Moved from Reverse^INRECReceive & renamed to
    ; 							replace local wrapper; pass existing variables as
    ; 							parameters
	; 02-Oct-2009	GRF		SR16361: split off ReadyForDelivery for separate call
	; 14-Sep-2009	PPP		SR16888: Added the Location parameter to $$INARTAVG call
	; 							(Routine was still in development - Not required)
    ; 09-Sep-2009	GRF		SR16875: mixing qty in order units & cost in inventory
    ; 							units
    ; 01-Sep-2008	HQN		Documenting ByRef variables used
	; 28-Aug-2008	HQN		SR15829: Code cleanup, removing all logic not applicable
	; 							supplier receipts
	; 27-Aug-2008	HQN		SR15829: Copied from INWEAUF
	;-------------------------------------------------------------------------------
	new blnWithOrder,fltConvFactor,fltPrevQtyRecvd,fltRecvdQty,fltRecQtyIU
	new objOrderLine,strStatus
	
	$$$LogR("RevOrderLine",$get(pidReceipt)_","_pidRecLine_"<"_pidOrder_","_pidOrdLine_"<")
	
	set blnWithOrder = ((pidOrder'="") && (pidOrdLine'=""))    ; SR16361
	
	if blnWithOrder {
		set objOrderLine = $get(^INAUFP(0,pidOrder,pidOrdLine,1))
	} else {
		set objOrderLine = ""             ; FIXME : what are implications?
	}
	
	if $$$INVORGDRPOnlyForNetChange($get(^INVORG(YM,YM,1))) set ^INDRPNETCHANGE(0,pidItem,1)=""
	
	if blnWithOrder do ReadyForDelivery^INRECReceive(pidOrder,pidOrdLine,pobjRecLine,.objOrderLine,$$$NO)  ; SR16361

	set fltRecQtyIU     = -$$$INRECLineQuantity(pobjRecLine)            ; in Inventory Units ; SR16932 -ve
	set fltConvFactor   = $$GetUOMConversion^INUOMConversion(pidItem,$$$INRECLineOrderedUnit(pobjRecLine))
	set fltRecvdQty     = fltRecQtyIU / fltConvFactor                  ; Conversion Inventory to Order
	set fltPrevQtyRecvd = $$$INAUFPIncomingGoodsQuantity(objOrderLine) ; in Order Units                  ; FIXME : INRECLine function?
	
	if blnWithOrder {   ; SR16361
		set $$$INAUFPIncomingGoodsQuantity(^INAUFP(0,pidOrder,pidOrdLine,1)) = fltRecvdQty + fltPrevQtyRecvd  ; DIRECT WRITE
		set $$$INAUFPIncomingGoodsQuantity(objOrderLine)                     = fltRecvdQty + fltPrevQtyRecvd   ; SR16962
	
		; Update order line if the Delivery should be sent directly to the Customer for a Supplier Order
		; (Specified at order line or at order level)
		if ($$$INAUFPCustomerIsDeliveryAddress(^INAUFP(0,pidOrder,pidOrdLine,1))=$$$YES) ||
		   ($$$INAUFCustomerAddressinOrder($get(^INAUF(0,pidOrder,1)))          =$$$YES)    {
		
			do ReceiveToCustomer^INRECReceive(pidOrder,pidOrdLine,pobjRecLine)
		}
	}
	do PurchaseJournal^INRECReceive(pidSupplier,pidItem,pidOrder,pidOrdLine,pidReceipt,pidLocn,pdteOrigRec,fltRecQtyIU,$$$INRECLineFlag(pobjRecLine))
	
	if blnWithOrder && ($$$INAUFPIncomingGoodsQuantity(objOrderLine) < $$$INAUFPQuantity(objOrderLine)) {   ; SR16932
		set $$$INAUFPPosCompleted(objOrderLine) = $$$NO
		set strStatus = $$$Save("INAUFP",pidOrder_","_pidOrdLine,objOrderLine,$$$YES)   ; SR16962
	}
	quit
	
	
GetStatus(pidInvMatch) 
	;-------------------------------------------------------------------------------
	; Get the reverse status of the receipt
	;
	; Params: invMatchCache id
	;
	; Returns: Transaction Status
	;
	; History:
	; 27-Apr-2010	Karine	SR17262: The validation of the last receipt needs to
	; 							be between differents Receipts
	; 12-Oct-2009	GRF		SR16932: Check if date or time not found in match index
	; 06-Oct-2009	GRF		SR16928: Permit Receipts without order to be processed
	; 10-Nov-2005	JW		SR13822: Check item history not INWE
	; 10-Nov-2005	JW		SR13819: Check if receipted as well
	; 02-Nov-2005	JW		SR13222: Created
	;-------------------------------------------------------------------------------
	new blnWithOrder,dteReceipt,enumStatus,idItem,idxItemNo,idOrder,idOrdLine,idSource
	new idLastInvMatch,idLastSource,objInvMatch,tmeReceipt
	
	$$$LogR("GetStatus",pidInvMatch)
	set objInvMatch = $get(^FINAPInvMatchCache(0,pidInvMatch,1))
	
	set idOrder   = $$$FINAPInvMatchCacheSourceOrder(objInvMatch)
	set idOrdLine = $$$FINAPInvMatchCacheOrderLine(objInvMatch)
	set blnWithOrder = ((idOrder'="") && (idOrdLine'=""))     ; SR16928
	$$$LogRx("GS0:"_$$$FINAPInvMatchCacheReceipted(objInvMatch)_"<"_blnWithOrder_"<"_$$$FINAPInvMatchCacheCompleted(objInvMatch)_"<")
	
		// Already invoiced
	if ($$$FINAPInvMatchCachePreviouslyInvoicedValue(objInvMatch)'="") ||
	   ($$$FINAPInvMatchCacheInvoiceNumber(objInvMatch)'="")              {
		set enumStatus = $$$EnumINRECREVERSESTATUSInvoiced
		
		// Completed -> Already Reversed
	} elseif $$$FINAPInvMatchCacheCompleted(objInvMatch) ||
	        '$$$FINAPInvMatchCacheReceipted(objInvMatch)    {	     //SR13819
		set enumStatus = $$$EnumINRECREVERSESTATUSAlreadyReversed
		
		// Reservations
	;} elseif $data(^INRESERVIERT(YM,idOrder,idOrdLine)) {           ; SR16928
	} elseif blnWithOrder && $data(^INRESERVIERT(0,idOrder,idOrdLine)) {
		set enumStatus = $$$EnumINRECREVERSESTATUSOrderLinehasReservations
		
		// Customer Order
	;} elseif +$$$INAUFOrderType($get(^INAUF(YM,idOrder,1)))=0 {     ; SR16928
	} elseif blnWithOrder && (+$$$INAUFOrderType($get(^INAUF(0,idOrder,1)))=0) {
		set enumStatus = $$$EnumINRECREVERSESTATUSCustomerOrder
		
	} else {       // Check for other receipts
		set idSource   = $$$FINAPInvMatchCacheReceiptNumber(objInvMatch)  ;SR17262                                                ; <<<<<
		set idItem     = $$$FINAPInvMatchCacheItem(objInvMatch)
		set idxItemNo  = $$$Index(idItem)
		set dteReceipt = $order(^FINAPInvMatchCaches(0,4,idxItemNo," "),-1)
		if dteReceipt'="" {        ; SR16932
			set tmeReceipt = $order(^FINAPInvMatchCaches(0,4,idxItemNo,dteReceipt," "),-1)
			if tmeReceipt'="" {
				set idLastInvMatch = $order(^FINAPInvMatchCaches(0,4,idxItemNo,dteReceipt,tmeReceipt,""),-1)
				set idLastSource   = $$$FINAPInvMatchCacheReceiptNumber($get(^FINAPInvMatchCache(0,idLastInvMatch,1))) ;SR17262   ; <<<<<
		
	$$$LogRx("GS1:"_dteReceipt_"<"_tmeReceipt_"<"_idLastInvMatch_"<"_pidInvMatch)
						
			;	if idLastInvMatch '= pidInvMatch {       ;SR17262
				if idSource '= idLastSource {                                                                                     ; <<<<<
					set enumStatus = $$$EnumINRECREVERSESTATUSNotLastReceipt
					
				} else {   // Check if issued by looking at item history
					if blnWithOrder && $$IssueAfterReceipt^INARTHISTLUtils(idItem,idOrder,idOrdLine,
					                                       $$$FINAPInvMatchCacheLocation(objInvMatch),
					                                       $$$FINAPInvMatchCacheStockLocation(objInvMatch),
					                                       $$$FINAPInvMatchCacheReceiptDate(objInvMatch)) {
				
						set enumStatus = $$$EnumINRECREVERSESTATUSStockIssued
				
					} else {
						set enumStatus = $$$EnumINRECREVERSESTATUSCompletelyReversible
					}
				}
			} else {    ; no time
				set enumStatus = $$$EnumINRECREVERSESTATUSCompletelyReversible         ; ??? SR16932 error situation?
	$$$LogRx("GSx:Time")
			}
		} else {        ; no date
			set enumStatus = $$$EnumINRECREVERSESTATUSCompletelyReversible             ; ??? SR16932 error situation?
	$$$LogRx("GSx:Date")
		}
	}
	quit enumStatus
	
	
UpdateStatus(pidRec)
	;-------------------------------------------------------------------------------
	; Update reverse status of lines
	;
	; Params: pidRec	INREC key
	;
	; Returns: status
	;
	; History:
	; 03-Nov-2005	JW		SR13222: Created
	;-------------------------------------------------------------------------------
	new enumStatus,idInvMatch,idLine,objRecLine,strStatus
	
	set strStatus = $$$OK
	
	set idLine = ""
	for {
		set idLine = $order(^INRECLine(YM,pidRec,idLine))
		quit:idLine=""
		
		set objRecLine = $get(^INRECLine(YM,pidRec,idLine,1))
		set enumStatus = $$GetStatus($$$INRECLineCacheLink(objRecLine))
		
		if enumStatus '= $$$INRECLineReverseStatus(objRecLine) {
			set $$$INRECLineReverseStatus(objRecLine) = enumStatus
			set strStatus = $$$Save("INRECLine",pidRec_","_idLine,objRecLine,1)
		}
		quit:$$$ISERR(strStatus)
	}
	quit strStatus
	
	
GetQtyOnHand(pidItem,pidLocn,pidStore,pstrLotNo,pdteUseByDate)
	;-------------------------------------------------------------------------------
	; Called By: Reversible (SR17262)
	; 
	; History:
	; 11-May-2010	GRF		SR17262: Also calc when policy is "no lot number"
	; 27-Apr-2010	Karine	SR17262: Created
	;-------------------------------------------------------------------------------
	new intQty
	
	if pdteUseByDate'="" {
		&sql(
			SELECT SUM(QtyOnHand) into :intQty
			FROM alSOH.dBundleStock 
			WHERE
				Item=:pidItem                   AND
				Storage->Location=:pidLocn      AND
				Storage->Code=:pidStore         AND
				Bundle->LotNumber=:pstrLotNo    AND
				Bundle->UseByDate=:pdteUseByDate
		)
		
	} elseif pstrLotNo'="" {
		&sql(
			SELECT SUM(QtyOnHand) into :intQty
			FROM alSOH.dBundleStock 
			WHERE
				Item=:pidItem                   AND
				Storage->Location=:pidLocn      AND
				Storage->Code=:pidStore         AND
				Bundle->LotNumber=:pstrLotNo    AND
				Bundle->UseByDate IS NULL
		)
		
	} else {
		&sql(
			SELECT SUM(QtyOnHand) into :intQty
			FROM alSOH.dBundleStock 
			WHERE
				Item=:pidItem                   AND
				Storage->Location=:pidLocn      AND
				Storage->Code=:pidStore         AND
				Bundle->LotNumber IS NULL       AND
				Bundle->UseByDate IS NULL
		)
	}
	quit intQty
	
	
ListMostRecentReceipts(pYUSER,pidLocn)
	;-------------------------------------------------------------------------------
	; Create a Temp List with all the receipts that can be reversed
	; We can only reverse the last receipt for a particular item / supplier
	; 
	; Called By: BeforeButtonLine^INREC (SR17262)
	; 
	; Params:
	;
	; Returns: 
	;
	; History:
	; 12-May-2010	GRF		SR17262: Base on session id (YUSER) not user id (YBED);
	; 							CacheTempRecReversal replaces TempRevRec; INRECTemp
	; 							replaces TempListReversibleRec (idRec only in header)
	; 27-Apr-2010	Karine	SR17262: Created
	;-------------------------------------------------------------------------------
	new idItem,idRecNo,idSupplier,objRECTemp,objRevRec,strStatus
		
	;kill ^TempListReversibleRec(0,pYBED)
	kill ^INRECTemp(0,pYUSER)
	
	; This following will fill ^CacheTempRecReversal with the most recent receipt 
	; for the item / supplier combination
	; the data is in the format of an object ready to be put into ^INRECTemp
	do MostRecentRec(pYUSER,pidLocn)

	; Now we just copy the list of most recent into ^INRECTemp
	; ready for showing in the COMView
	set idItem = ""
	for {
		set idItem = $order(^CacheTempRecReversal(pYUSER,idItem)) 
		quit:(idItem = "")
		
		set idSupplier = ""
		for {
			set idSupplier = $order(^CacheTempRecReversal(pYUSER,idItem,idSupplier)) 
			quit:(idSupplier="")
			
			set objRevRec  = $get(^CacheTempRecReversal(pYUSER,idItem,idSupplier))
			set idRecNo    = $piece(objRevRec,Y,1)
		;	set idRevLine  = $piece(objRevRec,Y,2)
			set objRECTemp = $piece(objRevRec,Y,2,4)
			
	 ;   	set status = $$$Save("TempListReversibleRec",YUSER_","_idRecNo,objRevRec,$$$YES)
	    	set strStatus = $$$Save("INRECTemp",pYUSER_","_idRecNo,objRECTemp,$$$YES)
		}
	}
	quit
	
	
MostRecentRec(pYUSER,pidLocn)
	;-------------------------------------------------------------------------------
	; Find Receipts that can be reversed. 
	; Rules: Select all receipts that have the last item from a supplier.
	; GetStatus ensures only the last receipt for an item will be available.
	;
	; Params:
	;
	; Returns: TempView 
	;
	; History:
	; 20-May-2010	GRF		SR17262: check for missing receipt details
	; 12-May-2010	GRF		SR17262: Base on session id (YUSER) not user id (YBED);
	; 							CacheTempRecReversal replaces TempRevRec; variables
	; 26-May-2008	Karine	SR17262: Created
	;------------------------------------------------------------------------------- 
	new dteRecpt,idInvMatch,idItem,idOrder,idRecNo,idSupp,objINREC,objInvMatch
	
	kill ^CacheTempRecReversal(pYUSER)
	
	set idInvMatch = ""
	for {
		set idInvMatch = $order(^FINAPInvMatchCache(0,idInvMatch))
		quit:(idInvMatch = "")	
		
		set objInvMatch = $get(^FINAPInvMatchCache(0,idInvMatch,1))
		if ($$$FINAPInvMatchCacheLocation(objInvMatch)=pidLocn)                    &&
		   ($$GetStatus(idInvMatch)=$$$EnumINRECREVERSESTATUSCompletelyReversible)    {
		
			set idRecNo  = $$$FINAPInvMatchCacheReceiptNumber(objInvMatch)
			continue:idRecNo=""
			
			set idItem   = $$$FINAPInvMatchCacheItem(objInvMatch)
			set dteRecpt = $$$FINAPInvMatchCacheReceiptDate(objInvMatch)
			set objINREC = $get(^INREC(0,idRecNo,1))
			set idOrder  = $$$INRECReceiptSourceNo(objINREC)
			set idSupp   = $$$FINAPInvMatchCacheSupplier(objInvMatch)
			
			set ^CacheTempRecReversal(pYUSER,idItem,idSupp) = idRecNo_Y_dteRecpt_Y_idOrder_Y_idSupp
		}
	}
	quit
	
	
UpdateReceiptDetails(&pobjRecLine,pidLocn,pidStore,pdteReceipt)
	;-------------------------------------------------------------------------------
	; Update the INRECLine with the INWEAUF details
	; 
	; Called By:
	;	CreateLine^INRECLine
	;	CreateLine^INReceiptLine
	; 
	; Params:
	;
	; ByRefs:
	;
	; Returns:
	;
	; History:
	; 30-Oct-2009	GRF		SR16871: Pass Locn to INRECReverseLine
	; 05-Jun-2009	GRF		SR16591: GetINWEAUFKeys was always building a key set
	; 							based on today even though we were passing in the
	; 							actual date.seq key - returned null for each
	; 29-Mar-2006	JW		SR14421: Created
	;-------------------------------------------------------------------------------
	new objINWEAUF
	
	$$$LogR("UpdateReceiptDetails",pidLocn_","_pidStore_","_pdteReceipt)
	
	set $$$INRECLineLocation(pobjRecLine)      = pidLocn
	set $$$INRECLineStockLocation(pobjRecLine) = pidStore
	set $$$INRECLineReceiptDate(pobjRecLine)   = pdteReceipt
	
	;set objINWEAUF = $get(@("^INWEAUF(YM,"_$$^WWWKEYBUILD($$GetINWEAUFKeys^INRECLine(pobjRecLine))_",1)"))   ; SR16591
	set objINWEAUF = $get(^INWEAUF(0,$$$INRECLineOrder1(pobjRecLine),$$$INRECLineOrderLine(pobjRecLine),pidLocn,pidStore,pdteReceipt,1))
	
	set $$$INRECLineEach(pobjRecLine)          = $$$INWEAUFUnitPrice(objINWEAUF)
	set $$$INRECLineTotal(pobjRecLine)         = $justify($$$INRECLineEach(pobjRecLine) * $$$INRECLineQuantity(pobjRecLine),0,2)
	set $$$INRECLineReverseStatus(pobjRecLine) = $$GetStatus($$$INRECLineCacheLink(pobjRecLine))
	set $$$INRECLineAverageCost(pobjRecLine)   = $$GetAverageCost^INRECReverseLine(pobjRecLine,pidLocn)   ; SR16871
	
	$$$LogRx("URD:"_$$$INRECLineEach(pobjRecLine))
	
	quit
	
	
CostDetails()
	;-------------------------------------------------------------------------------
	; Go to the stock value adjustment page for the current line
	;
	; Params:
	;
	; Returns:
	;
	; History:
	; 29-Oct-2009	GRF		SR16871: INStockValCCAdj with cost centre replaces
	; 							INStockValAdjust
	; 07-Nov-2005	JW		SR13222: Created
	;-------------------------------------------------------------------------------
	new idCostCentre,idKey,idLocn,objRecLine
	
	set objRecLine = $$GetYFELDEX^COMGridEdit31Interface() // Get current line
	
	;set idKey = $$$INRECLineItem(objRecLine)_","_$$$INRECLineAdjustmentReference(objRecLine)  ; SR16871
	;do GoToForm^COMGridEdit31Interface("INStockValAdjust",idKey)
	
	set idLocn       = $$$INRECLineLocation(objRecLine)
	set idCostCentre = $$GetCostCentre^INCostCentre(idLocn)
	set idKey = $$$INRECLineItem(objRecLine)_$$$COMMA_idCostCentre_$$$COMMA_$$$INRECLineAdjustmentReference(objRecLine)
	do GoToForm^COMGridEdit31Interface("INStockValCCAdj",idKey)
	quit
	
	
AfterDelete(pidREC)
	;-------------------------------------------------------------------------------
	; Perform after delete on lines as well
	;
	; Params:
	;
	; ByRefs:
	;
	; Returns:
	;
	; History:
	; 23-Oct-2006	JW		SR15134: Look at kill status.
	; 24-Apr-2006	JW		SR14421: Created
	;-------------------------------------------------------------------------------
	new idLine,strStatus
	
	set strStatus = $$$OK
	
	set idLine = ""
	for {
		set idLine = $order(^INRECLine(YM,pidREC,idLine))
		quit:idLine=""
		
		set strStatus = $$AfterDelete^INRECReverseLine($get(^INRECLine(YM,pidREC,idLine,1))) //SR15134
		quit:$$$ISERR(strStatus)
	}
	if $$$ISERR(strStatus) {
		set Q = $$$QDontDelete		//SR15134
	}
	
	quit
	
	
CreateMovement(pidReceipt,pidRecLine,pidOrder,pidOrdLine,pidItem,pidFromLocn,pidFromStore,pdteOrigRec,pidOrigRecNo,pidOrigLine,pfltQty,pcurEach,pcurTotal) private
	;-------------------------------------------------------------------------------
	; Creates a alREC.dMovement, but specify the MovementType as reversal
	; 
	; History:
    ; 07-Oct-2009	GRF		SR16928: Pass existing variables as parameters; get
    ; 							original receipt details from backlinks in INRECLine
    ; 							(passed in) before trying to get from INRECLines
    ; 							(retain code for older receipts); include Unit and
    ; 							Extended Costs
	; 02-Sep-2009	GRF		SR16361: Implement use of INRECLine rather than INWEAUF
	; 25-Mar-2009	GRF		SR16447: objRec15 based on original receipt line not the
	; 							order line 
	; 01-Sep-2008	HQN		code cleanup, formatting comments, newing variables
	; 25-Aug-2008	HQN		SR15829: Created
	;-------------------------------------------------------------------------------
	new idActualReceipt,idActualLine,objMove,objRec15,sc,strStatus
	
	set strStatus  = $$$OK
	
	;	Can only reverse the latest receipt - may need to check for completed receipts, skipping if unprocessed
	;	Validation occurs on selection - still applicable if delay before reversal processed?
	
	if (pidOrigRecNo'="") && (pidOrigLine'="") {  ; SR16928
		set objRec15 = ##class(alREC.dUReceiptLine).%OpenId("0||"_pidOrigRecNo_"||"_pidOrigLine)
		
	} elseif (pidOrder'="") && (pidOrdLine'="") {
		set idActualReceipt = $order(^INRECLines(0,4,$$$Index(pidOrder),$$$Index(pidOrdLine),""),-1)
		if idActualReceipt'="" {
			set idActualLine = $order(^INRECLines(0,4,$$$Index(pidOrder),$$$Index(pidOrdLine),idActualReceipt,""),-1)
		}
		set objRec15 = ##class(alREC.dUReceiptLine).%OpenId("0||"_idActualReceipt_"||"_idActualLine)
	} else {
		set strStatus = $$$MakeStatus("IN01131")  ; "Can not reverse older Receipt without Order"
	}
	
	if $$$ISOK(strStatus) {
		set objMove = ##class(alREC.dMovement).%New()
		set objMove.MovementType = ##class(alDRP.dMovementType.ReceiptReverse).%New()
		set objMove.Item         = ##class(alINV.iUINV).GetItem(pidItem)
		set objMove.FromLocn     = ##class(alLOC.iLOC).GetLocation(pidFromLocn)
		set objMove.FromStorage  = ##class(alLOC.iLOC).GetStorage(pidFromL]]><![CDATA[ocn,pidFromStore)
		set objMove.ToLocn       = ##class(alLOC.iLOC).GetLocation(pidFromLocn)    ; FIXME : should this be null? <GRF>
		set objMove.ToStorage    = ""
		set objMove.Bundle       = objRec15.Bundle
		set objMove.Reference    = pidReceipt
		set objMove.LineNumber   = pidRecLine
		set objMove.QtyPicked    = 0
		set objMove.QtyReceived  = pfltQty
		set objMove.QtyRequired  = 0
		set objMove.Supply       = ""
		set objMove.Demand       = ""
		set objMove.Completed    = $$$NO
		set objMove.OrderNumber  = pidOrder
		set objMove.OrderLine    = pidOrdLine
		set objMove.ReceiptDate  = pdteOrigRec          ; SR16875
	 	set objMove.ExtendedCost = pcurTotal
		set objMove.UnitCost     = pcurEach
		
		set sc = objMove.ChangeState(4)
		set:$$$ISERR(sc) strStatus = $$ISStatusToDLStatus^COMUtilError(sc)
	}
	
 	quit strStatus
	
	
GetINREC(pidRec)                  ; get a receipt
	quit $get(^INREC(YM,pidRec,1))
	
GetINRECLine(pidRec,pidLine)      ; get a receipt line
	quit $get(^INRECLine(YM,pidRec,pidLine,1))
	
GetINRECLineReverseStatus(pidREC,pidLine)
	quit $$$INRECLineReverseStatus($$GetINRECLine^INRECReverse(pidREC,pidLine))
	
GetINRECLineComplete(pidREC,pidLine)
	quit $$$INRECLineComplete($$GetINRECLine^INRECReverse(pidREC,pidLine))
	
 	; basic API : 
 	; $$IsAReverseLine^INRECReverse(pidREC,pidLine) - find out if this line is a line 
 	; from a reversal document
 	; $$IsReversed^INRECReverse(pidREC,pidLine) - find out if there is a reversal of 
 	; this normal receiving line
	
IsAReverseLine(pidREC,pidLine)
	; call this to find out if this in INRECLine represents a reversal
	new enumStatus
	
	set enumStatus = $$GetINRECLineReverseStatus(pidREC,pidLine)
	if enumStatus = 0 {   ; "Completely Reversible"                ; we may change this
		quit $$$YES
	}
	quit $$$NO
	
	
ReversedBy(pidOrigRec,pidOrigLine)
	;-------------------------------------------------------------------------------
	; find out which line in INRECLine reverses this one (if none, return empty string)
	;-------------------------------------------------------------------------------
	;
	; FIXME : Should make use of INRECLine D52-D59 - not currently populated <GRF>
	;
	new dteReceived,idLocn,idOrder,idOrdLine,idStore
	new objOrigLine,objINWEAUF,strCalcOrig,strKeys,strOrigKeys,strResult
	
	set objOrigLine = $$GetINRECLine^INRECReverse(pidOrigRec,pidOrigLine)
	set strOrigKeys = pidOrigRec_","_pidOrigLine
	
	set strResult = ""
	set idOrder   = $$$INRECLineOrder1(objOrigLine)
	set idOrdLine = $$$INRECLineOrderLine(objOrigLine)
	set idLocn    = $$$INRECLineLocation(objOrigLine)
	set idStore   = $$$INRECLineStockLocation(objOrigLine)
	
	if $get(idOrder) '= "" { ; otherwise may be a transfer
		set dteReceived = ""
		for {
			set dteReceived = $order(^INWEAUF(YM,idOrder,idOrdLine,idLocn,idStore,dteReceived))
			quit:dteReceived=""
			
			set strKeys = $$GetINRECLineKeysFromINWEAUF^INRECReverse(idOrder,idOrdLine,idLocn,idStore,dteReceived)
			if ($$IsAReverseLine^INRECReverse($$$KEY1(strKeys),$$$KEY2(strKeys))) {
				set strCalcOrig = $$ReverseLineToOrigReceiptLine($$$KEY1(strKeys),$$$KEY2(strKeys))
				if (strCalcOrig = strOrigKeys) {
					set strResult = strCalcOrig    ; ReceiptNo,ReceiptLine or null
					quit
				}				
			}
		}
	}
	quit strResult
	
	
IsReversed(pidOrigRec,pidOrigLine)
	;-------------------------------------------------------------------------------
	; is this line reversed by any other in INRECReverse
	;-------------------------------------------------------------------------------
	new strResult
	
	;quit ($$ReversedBy(pidOrigRec,pidOrigLine)'="")   ; FIXME - Better solution <GRF>
	set strResult = $$ReversedBy(pidOrigRec,pidOrigLine)
	if strResult = "" {
		quit $$$NO
	} 
	quit $$$YES
	
	
SetReverseStatus(pidRec,pidLine,val)
	new objLine,strStatus
	
	set objLine = $$GetINRECLine(pidRec,pidLine)
	set $$$INRECLineReverseStatus(objLine) = val
	set strStatus = $$Save^COMUtils("INRECLine",pidRec_","_pidLine,objLine,1)
	
	quit strStatus
	
	
ReverseLineToOrigReceiptLine(pidREC,pidLine)
	;-------------------------------------------------------------------------------
	; takes keys to an INRECLine for a reversal
	; and returns keys to the original receipt it's reversing
	; 
	; Params :
	; 	pidREC - id of the reversal receipt header
	; 	pidLine - id of the reversal receipt line
	;
	; Returns : 
	; 	keys - a string containing two pieces idREC,idLine
	;-------------------------------------------------------------------------------
	; FIXME : Should make use of INRECLine D52-D59 - not currently populated <GRF>

	new dteReceived,objLine,idLocn,idOrder,idOrdLine,idStore
	
	set objLine = $$GetINRECLine(pidREC,pidLine)
	
	set idOrder     = $$$INRECLineOrder1(objLine)
	set idOrdLine   = $$$INRECLineOrderLine(objLine)
	set idLocn      = $$$INRECLineLocation(objLine)
	set idStore     = $$$INRECLineStockLocation(objLine)
	set dteReceived = $$$INRECLineReceiptDate(objLine)
	
	;	SR16361 TODO
	if dteReceived '= "" {
		;write !,"B "_idOrder_","_idOrdLine_","_idLocn_","_idStore_","_dteReceived
		quit $$GetINRECLineKeysFromINWEAUF(idOrder,idOrdLine,idLocn,idStore,dteReceived)

	} else {
		;write !,"No date ... maybe no record"
	}
	
	quit ""
	
	;-------------------------------------------------------------------------------
	;   * * *   D E P R E C A T E D   C O D E   * * *    vvvvv
	;-------------------------------------------------------------------------------
	
	
GetINWEAUF(pidOrder,pidLine,pidLocn,pidStore,dteSeq) ; DEPRECATED - with removal of INWEAUF(VOR)
	quit $get(^INWEAUF(YM,pidOrder,pidLine,pidLocn,pidStore,dteSeq,1))
	
	
GetINRECLineKeysFromINWEAUF(pidOrder,pidOrdLine,pidLocn,pidStore,pidDte) ; DEPRECATED - with removal of INWEAUF(VOR)
	new objLine
	set objLine = $$GetINWEAUF(pidOrder,pidOrdLine,pidLocn,pidStore,pidDte)
	quit $$$INWEAUFReceivingNumber(objLine)_","_$$$INWEAUFIncomingGoodsLine(objLine)
	
	
ReverseLineToOriginalReceiptLine(pidREC,pidLine)   ; DEPRECATED - tag is too long
	quit $$ReverseLineToOrigReceiptLine($get(pidREC),$get(pidLine))
	
		
	
OldReverseTxn2(pidReceipt)   ; DEPRECATED SR16928  Second version
	;-------------------------------------------------------------------------------
	; For the Supplier Receipt Reversal specified by pidReceipt, reverse the original
	; Supplier Receipt quantity and update original Supplier Receipt for all lines
	;
	; Params: pidReceipt : key for reversal INREC record
	;
	; Returns:
	;
	; History:
	; 02-Oct-2009	GRF		SR16361: Implement changed code
	; 16-Sep-2009	GRF		SR16361: Original to OldReverseTxn; Remove INWEAUF(VOR)                     [IN PROGRESS]
	; 							processing; extend INARTAVG reference string
	; 27-Aug-2008	HQN		SR15829: Now call modified SAVE^INWEAUFVORS with
	; 							INWE/INARTHISTL removed, process V2 via movement
	; 							which back-populates INWE/INARTHISTL
	; 25-Aug-2008	HQN		SR15829: Added documentation header
	; 07-Apr-2008	shobby	SRBR014754: CacheTempHistoryTracking to leave an audit
	; 							trail in INARTHISTL
	;-------------------------------------------------------------------------------
	new dteOrigRec,dteReceipt,idAdj,idItem,idLocn,idOrder,idOrdLine,idRecLine,idStore
	new objREC,objReceipt,objRECLine,strRecptRef,strStatus

	new receiptKeys
	
	quit:$get(pidReceipt)="" $$$OK ; FIXME: HQN: This is an error, shouldn't be returning OK
	
	set strStatus = $$Reversible(pidReceipt)
	
	if $$$ISOK(strStatus) {
		set ^CacheTempHistoryTracking(YUCI,YUSER,"SourceForm") = $$GetLineForm^INTFRInterface($get(YFORM),"INRECReverseLine") ;BR014754 ;BR014754
		set idRecLine = ""
		for {
			set idRecLine = $order(^INRECLine(YM,pidReceipt,idRecLine))
			quit:idRecLine=""
			
			set ^CacheTempHistoryTracking(YUCI,YUSER,"SourceId") = pidReceipt_","_idRecLine ;BR014754
			
			set objRECLine = $get(^INRECLine(YM,pidReceipt,idRecLine,1))
			set idOrder    = $$$INRECLineOrder1(objRECLine)
			set idOrdLine  = $$$INRECLineOrderLine(objRECLine)
			set idLocn     = $$$INRECLineLocation(objRECLine)
			set idStore    = $$$INRECLineStockLocation(objRECLine)
			set dteOrigRec = $$$INRECLineReceiptDate(objRECLine)
			set idItem     = $$$INRECLineItem(objRECLine)
			
			// Create a reverse INWEAUFVOR record and then transfer
	;		set objReceipt	= $get(^INWEAUF(YM,idOrder,idOrdLine,idLocn,idStore,dteOrigRec,1))
	;		
	;		set $$$INWEAUFIncomingGoodsQuantity(objReceipt) = -$$$INWEAUFIncomingGoodsQuantity(objReceipt)
	;		set $$$INWEAUFQuantityInStockSet(objReceipt)	= ""
	;		set $$$INWEAUFCompleteWEQuantity(objReceipt)	= ""
	;		set $$$INWEAUFReceivingNumber(objReceipt)		= pidReceipt	//SR14422
	;		set $$$INWEAUFIncomingGoodsLine(objReceipt)		= idRecLine
			
	;		set dteReceipt = $$Increment^INWECounter($$$INRECLineItem(objRECLine),idLocn,idStore,dteOrigRec)
			set dteReceipt = +$horolog
			set ^CacheTempRECReverse(YUSER,idOrder,idOrdLine,idLocn,idStore,dteReceipt) = dteOrigRec	//SR14422
			set strRecptRef = idOrder_","_idOrdLine_","_idLocn_","_idStore_","_dteReceipt_","_pidReceipt_","_idRecLine  ; SR16361
			
	;		set strStatus = $$$Save("INWEAUFVOR",strRecptRef,objReceipt,1)
	;		if $$$ISOK(strStatus) {
				
				; TODO : save INAUFP, etc - ignore INWE*?  (YKEY,blnREVERSE=$$$NO,blnV2Processing)
				
				do OldRevOrderLine(pidReceipt,idRecLine,idOrder,idOrdLine,idItem,idLocn,idStore,dteOrigRec,strRecptRef,objRECLine)
				
				if $$$ISOK(strStatus) {   // Cost adjustment
					set idAdj = $$$INRECLineAdjustmentReference(objRECLine)
					if idAdj'="" {
						set strStatus = $$Adjust^INStockValAdjust($$$INRECLineItem(objRECLine)_","_idAdj,,$$$NO)
					}
				}
	;		}
			quit:$$$ISERR(strStatus)     ; FIXME : What if there is an error in CreateMovement - still go on to other lines <GRF>
			set strStatus = $$OldCreateMovement(pidReceipt_","_idRecLine)
		}
		if $$$ISOK(strStatus) {
			set strStatus = $$UpdateHeader^INRECPost(pidReceipt)
		}
	}
	
	kill ^CacheTempHistoryTracking(YUCI,YUSER) ;BR014754
	quit strStatus
	
	; DEPRECATED SR16928
OldRevOrderLine(pidReceipt,pidRecLine,pidOrder,pidOrdLine,pidItem,idLocn,idStore,dteOrigRec,pstrRecptRef,pobjRECLine)

	; original
	;set strStatus = $$SAVE^INWEAUFVORS(strRecptRef,$$$YES,$$$YES)	// Transfer receipts ; SR15829 27-Aug-2008 HQN
	; replacement - to be reduced and put here
	do Reverse^INRECReceive(pidReceipt,pidRecLine,pobjRECLine,pstrRecptRef)  ; idINWEAUF,objINWEAUF

	quit
	
OldCreateMovement(pidRecLine)  ; SR16928 - REPLACED
	;-------------------------------------------------------------------------------
	; Creates a alREC.dMovement, but specify the MovementType as reversal
	; 
	; History:
	; 02-Sep-2009	GRF		SR16361: Implement use of INRECLine rather than INWEAUF
	; 25-Mar-2009	GRF		SR16447: objRec15 based on original receipt line not the
	; 							order line 
	; 01-Sep-2008	HQN		code cleanup, formatting comments, newing variables
	; 25-Aug-2008	HQN		SR15829: Created
	;-------------------------------------------------------------------------------
	new dteReceived,idActualRecLine,idFromLocn,idFromStore,idRec,idLine,idOrder,idOrdLine
	new idReceiptIn,objMove,objOrdReceived,objRec15,sc,objRecLine,strStatus
	
	set idRec  = $$$KEY1(pidRecLine)
	set idLine = $$$KEY2(pidRecLine)
	
	set strStatus  = $$$OK
	set objRecLine = $get(^INRECLine(YM,idRec,idLine,1))
	
	if objRecLine = "" {
		set strStatus = $$$MakeStatus("Can't find Receipt Line")    ; FIXME : language text
		
	} else {
		set idOrder     = $$$INRECLineOrder1(objRecLine)      ; SR16447
		set idOrdLine   = $$$INRECLineOrderLine(objRecLine)   ; SR16447
		set idFromLocn  = $$$INRECLineLocation(objRecLine)
		set idFromStore = $$$INRECLineStockLocation(objRecLine)
		set dteReceived = $$$INRECLineReceiptDate(objRecLine)
		
	;	SR16361 vvv
	;	Can only reverse the latest receipt - may need to check for completed receipts, skipping if unprocessed  ; SR16928 FIXME
		set idReceiptIn = $order(^INRECLines(0,4,$$$Index(idOrder),$$$Index(idOrdLine),""),-1)
		if idReceiptIn'="" {
			set idActualRecLine = $order(^INRECLines(0,4,$$$Index(idOrder),$$$Index(idOrdLine),idReceiptIn,""),-1)
		}
		
		;set objOrdReceived  = $get(^INWEAUF(YM,idOrder,idOrdLine,idFromLocn,idFromStore,dteReceived,1))
		;set idReceiptIn     = $$$INWEAUFReceivingNumber(objOrdReceived)
		;set idActualRecLine = $$$INWEAUFIncomingGoodsLine(objOrdReceived)            ; SR16447
	;	SR16361 ^^^
		
	;	set idActualRecLine = $order(^INRECLines(0,4,$$$Index(idOrder),$$$Index(idOrdLine),idReceiptIn,""))            ; SR16447
	;	set objRec15 = ##class(alREC.dUReceiptLine).%OpenId("0||"_idReceiptIn_"||"_$$$INRECLineOrderLine(objRecLine))  ; SR16447
		set objRec15 = ##class(alREC.dUReceiptLine).%OpenId("0||"_idReceiptIn_"||"_idActualRecLine)
		
		set objMove = ##class(alREC.dMovement).%New()
		set objMove.MovementType = ##class(alDRP.dMovementType.ReceiptReverse).%New()
		set objMove.Item         = ##class(alINV.iUINV).GetItem($$$INRECLineItem(objRecLine))
		set objMove.FromLocn     = ##class(alLOC.iLOC).GetLocation(idFromLocn)
		set objMove.FromStorage  = ##class(alLOC.iLOC).GetStorage(idFromLocn,idFromStore)
		set objMove.ToLocn       = ##class(alLOC.iLOC).GetLocation(idFromLocn)    ; FIXME : should this be null? <GRF>
		set objMove.ToStorage    = ""
		set objMove.Bundle       = objRec15.Bundle
		set objMove.Reference    = idRec
		set objMove.LineNumber   = idLine
		set objMove.QtyPicked    = 0
		set objMove.QtyReceived  = $$$INRECLineQuantity(objRecLine)
		set objMove.QtyRequired  = 0
		set objMove.Supply       = ""
		set objMove.Demand       = ""
		set objMove.Completed    = $$$NO
		set objMove.OrderNumber  = idOrder      ; $$$INRECLineOrder1(objRecLine)      ; SR16447
		set objMove.OrderLine    = idOrdLine    ; $$$INRECLineOrderLine(objRecLine)   ; SR16447
		set objMove.ReceiptDate  = dteReceived          ; SR16875
		
		set sc = objMove.ChangeState(4)
		set:$$$ISERR(sc) strStatus = $$ISStatusToDLStatus^COMUtilError(sc)
	}
 	quit strStatus
	
	
	;-------------------------------------------------------------------------------
	;   * * *   D E P R E C A T E D   C O D E   * * *    ^^^^^
	;-------------------------------------------------------------------------------
	
]]></Routine>
</Export>