<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="CACHE" ts="2001-01-01 00:00:00">
<Routine name="COMCodeCheck" type="MAC" languagemode="0" timestamp="58440,0"><![CDATA[
COMCodeCheck ; Code Check
	; Used to Check Code via a Template
	; Template csp Code:
	; <csp:StudioInteractiveTemplate  name="Code Check" type="MAC,INT" >
	; <SCRIPT LANGUAGE="CACHE" RUNAT="SERVER">	
	;  do Code^COMCodeCheck($G(%request.Data("Name",1)))
	; </SCRIPT>
	
#include WWWConst
#include COMSYS
#include %occInclude
	
	;---------------------------------------
	;   TODO :
	;    - Don't report $get missing on kill commands  
	;--------------------------------------- 

Routine(Name)
	;-------------------------------------------------------------------------------
	; 07-Jul-2003	SCR			Removed Fixed IP and Namespace
	; 03-Jul-2003	SCR			Size Check
	; Get Code for a Routine
	;-------------------------------------------------------------------------------
	new Code,Glo,Line,Routine
	set Glo="^rMAC"
	if $zcvt($piece(Name,".",$length(Name,".")),"l")="int" {
		set Glo="^ROUTINE"
	}

	set Routine=$piece(Name,".",1,$length(Name,".")-1)
	set Code=""
	set Line=0
	if Routine'="" {
		for {
			set Line=$order(@Glo@(Routine,0,Line))
			quit:'Line
			set Code=Code_@Glo@(Routine,0,Line)_$c(13,10)
			;if $Length(Code)>31000 set Code=Code_" ; Routine Greater than 31000" quit 
		}
	}
	quit Code
 
Code(Name) ; Template entry point
	;-------------------------------------------------------------------------------
	; History:
	; 13-Mar-2007	RPW		SR15448: Don't need /csp/?/
	; 21-Apr-2006	JW		SR14421: Always check INT Code
	;-------------------------------------------------------------------------------
	new Rtn

	if $zconvert($piece(Name,".",$length(Name,".")),"U")="MAC" {
		set $piece(Name,".",$length(Name,"."))="INT"
	}
	set Rtn=$tr(Name,".")
	
	&html<<html>
<head>
<script language="JavaScript" type="text/javascript">
 
 
</script>
 
</head>
<body>
<script language="JavaScript" type="text/javascript">
  
 window.open("COM.CodeCheck.cls?Code=<%=Name%>","<%=Rtn%>");
</script>
<FORM id="FormClose"   METHOD="post">
	<INPUT TYPE="text">
 	<INPUT TYPE="post" id="P" VALUE="OK" NAME="s">
</FORM>
 
</body>
</html>
	>
	
	quit
 
 
DecodeLine(pstrLine="")
	new In,Out,synColor,i
	
	if pstrLine'="" {
		set In       = ##class(%GlobalCharacterStream).%New()
		set Out      = ##class(%GlobalCharacterStream).%New()
		set synColor = ##class(%Library.SyntaxColor).%New()
		do In.WriteLine(pstrLine)
		do synColor.Color(In,Out,"COS","SPF")
		set pstrLine=""
		for {
			set i=32000
			set pstrLine=pstrLine_Out.ReadLine(.i)
			quit:i=-1
		}
	}
	quit pstrLine
	
	
Show(Name,pblnShowHTML=$$$YES,pblnStrictParameterCheck=$$$NO,pstrNameSpace="")
	;-------------------------------------------------------------------------------
	;
	; Params:	Name						- 
	; 			pblnShowHTML				- 
	; 			pblnStrictParameterCheck	- Whether parameters need to be explicitly defined before use
	;
	; ByRefs:
	;
	; Returns:
	;
	; History:
 	; 30-Jul-2009	shobby	SRAdhoc: Can check COMLocks. Made SALLock redundant.
    ; 10-Nov-2008	SCR		SR16128: Log Strings in CacheTempCodeCheck
	; 17-Jan-2008	GRF		SRBR014492: Added zzCodeCheck for analysis
	; 01-Nov-2006	JW		SR15160: Doco.
	; 19-Jul-2005	RPW		SR12981: Use %Library.Routine, it's working correctly.
	; 09-Feb-2005	shobby	pblnStrictParameterCheck
	; 03-Feb-2005	sh/RW	Removed the 31000 character limitation. (Still warns)
	; 07-Jul-2003	SRC		Added Error Loging & Separate Screen
	; 03-Jul-2003	SCR		End Of File Check on streams
	;-------------------------------------------------------------------------------
	new Count,Errors,Glo,In,Line,NewErrors,Out,Style,Var,dtCompiled,i,intLen,objFile
	new strCSS,strCurrentNameSpace,strHTML,strNSpace,strOutFile,strRtn,strTag,strType
	new synColor

	
	if pstrNameSpace'="" { 
		set strCurrentNameSpace = $znspace 
		set $znspace = pstrNameSpace
	}
	
	if $get(^SysSetup("CodeCheck")) kill ^zzCodeCheck
	
	if Name="" {
		do List^COMCodeCheckShow()
		quit 0
	}
 
	if pstrNameSpace'="" { 
		set strCurrentNameSpace = $znspace 
		set $znspace = pstrNameSpace
	}
	
	set Glo="^mtemp(""CodeCheck"",$job)"
	;set Code=$$Routine(Name)
	kill @Glo
	;set In      = ##class(%GlobalCharacterStream).%New()
	set In       = ##class(%Routine).%New(Name)
	set Out      = ##class(%GlobalCharacterStream).%New()
	set Style    = ##class(%GlobalCharacterStream).%New()
	set synColor = ##class(%Library.SyntaxColor).%New()
	
	if $get(^SysSetup("CodeCheckRemote")) {
		
		set strOutFile	= $get(^SysSetup("CodeCheckRemote","CSSFile"))
		set intLen		= 9999999999
		set objFile		= ##class(%File).%New(strOutFile)
		do objFile.Open("RU") 
		set strCSS		= objFile.Read(.intLen)
	
		set strOutFile	= $get(^SysSetup("CodeCheckRemote","HtmlFile"))
		set intLen		= 9999999999
		set objFile		= ##class(%File).%New(strOutFile)
		do objFile.Open("RU") 
		set strHTML		= objFile.Read(.intLen)
	}
	if pblnShowHTML {
		&html<
			<HTML> 
			<HEAD>,
			<META HTTP-EQUIV= "Content-Type" content="text/html; charset=iso-8859-1">
			<STYLE>
		>
		if $get(^SysSetup("CodeCheckRemote")) {
			write !!,$get(strCSS),!! 
			write !!,$get(strHTML),!! 
		} else {

			do synColor.GetCSS(Style,"COS")
			write !!!
			for {
			
				set i=32000 set Line=Style.ReadLine(.i)
				quit:i=-1
				quit:Line=""
				write Line,!
			}
			do synColor.GetCSS(Style,"HTML")
			write !!!
			for {
			
				set i=32000 set Line=Style.ReadLine(.i)
				quit:i=-1
				quit:Line=""
				write Line,!
			}
			do synColor.GetCSS(Style,"JS")
			write !!!
			for { 
				
				set i=32000 set Line=Style.ReadLine(.i)
				quit:i=-1
				quit:Line=""
				write Line,!
			}
		} 
		&html<
			</STYLE>
			</HEAD>
			<BODY>  
			<font size=3>
			Code Check of <%=Name%> at <%=$zdt($h,3)%><br>
		>
		write "<A HREF=""#Error1"">  Error</A><br>"
	}
	if $get(^SysSetup("CodeCheckRemote")) {
		
		do RemoteIn(In,synColor,pblnShowHTML,Glo,pblnStrictParameterCheck,Name)
	}
	if '$get(^SysSetup("CodeCheckRemote"))	 {
		do MultipleIn(In,synColor,pblnShowHTML,Glo,pblnStrictParameterCheck,Name)
	}
	set Errors=$get(@Glo@("Error"))
	set NewErrors=$get(@Glo@("NewError"))
	if pblnShowHTML {
		write !
		set Var=""
		for Count=1:1 {
			set Var=$order(@Glo@("Bad",Var))
			quit:Var=""
			if Count>1 write ","
			write Var
		}
		if In.Size>31000&&('$get(^SysSetup("CodeCheckRemote"))) {
			 write "<pre>Routine Greater than >31000 characters = "_In.Size_"</pre>"
		}
		
		
 	 	write "<br><b>"
		write "<A NAME=""Error"_(Errors+1)_"""></A>"_Errors_" Errors " 
	 	if Errors { 
	 		for Count=1:1:Errors {
		 		write " <A HREF=""#Error"_Count_""">"_Count_"</A> "
		 	} 
	 	}
	 	if 'Errors write "Code Ok"
		if NewErrors {
			write "<br> The following Tag(s) have missing newed variables <br>"
			for Count=1:1:NewErrors {
				set strTag = $get(@Glo@("NewError",Count))
				write " <A HREF=""#NewError"_(Count)_"""> "_strTag_"</A> "	
			}	
		}	
 		&HTML<</b>
		</BODY>
		>
	}
	; SR16128
	kill ^CacheTempCodeCheck("Text",Name)
	merge ^CacheTempCodeCheck("Text",Name)=@Glo@("Text")
	kill @Glo

	set strType	= $piece(Name,".",$length(Name,"."))
	;if strType="MAC" {
		set strRtn	= $piece(Name,".",$length(Name,".")-1)
		set strNSpace	= $znspace
		set dtCompiled	= $get(^rMAC(strRtn,0))
		set ^%COMRoutineLog(2,$znspace,strRtn,"Errors")	= Errors
		set ^%COMRoutineLog(2,$znspace,strRtn,"Compiled")	= ""
	;}
	if pstrNameSpace'="" { 
		set $znspace = strCurrentNameSpace
	}

	quit Errors_","_NewErrors
	
Class(pLine,pintTokenNo)
	;-------------------------------------------------------------------------------
	; Get Class rather than Token
	; 
	; History:
	; 02-Jan-2008	GRF		Created
	;-------------------------------------------------------------------------------
	new strClass,strSeg
	
	set strSeg   = $piece(pLine,"<SPAN",pintTokenNo)
	set strClass = $piece(strSeg,"""",2)
	
	quit strClass
	
Token(Line,TokenNumber,&Class)
	;-------------------------------------------------------------------------------
	; Get Token 
	; 
	; History:
	; 10-Apr-2007	RPW		SR15220: Removed extra unnecessary code.
	;-------------------------------------------------------------------------------
	new Seg,Text
	
	set Seg   = $piece(Line,"<SPAN",TokenNumber)
	set Class = $piece(Seg,"""",2)
	set Text  = $piece($piece(Seg,">",2),"<",1)
	quit Text
	 
Decode(Number,Line,Glo,&Vars,pblnShowHTML=1,pblnStrictParameterCheck=0,Name="",&pblnClass=$$$NO)
    ;/*------------------------------------------------------------------------------
    ; Decode Line
    ;  
    ; Params:	Name 		- name of routine
    ; 
    ; ByRefs:	pblnClass	- whether this comes from a class file
    ; 
    ; Definitions of COS_:
    ; 00 - Error in code
    ; 01 - Free Space 
    ; 03 - Tag
    ; 05 - "##class"
    ; 06 - String constant
   	; 07 - Comment
   	; 08 - dot in dot notation
   	; 09 - & for transfering to another language
   	; 0D - ( ) , ^ [ ] |
   	; 0F - $$ tag prefix
   	; 10 - ! ( in write statements)
   	; 11 - cache functions ($piece,$zcvt,$order etc)
   	; 12 - Global reference
   	; 13 - @ (indirection)
   	; 14 - variable usage
   	; 16 - Parameter
   	; 17 - numeric constant
   	; 18 - comparison/assignment operator (= < > . ' etc)
   	; 19 - routine reference
   	; 1F - Class Name
   	; 20 - cache commands (new,set,if,for,quit,kill,do,write)
   	; 24 - method for class
   	; 2A - { } condition wrappers.
   	; 
    ;
    ; History:
    ; 12-Sep-2014	SCR		CORE-312: Check for unused Code
    ; 23-Jul-2014	SCR		SESDF-1411 Bug fix on % Code
    ; 03-Mar-2011	GRF		Add YUSERAGENT (MSIE/FF/etc)
    ; 09-Jul-2009	GRF		Don't bother to check "YM" on classes
    ; 10-Nov-2008	SCR		SR16128: Log Strings in CacheTempCodeCheck
	; 20-Aug-2008	FIS		SR15853: check usage of CacheTemp (always use ^CacheTemp*(YUSER...))
	; 17-Jan-2008	GRF		SRBR014492: Added zzCodeCheck for analysis
    ; 17-Jan-2008	GRF		SRBR014492: Peer - removed FIX ME
    ; 16-Jan-2008	shobby	SRBR014492: Test for LastCmd seemed to prevent reporting
    ; 							of missing $get
    ; 11-Jan-2008	GM		SRBR014492: Put in comments condition to fix error when
    ; 							using $order
    ; 02-Jan-2008	GRF		Don't report missing $GET for "$$TAG^ROUTINE(,params)"
    ; 02-Jan-2008	GRF		System variable list rewritten for easier maintenance and
    ; 							to remove duplicated entries
    ; 12-Jun-2007	RPW		SR<>: 
    ; 10-Apr-2007	RPW		SR15220: Handle s x=^joe and set x=^[ns]joe and added elses
    ; 27-Feb-2007	JW		SR15452: $increment also defines the variable
    ; 01-Nov-2006	JW		SR15160: Added pblnClass - ignore vars, allow abbreviated fns.
    ; 						Better error msg for shared/company classes.
    ; 						Allow comma separated commands on the same line.
    ; 18-Jul-2006	JW		SR14832: Added $increment
    ; 30-Jun-2006	RPW		SR14580: Added YPRINTERNAME,YPRINTERLOCATION
    ;  7-Oct-2005	JW		SR13637: Check WWWDATEN shared status, but not keys.
    ; 02-Sep-2005	PO		SR12965: Added DLDPStorage
    ; 15-Jul-2005	RPW		SR12981: Added YOLDV,YPARA1,YVOR
    ; 14-Feb-2005	shobby	Exit for loop if Token returns a blank string.
    ; 09-Feb-2005	shobby	pblnStrictParameterCheck
    ; 02-Feb-2005	shobby	Ignore a few Y variables - YKOMMA,YCR,YBED,YGIF,YM,YUSER,Y
    ; 02-Feb-2005	shobby	Ignore WWWDATEN in primary key check.  We know it doesn't follow the rules.
    ; 28-Oct-2004	Paul K	Include check for correct number of primary keys
	; 25-Oct-2004	Paul K	Ignore Variable FMFELD
	; 28-Jun-2004	Paul K	Ignore Variables that start with "g"
	; 28-Jun-2004	Paul K	Ignore Tags with a "%" in them
	; 02-Jun-2004	SCR		Tag Checking
	; 17-Jul-2003	SCR		Stop Var warning on 'Merge' command
	; 13-Jul-2003	SCR		Included vars used in the 'Read' command in the 'Set' vars list
	; 11-Jul-2003	SCR		Correction
	; 08-Jul-2003	SCR		Added more direct global access checing
	; 03-Jul-2003	SCR		Added Shared File Checking, SPRACHE,LANGUAGE,Q added to System Vars
	; 02-Jul-2003	SCR		Added VORG to System Vars
	; 02-Jul-2003	SCR		Added 'Kill' Command to Set Check
    ;-----------------------------------------------------------------------------*/

	new ANMClass,Class,Cmd,Company,Count,Function,LastClass,LastText,New,Ok,Shared
	new Start,System,Tag,Text,Token,Type,Variable1,Variable2,arrError,intBracketCount
	new intErrorLine,intInBrackets,intKeys,intLastLineError,intNumKeys,intOffset
	new intVar,strBracket,strFns,strLastTag,strNewLine,strString,strTempText,strText
	new strTokenSpan,strVar,strVariable,strVars,strClass

	if $extract(Line,1,22)="<SPAN CLASS=""COS_03"">%" {  ; Line Starts with % = SQL Compiled code, Stop Checking
		set @Glo@("SQLStop")=1
	}
	if $get(@Glo@("SQLStop")) quit  ; SQL Compiled Code , Quit
	;if pblnShowHTML write "["_Number_"]"_Line
	set Start="<SPAN"
	set Count=$length(Line,Start)
	
	; vvvvv FIXME : <GRF> strFns not used in this routine
	set strFns = "$sortbegin$get$"                   ;"$get$data$order$increment$query$sortbegin$sortend$"	//SR15160
	if pblnClass $$$Prepend(strFns,"$g$d$o$i$q")		// Abbreviations are ok in cls->int code
	; ^^^^^
	set strClass	= ""
	set intInBrackets=0	//SR15160
	kill @Glo@("LineErrors")
	set @Glo@("LineErrors")=0
	set intLastLineError=0
	for Token=2:1:Count {
		set Text=$$Token(Line,Token,.Class)
		if $get(^SysSetup("CodeCheck")) set ^zzCodeCheck(Number+1,Token) = Class_":"_Text
		
		if Class="COS_1F" {
			set strClass	= strClass_Text		
		} else {
			if strClass'="" {
				set ^CacheTempCCUsed("c",strClass,Name)=$get(^CacheTempCCUsed("c",strClass,Name))+1
				set strClass =	""
			}
		}
		if Class'="COS_01" {
			set New=""
			
		;	Tag
		;-----------------------------------
			
			if (Class="COS_03") && (Token=2) {
				set New="Tag"
				if $translate($zcvt(Line,"I","HTML"),$char(160)," ")'["Internal Tag" {
					set strLastTag	= $get(@Glo@("Current","Tag"))
					do:strLastTag'="" TagEnd(Glo,strLastTag,pblnShowHTML)
					kill @Glo@("var")
					kill @Glo@("tag")
					set @Glo@("Current","Tag")=Text
				}
			
		;	Routine
		;-----------------------------------
			
			} elseif Class="COS_19" { // SR15220
				set ^CacheTempCCUsed("r",Text,Name)=$get(^CacheTempCCUsed("r",Text,Name))+1
				set Tag="^"_Text
				set LastText=$$Token(Line,Token-2,.LastClass)
				if LastClass="COS_03" set Tag=LastText_Tag
				if $text(@Tag)="" && '$find(Tag,"%") {
					; Try to Compile
					do ROUTINE^%R($piece(Tag,"^",2)_".mac",,.arrError,"LCS")
					if $text(@Tag)="" {
						do Error("Tag Error "_Tag,"Tag",pblnShowHTML,Glo)
					}
				}
				if (Tag="Save^COMUtils") || (Text="WWWSPEI") {
					set LastText=$$Token(Line,Token+2,.LastClass)
					if LastClass="COS_06" {
						set strSave	= $piece($piece(LastText,";",2),"&",1)
						if strSave'="" {
							set strSave	= "^"_strSave
							set ^CacheTempCCUsed("g",strSave,Name)=$get(^CacheTempCCUsed("g",strSave,Name))+1
						}
					}
				}
			
		;	Caché Commands
		;-----------------------------------
			
			} elseif Class="COS_20" { // SR15220
				set New="Cmd"
				set Cmd = $$$LOWER($extract(Text))
				set @Glo@("tag","LastCmd")      = Cmd
				set @Glo@("tag","LastCacheCmd") = Cmd						// Store last cache command - SR15160
				set @Glo@("tag","Command Count") = $get(@Glo@("tag","Command Count"))+1
				if Cmd="b" do Error(" Break!!!","Break",pblnShowHTML,Glo)
		/* SR15160
				set @Glo@("tag","LastCmd")=$zcvt($extract(Text,1),"l")
				if @Glo@("tag","LastCmd")="b" do Error(" Break!!!","Break",pblnShowHTML)
		*/
				kill @Glo@("tag","Equal")
			
		;	Bracket Levels  ( ) , ^ [ ] |
		;-----------------------------------
			
			} elseif Class="COS_0D" {	          // SR15160 - record how many brackets we are inside
												  // SR15220: handle s x=^joe and set x=^[ns]joe
												  
				if (Text = "(") && ($get(@Glo@("tag","LastCmd"))="n") {  ; exclusive NEW
					set @Glo@("tag","New All")=1
				}
				if (Text [ "(") || (Text = "[") {
					set intInBrackets = intInBrackets + 1
					
				} elseif (Text = ")") || (Text = "]") {
					set intInBrackets = intInBrackets - 1
					
				} elseif (Text = ",") && (intInBrackets=0) { // If we have a "," re-set the last command if not in brackets
					if $data(@Glo@("tag","LastCacheCmd")) {
						set @Glo@("tag","LastCmd") = @Glo@("tag","LastCacheCmd")
					}
					
				} else {
					if Text="^[" set intInBrackets=intInBrackets+1
					set Cmd=$get(@Glo@("tag","LastCmd"))
					if "mrskf"'[Cmd {
						// RHS
						set strBracket=$$Token(Line,Token-1)
						if strBracket'="(" {
							; do nothing
						
						} elseif $$Class(Line,Token-2)="COS_19" {
							; do nothing - $$TAG(,param)     ; 02-Jan-2008
				
		;-----------------------------------
		; QUERY  : What about $G?
		; ANSWER : Standards require full commands - This is okay. <GRF>
		;-----------------------------------
				; Commented BR014492
				;		} elseif $$$UPPER($$Token(Line,Token-2))'="$GET" {
				;			do Error("Direct Global Ref (use $get)","Glo",pblnShowHTML)	 ; *** 1
						
						} else {
							set @Glo@("tag","LastCmd")="s"
						}
					}
				}
			
		;	comparison/assignment operator (= < > . ' etc)
		;-----------------------------------
			
			} elseif Class="COS_18" { // SR15220
				set New="="
				set @Glo@("tag","Equal")=1
				set @Glo@("tag","LastCmd")="="
			
		;	Global
		;-----------------------------------
			
			} elseif Class="COS_12" { // SR15220
				set New="Global"					// If we have a global where last cache command was in fswiq
				
				set ^CacheTempCCUsed("g",Text,Name)=$get(^CacheTempCCUsed("g",Text,Name))+1
				
				if $get(@Glo@("tag","LastClass"))="COS_18" {
		;			if @Glo@("tag","LastCmd")="s" {                ; BR014492  // cannot get into here
					if @Glo@("tag","LastCacheCmd")="s" {				
						do Error("Direct Global Ref (use $get)","Glo",pblnShowHTML,Glo)      ; *** 2
					}
				}
				if $get(@Glo@("tag","LastClass"))="COS_0D" {
					set Function=$zcvt($$Token(Line,Token-2),"l")_"$"		// ^global
					set Ok=0
					if @Glo@("tag","LastCmd")="s"						set Ok=1 ; Set $piece(^A,Y,1)=2 is ok
					if "$get$data$order$increment$query$sortbegin$sortend$name$"[Function		set Ok=1 ; $Get or $Data is ok
 
					if Ok=0 {
						do Error("Direct Global Ref (use $get)","Glo",pblnShowHTML,Glo)      ; *** 3
					}
				}
	; FIXME : Recognise YUSER anywhere in argument list  e.g. ^CacheTemp("Type",YUSER,...) ; 20-Jun-2011 allow in 2nd place regardless of 1st arg
				// vvvvvv ;SR15853 ;always use ^CacheTemp*(YUSER)
				if ($extract(Text,1,10)="^CacheTemp") && ($get(@Glo@("tag","LastClass"))="COS_20") && (@Glo@("tag","LastCmd")="s") {  //set ^CacheTemp*
					set Variable1=$zcvt($$Token(Line,Token+2),"l")		// ^CacheTemp*(Variable...
					set Variable2=$zcvt($$Token(Line,Token+4),"l")		// ^CacheTemp*(Variable,Variable2...
					set Ok=0
					if $find(",yuser,",","_Variable1_",") set Ok=1
					if $find(",yuser,",","_Variable2_",") set Ok=1   ; 20-Jun-2011
					if $find(",$job,",","_Variable1_",") set Ok=1
					if $find(",$job,",","_Variable2_",") set Ok=1  
					if $find(",$znspace,",","_Variable1_",") set Ok=1
					if $find(",$znspace,",","_Variable2_",") set Ok=1  
					if (Ok=0) {
						do Error("Check CacheTemp Separator (use ^CacheTemp*(YUSER,...))","Glo",pblnShowHTML,Glo)
					} elseif (Ok=-1) {
						do Error("Namespace not required for CacheTemp Separator (use ^CacheTemp*(YUSER,...))","Glo",pblnShowHTML,Glo)
					}
				}
				// ^^^^^^^^^ */
				
				; @Net Manager Shared File Check
				set ANMClass=$extract(Text,2,99)
				if $extract(ANMClass,$length(ANMClass))="s" { ; Index Check
					if (ANMClass'="")&&('$data(^WWW001(0,ANMClass,1))) {
						set ANMClass=$extract(ANMClass,1,$length(ANMClass)-1)
					}
				} 
				if (ANMClass'="") && ($data(^WWW001(0,ANMClass,1))) {		//SR13637
					set Shared=$piece($get(^WWW001(0,ANMClass,1)),"~",3) ; Get Shared Flag
					if $$Token(Line,Token+1)="(" { ; Look for "("
						set Company=$$Token(Line,Token+2) ;
						;if Shared && (Company'="0") {
						;	Do Error("Shared Class '"_ANMClass_"' should use 0 ","Class",pblnShowHTML,Glo)
						;	
						;} elseif 'Shared&&(Company="0") {            ; 09-Jul-2009
						;	Do Error("Company Class '"_ANMClass_"' should use YM ","Class",pblnShowHTML)
 						;}
					}
					if (ANMClass'="WWWDATEN") && ($zcvt($extract($$Token(Line,Token-2),1,2),"l")="$g") {
						set strVariable=$$Token(Line,Token-4)
						if strVariable'="" set @Glo@("var",strVariable)=ANMClass
						set intBracketCount=1
						set intNumKeys=""
						set intOffset=1
						for {
							quit:intBracketCount=0
							set intOffset=intOffset+1
							set strText=$$Token(Line,Token+intOffset)
							quit:strText="" ;14-Feb-2005
							
							if strText="("  set intBracketCount = intBracketCount + 1
							if strText="^(" set intBracketCount = intBracketCount + 1
							if strText=")"  set intBracketCount = intBracketCount - 1
							if strText="," if intBracketCount=1 set intNumKeys = intNumKeys + 1
						}
						set intKeys=$order(^WWW002(0,ANMClass,""),-1)
						if intNumKeys'=(intKeys+1)&&('$$$WWW001NoCompilemappedclass($get(^WWW001(0,ANMClass,1)))) {
							Do Error("Class '"_ANMClass_"' requires "_intKeys_" keys","Class",pblnShowHTML,Glo)
						}
					}
				}
				
		;	Parameter
		;-----------------------------------
			
			} elseif Class="COS_16" { // SR15220
				set New="Param"
				set @Glo@("tag","v",Text)="p"
				if ('pblnStrictParameterCheck)||($$Token(Line,Token+1)="=") {
					set @Glo@("tag","s",Text)=.1
				}
				
		;	Variable
		;-----------------------------------
			
			} elseif Class="COS_14" { // SR15220
				set New="Var"
				set Type=$extract(Text,1)
				set System=0
				
				/*
				if (Type="g")||(Type="%")||(",YLIGHTGREY,YLFN,YYKEY,YMFELD,YFORM,YKEY,YHTMFORM,YDECIMAL,YGIF1,YCOUNTRY,YTRAKT,YANZ,YNAME,YNUMMER,YSCREENM,YPOSLOCATION,YDDSATZ,YURL,YNOFOOT,YWHITE,YOPTION1,YFKEY,YOPTION,YBACKGROUNDCOLOR,YFONTCOLOR,YTOOLTIP,YBEDBER,YFELD,YINHALT,YHID,YOPTION,YVOR,YGRAY,YRETVAL,YQUERY,YBACK,YLOCATION,YPWD,YAKTION,YUCI,YAUSWAHL,YRED,YPARA,YDARKGRAY,YWHR,Y,YSEITE,YUSER,YM,YGIF,YQ,YBED,YCR,YKOMMA,VORG,Q,LANGUAGE,SPRACHE,ANZM,FMFELD,URL,YTARGET,YUMLAU,"[(","_Text_",")) set System=1
				; THIS LIST SHOULD BE CHECKED CONSTANTLY! These are maybes.
				if (",YOLDV,YPARA1,YKOPF,YTABLEANZ,YVOR1,YPROZ,YYAKTION,YKILL,YFOCUSID,YMAXKEY,YDAT,YDATEI,REL,PARA,RELF,SUCH,YTEXT,YTIMEFORM,YAM,YWIDTH,YHEIGHT,YBBNMAX,YCOL,YSUCH,YR,YROW,YKLFN,YCOLOFF,YLENGTH,YCOLON,YCOLOFF,YPADDING,YFTYPE,YENABLED,DLDP,DLDPStorage,YBBN,YREQUIRED,YGRIDGRAY,YGRIDWHITE,YALIGN,YDECIMALLEN,YLFDAT,YVALIGN,YFONT,YFONTSIZE,YART,YFIELDNAME,YTYP,YTXT,YOK,YFOCUS,YPRINTERNAME,YPRINTERLOCATION,YIGNOREJUMP,"[(","_Text_",")) set System=1 // SR<>
				*/
				
				;---------------------------
				; Review list of recognised variables regularly
				; Add in alphabetical order
				;---------------------------
				
				if (Type="g") || (Type="%")  || (Type="G") {
					 set System=1
				
				} elseif $extract(Text,1)'="Y" {
					if ",ANZM,DLDP,DLDPStorage,FMFELD,LANGUAGE,PARA,Q,REL,RELF,SPRACHE,SUCH,URL,VORG,"					[ (","_Text_",") {
						set System=1
					}
				
				} else {
					if ",Y,YM," [ (","_Text_",") {
						set System=1
					} elseif ",YAKTION,YALIGN,YAM,YANZ,YART,YAUSWAHL,YBACK,YBACKGROUNDCOLOR,YBBN,YBBNMAX,YBED,YBEDBER,"	[ (","_Text_",") {
						set System=1
					} elseif ",YCOL,YCOLOFF,YCOLON,YCOUNTRY,YCR,YDARKGRAY,YDAT,YDATEI,YDDSATZ,YDECIMAL,YDECIMALLEN,"	[ (","_Text_",") {
						set System=1
					} elseif ",YENABLED,YFELD,YFIELDNAME,YFKEY,YFOCUS,YFOCUSID,YFONT,YFONTCOLOR,YFONTSIZE,YFORM,YFTYPE,"[ (","_Text_",") {
						set System=1
					} elseif ",YGIF,YGIF1,YGRAY,YGRIDGRAY,YGRIDWHITE,YHEIGHT,YHID,YHTMFORM,YIGNOREJUMP,YINHALT,"		[ (","_Text_",") {
						set System=1
					} elseif ",YKEY,YKILL,YKLFN,YKOMMA,YKOPF,YLENGTH,YLFDAT,YLFN,YLIGHTGREY,YLOCATION,"					[ (","_Text_",") {
						set System=1
					} elseif ",YMAXKEY,YMFELD,YNAME,YNOFOOT,YNUMMER,YOK,YOLDV,YOPTION,YOPTION1,"						[ (","_Text_",") {
						set System=1
					} elseif ",YPADDING,YPARA,YPARA1,YPOSLOCATION,YPRINTERLOCATION,YPRINTERNAME,YPROZ,YPWD,"			[ (","_Text_",") {
						set System=1
					} elseif ",YQ,YQUERY,YR,YRED,YREQUIRED,YRETVAL,YROW,YSCREENM,YSEITE,YSUCH,"							[ (","_Text_",") {
						set System=1
					} elseif ",YTABLEANZ,YTARGET,YTEXT,YTIMEFORM,YTOOLTIP,YTRAKT,YTXT,YTYP,YPFLICHT,"					[ (","_Text_",") {
						set System=1
					} elseif ",YUCI,YUMLAU,YURL,YUSER,YUSERAGENT,YVALIGN,YVOR,YVOR1,YWHITE,YWHR,YWIDTH,"				[ (","_Text_",") {
						set System=1
					} elseif ",YBLUE,YISO,YLINKCOL,"																	[ (","_Text_",") {
						set System=1
					} elseif ",YYAKTION,YYKEY,YWARNING,YREQUIRED,YMANDATORY,YRETURN,YPOPUP,YHYPER,YIPADDR,"				[ (","_Text_",") {
						set System=1
					} elseif $extract(Text)="%" {
						set System=1
					}
				}
				
				set Cmd=$get(@Glo@("tag","LastCmd"))
				
				if Cmd="n" {
					if ($get(@Glo@("tag","v",Text))="p")&&('System)&&('$find(Line,"(")) Do Error(" Parameter '"_Text_"' should not be newed","Param",pblnShowHTML,Glo)
					set @Glo@("tag","v",Text)="p"
					set @Glo@("tag","n",Text)=""
					
				} else {
					if $get(@Glo@("tag","v",Text))="" {
 						//if 'System {
	 					if 'pblnClass && 'System && '$get(@Glo@("tag","New All")) {		//SR15160 - don't new variables in cls code
							Do Error("What is '"_Text_"'","n",pblnShowHTML,Glo)
							set @Glo@("tag","Bad",Text)=""
						}
					}
					if "mrskf"'[Cmd {  ; Variable usage
						set Ok=0
						if $get(@Glo@("tag","s",Text)) && ($get(@Glo@("tag","s",Text))<$get(@Glo@("tag","Command Count")))		set Ok=1  ; we know about 
						if System 									set Ok=1 ; System is ok
						if $$Token(Line,Token-1)="." {
							set Ok=1,Cmd="s" ; Pass by Ref is ok, same as set
							set @Glo@("tag","s",Text)=$get(@Glo@("tag","Command Count"))
						}
						set Function=$zcvt($$Token(Line,Token-2),"l")
						
					//	if (Function="$get")||(Function="$data")	set Ok=1 if pblnStrictParameterCheck set @Glo@("tag","s",Text)="" ; $Get or $Data is ok ;"SHOBBY" TODO
					//	if (Function="$get")||(Function="$data")||(Function="$increment") set Ok=1 if pblnStrictParameterCheck set @Glo@("tag","s",Text)="" ; $Get or $Data is ok ;"SHOBBY" TODO  ; SR14832
						if (Function="$get")||(Function="$data") {
							set Ok=1
							if pblnStrictParameterCheck set @Glo@("tag","s",Text)=$get(@Glo@("tag","Command Count")) ; $Get or $Data is ok ;"SHOBBY" TODO  ; SR14832
							
						} elseif (Function="$increment") {		// SR15452
							set Ok=1
							set @Glo@("tag","s",Text)=$get(@Glo@("tag","Command Count"))		// $increment always defines variable
						}
						
						if Ok'=1 {
							do Error(" '"_Text_"' may not be defined","Warn",pblnShowHTML,Glo)
						}
						
					}
					if (Cmd="s")||(Cmd="f")||(Cmd="r")||(Cmd="m") {
						if '$data(@Glo@("tag","s",Text)) {
							set @Glo@("tag","s",Text)=$get(@Glo@("tag","Command Count"))
						}
					}
				}
				
		;	Text
		;-----------------------------------
			
			} elseif ((Class="COS_06") && (Text'="&qout;&qout;")) {
				set strString=Text
				while (strString["&quot;") {
					set strString=$piece(strString,"&quot;",1)_""""_$piece(strString,"&quot;",2,9999)
				}
				
				set @Glo@("Text",$increment(@Glo@("Text")))=strString
				
			}
			
		;	Comment
		;-----------------------------------
			
			// Check the first 3 lines for the system generated class message - SR15160
			if (Line<3) && (Class="COS_07") {	// It's a comment
				set Text	= $translate($zcvt(Text,"I","HTML"),$char(160)," ")
				if $find($$$LOWER(Text),"do not edit") {
					set pblnClass = $$$YES
				}
			}
			if (Class="COS_07") {	// It's a comment	
				set strVars	= ""
				if $extract(Text,1,7)	="; Sets " {
					set strVars	= $translate($extract(Text,8,9999),",;","  ")
				}
				if $extract(Text,1,10)	="; Assumes " {
					set strVars	= $translate($extract(Text,11,9999),",;","  ")
				}
				if $extract(Text,1,9)	="; Export " {
					set strVars	= $translate($extract(Text,10,9999),",;","  ")
				}
				if strVars'="" {
					for intVar=1:1:$length(strVars," ") {
						set strVar	= $piece(strVars," ",intVar)
						if strVar'="" {
							set @Glo@("tag","s",strVar)=$get(@Glo@("tag","Command Count"))
							set @Glo@("tag","v",strVar)="a"
							set @Glo@("tag","n",strVar)=""
						}
					}
				}
			}
			
			if New'="" {
				;write " ",New," ",Text
				set Vars=$get(Vars)+1
				set Vars(Vars,New)=Text
			}
			set @Glo@("tag","LastClass")=Class
			set @Glo@("tag","LastText")=Text
		}
		if intLastLineError'=@Glo@("LineErrors") {
			set strNewLine	= $piece(Line,"<SPAN",1,Token-1)
			set strTokenSpan = "<SPAN"_$piece(Line,"<SPAN",Token)
			set strNewLine	= strNewLine _ $piece(strTokenSpan,">",1)_">"
			set strNewLine	= strNewLine _ "<b><u><font size=4>"
			set strNewLine	= strNewLine _ $piece($piece(strTokenSpan,">",2),"<",1)
			set strNewLine	= strNewLine _ "<font size=3></u></b>"
			set strNewLine	= strNewLine _ "<"_$piece(strTokenSpan,"<",3)
			set strTempText	= $piece(Line,"<SPAN",Token+1,9999)
			set:strTempText'="" strNewLine	= strNewLine _ "<SPAN"_strTempText
			set Line		= strNewLine
			
				;set Seg   = $piece(Line,"<SPAN",TokenNumber)
				;set Class = $piece(Seg,"""",2)
				;set Text  = $piece($piece(Seg,">",2),"<",1)

			set intLastLineError=@Glo@("LineErrors")
		}
	}
	if pblnShowHTML {
		write "["_Number_"]"_Line
		set intErrorLine=""
		for {
			set intErrorLine	= $order(@Glo@("LineErrors",intErrorLine))
			quit:intErrorLine=""
			write $get(@Glo@("LineErrors",intErrorLine))
		}
		if pblnShowHTML write !
	}
	quit
	
Error(Text,Type="",pblnShowHTML=1,Glo,strTag="") ; Internal Tag 
	;-------------------------------------------------------------------------------
	; 08-Jul-2003	SCR			Added Previous / Next
	;-------------------------------------------------------------------------------
	new ECount
	if Type="" set Type="??"
	if Type="New" {
		set ECount=$get(@Glo@("NewError"))+1
		set @Glo@("NewError")=ECount
		set @Glo@("NewError",ECount)=strTag
		;write:'pblnShowHTML !,Text
		if pblnShowHTML {
			do ErrorText("<br><b>"_Text_"</b><A NAME=""NewError"_ECount_"""></A>",Glo,pblnShowHTML,1)
			if ECount>1 do ErrorText(" <A HREF=""#NewError"_(ECount-1)_""">Previous tag with missing newed Variables</A> ",Glo,pblnShowHTML,1)
			do ErrorText("<A HREF=""#NewError"_(ECount+1)_""">Next tag with missing newed Variables</A><br><br>",Glo,pblnShowHTML,1)
		} 
	} else {
		set ECount=$get(@Glo@("Error"))+1
		set @Glo@("Error")=ECount
		set @Glo@("Error",Type)=$get(@Glo@("Error",Type))+1
		;write:'pblnShowHTML !,Text
		if pblnShowHTML {
			do ErrorText("<br><b>"_Text_"</b><A NAME=""Error"_ECount_"""></A>",Glo,pblnShowHTML)
			if ECount>1 do ErrorText(" <A HREF=""#Error"_(ECount-1)_""">Previous</A> ",Glo,pblnShowHTML)
			do ErrorText(" <A HREF=""#Error"_(ECount+1)_""">Next</A> ",Glo,pblnShowHTML)
		} 
	
	}
	quit
	
ErrorText(Text,Glo,pblnShowHTML=1,pblnWriteNow=0) ; Internal Tag
	;-------------------------------------------------------------------------------
	; 27-Oct-2013	SCR			Save Error Text
	;-------------------------------------------------------------------------------
	new intError
	
	if pblnWriteNow&pblnShowHTML {
		write Text
	} else {
	 	set intError			= $order(@Glo@("LineErrors",""),-1)+1
		set @Glo@("LineErrors")	= intError
		set @Glo@("LineErrors",intError)	= Text
	}
	quit
	
TagEnd(Glo,pstrTag="",pblnShowHTML=1)
	;-------------------------------------------------------------------------------
	; 26-Oct-2013	SCR			Created
	;-------------------------------------------------------------------------------
	new blnGot,intCount,intLineMax,intSize,strNotUsed,strOut,strUsedOut,strVar
	
	set intLineMax	= 70
	set strOut		= ""
	set:pstrTag="" pstrTag = $get(@Glo@("Current","Tag"))
	; Keep for next time arround
	if pstrTag'="",$data(@Glo@("tag","Bad")) {
		set strOut	= $char(9)_"These Variables Should 'Newed'<br>"_$char(9)
		set strVar	= ""
		for intCount=1:1 {
			set strVar	= $order(@Glo@("tag","Bad",strVar))
			quit:strVar=""
			set:intCount>1 strOut=strOut_","
			set strOut	= strOut_strVar
			set @Glo@("tag","n",strVar)=""
			
		}
		set strOut	= strOut_"<BR><br>"
	}
	if pstrTag'="",strOut'="" {
		set strOut	= strOut_$char(9)_"Sorted New list for Tag "_pstrTag_"<br><br>"_$char(9)_"new "
		set intSize	= 0
		set strVar	= ""
		for intCount=1:1 {
			set strVar	= $order(@Glo@("tag","n",strVar))
			quit:strVar=""
			if $get(@Glo@("tag","v",strVar))="a" {
				set intCount	= intCount - 1
				continue
			}
			if intSize>intLineMax {
				set intSize	= 0
				set strOut	= strOut_"<br>"_$char(9)_"new "
				set intCount=1
			}
			set:intCount>1 strOut=strOut_","
			set strOut	= strOut_strVar
			set intSize	= intSize+$length(strVar)+1
		}
		set strOut	= strOut_"<BR><br>"
	}
		
	
	set strNotUsed	= ""
	set strUsedOut	= ""
	
	set intSize	= 0
	set strVar	= ""
	set blnGot	= 0
	set intCount=0
	for {
		set strVar	= $order(@Glo@("tag","n",strVar))
		quit:strVar=""
		if '$data(@Glo@("tag","s",strVar))&&(",SQLCODE,"'[(","_strVar_",")) {
			set:strNotUsed'="" strNotUsed=strNotUsed_","
			set strNotUsed	= strNotUsed_strVar
		} else {
			set intCount	= intCou]]><![CDATA[nt+1
			if intSize>intLineMax {
				set intSize		= 0
				set strUsedOut	= strUsedOut_"<br>"_$char(9)_"new "
				set intCount	= 1
			}
			set:intCount>1 strUsedOut=strUsedOut_","
			set strUsedOut	= strUsedOut_strVar
			set intSize		= intSize+$length(strVar)+1
			set blnGot		= 1
		}
	}
	set strUsedOut	= strUsedOut_"<br><br>"
	
	if strNotUsed'="" {
		set strOut	= strOut_$char(9)_"These Variables are 'Newed' but are not used<br>"_$char(9)
		set strOut	= strOut_strNotUsed_"<br>"
		set strOut	= strOut_$char(9)_"Sorted New list with used Vars for Tag "_pstrTag_"<br><br>"
		if blnGot {
			set strOut	= strOut_$char(9)_"new "
			set strOut	= strOut_strUsedOut_"<br><br>"
		}
	}

	if strOut'="" {
		do Error(strOut,"New",pblnShowHTML,Glo,pstrTag)
	}
	quit
	

	
CheckModule(Module="",pblnStrictParameterCheck=0,pblnUseMac=0)
    ;-------------------------------------------------------------------------------
    ; Check a Module 
    ;
    ; History:
    ; 12-Sep-2014	SCR		CORE-312: Check for unused Code
    ; 11-May-2007	RPW		SRadhoc: Ignore Gnnn and Snnn files these are
    ; 						pure intraprend code.
    ; 01-Nov-2006	JW		SR15160: No longer ignore classes
    ; 27-Apr-2006	JW		Ignore class created routines (end in number)
    ; 02-Sep-2005	RPW		Always use MAC routines and not INTs
    ; 19-Jul-2005	RPW		SR12981: Make the summary show the actual length of the code
    ; 14-Jul-2005	PO		SR12971: Produce a summary at the end of the code check.
    ; 09-Feb-2004	shobby	pblnStrictParameterCheck
    ; 02-Jun-2004	SCR		Changed Routine Size Calc
    ; 01-Jun-2004	Paul K	Added Number of lines of code,code size and comment ratio.
    ; 10-May-2004   Paul K	Added Param to Show so HTML isn't shown from terminal
    ;-------------------------------------------------------------------------------
	new RtnName,arrFlaggedRoutines,blnUseINT,intLength,intMaxRoutines,intNumberOfErrors
	new intRoutines,intSize,objRoutine,strChar,strFind,strNotes,strType
 
	if Module="" Set Module="???"
	kill ^mtemp("cc",$job)
	;set blnUseINT=((Module="IN")||(Module="WWW"))&&('pblnUseMac)
	set blnUseINT=$$$YES
	
	if blnUseINT {
		set RtnName=Module
		set RtnName=$order(^ROUTINE(RtnName),-1)  ; Start back one
		set intMaxRoutines=0
		set intRoutines=0
		
		kill ^mtemp("cc",$job)
		for {
			set RtnName=$order(^ROUTINE(RtnName))
			quit:$extract(RtnName,1,$length(Module))'=Module
			continue:RtnName["."
			/* SR15160
			set strLast = $piece(RtnName,".",$length(RtnName,"."))	// JW skip cls
			continue:(strLast=+strLast)
			set $extract(strLast)=""
			continue:(strLast=+strLast)
			*/			
			
			set strType=$piece(RtnName,".",$length(RtnName,"."))
			
			set strChar=$extract(strType)
			
			if (strChar="T")||(strChar="G") {
				
				set strType="int"
				if strChar="T" {
					set strType="mac"
					set strFind="#classcontext"
				} elseif strChar="G" {
					set strFind="(C)InterSystems, method generator"
				}
				set objRoutine=##class(%Library.Routine).%New(RtnName_"."_strType)
				continue:objRoutine.FindAt(-1,strFind)'=-1
			}
			
			set ^mtemp("cc",$job,RtnName)=""
			set intMaxRoutines=intMaxRoutines+$get(^ROUTINE(RtnName,0,0))
		}		
	} /*else {
		set RtnName=Module
		set RtnName=$order(^rMAC(RtnName),-1)  ; Start back one
		set intMaxRoutines=0
		set intRoutines=0
		
		kill ^mtemp("cc",$job)
		for {
			set RtnName=$order(^rMAC(RtnName))
			quit:$extract(RtnName,1,$length(Module))'=Module
			set ^mtemp("cc",$job,RtnName)=""
			set intMaxRoutines=intMaxRoutines+^rMAC(RtnName,0,0)
			
		}
	}
	*/
	write !,Module_" Code Error Check",!
	write !,$justify("Routine",30)_$justify("Errors",10)_$justify("Size",10)_$justify("Lines",10)_$justify("C/R",10)_$justify("Notes",20)_$justify("Amt complete",14)
	write !,$translate($justify("",104)," ","-")
	set RtnName=""
	for {
		set RtnName=$order(^mtemp("cc",$job,RtnName))
		quit:RtnName=""
		if blnUseINT {
			set intSize=$get(^ROUTINE(RtnName,0,0))
			set intLength=$get(^ROUTINE(RtnName,0,"SIZE"))
		} else {
			set intSize=$get(^rMAC(RtnName,0,0))
			set intLength=$get(^rMAC(RtnName,0,"SIZE"))
		}
		set intRoutines=intRoutines+intSize
		set strNotes=""
		;if intLength>31000 set strNotes=" Too Large >31000"
		write !
		write $justify(RtnName,30)
		if blnUseINT {
			set intNumberOfErrors = $$Show(RtnName_".INT",0,pblnStrictParameterCheck)
			write $justify(intNumberOfErrors,10)
		} else {
			set intNumberOfErrors = $$Show(RtnName_".MAC",0,pblnStrictParameterCheck)
			write $justify(intNumberOfErrors,10)
		}
		write $justify(intLength,10)
		write $justify(intSize,10)
		write $justify($$CommentRatio(RtnName)_"%",10)
		write $justify(strNotes,20)
		write $justify((intRoutines*100\intMaxRoutines)_"% complete",14)
		if strNotes'="" set arrFlaggedRoutines(1,RtnName) = strNotes_" = "_intLength
		if intNumberOfErrors set arrFlaggedRoutines(2,RtnName) = intNumberOfErrors
	}
	write !,$translate($justify("",104)," ","-")
	write !,"Summary:"
	write !,"Number of errors for Routines..."
	set RtnName=""
	if $data(arrFlaggedRoutines(2)) {
		for {
			set RtnName = $order(arrFlaggedRoutines(2,RtnName))
			quit:RtnName=""
			write !,$justify(RtnName,30),$justify(arrFlaggedRoutines(2,RtnName),10)
		}
	} else {
		write !,$c(9),"NO ROUTINES WITH ERRORS."
	}
	write !,"Notes for Routines..."
	set RtnName=""
	if $data(arrFlaggedRoutines(1)) {
		for {
			set RtnName = $order(arrFlaggedRoutines(1,RtnName))
			quit:RtnName=""
			write !,$justify(RtnName,30),$justify(arrFlaggedRoutines(1,RtnName),10)
		}
	} else {
		write !,$c(9),"NO ROUTINES WITH NOTES."
	}
	write !,$translate($justify("",104)," ","-")
	kill ^mtemp("cc",$job)
	
	quit
 
 
CommentRatio(pstrRoutine)
    ;-------------------------------------------------------------------------------
    ; Determine the comment ratio for each routine.
    ;
    ; Returns:Float
    ;
    ; History:
    ; 07-Nov-2006	Steve S			Call $zstrip directly
    ; 01-Jun-2004   Paul Kalenjuk   Created
    ;-------------------------------------------------------------------------------
	new idLine,strCode,blnComment,fltRatio,intComment,intCode
	
	set fltRatio=0
	set intComment=0
	set intCode=0
	set idLine=""
	for {
		set idLine=$order(^rMAC(pstrRoutine,0,idLine))
		quit:idLine=""
		
		set strCode=$get(^rMAC(pstrRoutine,0,idLine))
		set strCode=$zstrip(strCode,"<W")
		set blnComment=($extract(strCode,1)=";")||($extract(strCode,1,2)="//")
		if blnComment set intComment=intComment+1
		set intCode=intCode+1
	}
	if intCode>0 {
		set fltRatio=$tr($justify(intComment/intCode*100,0,2)," ","0")
	}
	quit fltRatio
	
SuspectRoutines(pstrModule="") 
    ;-------------------------------------------------------------------------------
    ; Determine which routines may or are too long in a quick fashion.
    ; 
    ; Also attempts to find the window routines. These are ones where the CheckModule
    ; label will show the routine is okay in length, but Show says it is too long.
    ;
    ; Params:
    ; pstrModule : The module to check, or all modules.
    ;
    ; Returns:
    ;
    ; History:
    ; 15-Jul-2005	RobertW		SR12891: Created
    ;-------------------------------------------------------------------------------
	new strModule,intSize,strLine
 
	set strModule=$order(^rMAC(pstrModule),-1)
		
	for {
		set strModule=$order(^rMAC(strModule))
		quit:strModule=""
		quit:$extract(strModule,1,$length(pstrModule))'=pstrModule
		
		set intSize=$get(^rMAC(strModule,0,"SIZE"))
		set strLine=""
		if intSize>30000 {
			set strLine=strModule_" "_intSize
		}
		
		if intSize>31000 {
			set strLine="*"_strLine
		}
		write:strLine'="" !,strLine
		
	}
	
	quit
	
RemoteIn(pobjIn,pobjSynColor,pblnShowHTML,pstrGLO,pblnStrictParameterCheck,pstrName )
    ;-------------------------------------------------------------------------------
    ; This method breaks a routine into about 32000 character blocks and passes these
    ; through to the colouring routines.
    ;
    ; Params:
    ; pobjIn					The routine stream to check
    ; pobjSynColor              The syntax colouring stream
    ; pblnShowHTML              Are we showing the HTML or not
    ; pstrGLO                   The stream of globals
    ; pblnStrictParameterCheck  Are we checking the parameters thoroughly
    ; pstrName                  The name of the routine
    ;
    ; Returns:
    ;
    ; History:
    ; 11-Jun-2009	shobby		SR16636: Chang e Write to WriteLine.  Otherwise in Cache2008 the output all
    ; 								appears on one line.
    ; 01-Nov-2006	JW			SR15160: Added blnClass check
    ; 19-Jul-2005	RobertW		SR12981: Created
    ;-------------------------------------------------------------------------------
	new Vars,blnClass,intLen,intLine,intMaxLines,intPort,objFile,strCodeFile,strIO
	new strLine,strOutFile,strServer,strSyntax,strText

	
	set strCodeFile	= $get(^SysSetup("CodeCheckRemote","CodeFile"))
	Set objFile		= ##class(%File).%New(strCodeFile)
	Do objFile.Open("WSN")
	Do objFile.Write($$Routine^COMCodeCheck(pstrName ))
	do objFile.Close()
	set intPort		= $get(^SysSetup("CodeCheckRemote", "Port"))
	set strServer	= $get(^SysSetup("CodeCheckRemote","Server"))
	set strIO="|TCP|2" 
	close strIO
	;set $ztrap="Error"
	open strIO:(strServer:intPort:"M"):200 ;Connect to server
	if ('$TEST) { 
       write !,"cannot open remote connection" Quit }
	else { 
       use strIO read strText#6:200 ;Reads from subjob 
       use 0
    }

	set strOutFile	= $get(^SysSetup("CodeCheckRemote","SyntaxFile"))
	set intLen		= 9999999999
	set objFile		= ##class(%File).%New(strOutFile)
	do objFile.Open("RU") 
	set strSyntax	= objFile.Read(.intLen)
	set intMaxLines	= $length(strSyntax,"<BR>"_$c(13,10))
	write:pblnShowHTML "<PRE>"
 	for intLine = 1:1:intMaxLines {
		set strLine		= $piece(strSyntax,"<BR>"_$c(13,10),intLine) 

		do Decode(intLine,strLine,pstrGLO,.Vars,pblnShowHTML,pblnStrictParameterCheck,pstrName,.blnClass)
	}
	do TagEnd(pstrGLO,,pblnShowHTML)

	kill ^CacheTempMultipleIn($job)
	write:pblnShowHTML "</PRE>"
	
	quit

	
MultipleIn(pobjIn,pobjSynColor,pblnShowHTML,pstrGLO,pblnStrictParameterCheck,pstrName)
    ;-------------------------------------------------------------------------------
    ; This method breaks a routine into about 32000 character blocks and passes these
    ; through to the colouring routines.
    ;
    ; Params:
    ; pobjIn					The routine stream to check
    ; pobjSynColor              The syntax colouring stream
    ; pblnShowHTML              Are we showing the HTML or not
    ; pstrGLO                   The stream of globals
    ; pblnStrictParameterCheck  Are we checking the parameters thoroughly
    ; pstrName                  The name of the routine
    ;
    ; Returns:
    ;
    ; History:
    ; 11-Jun-2009	shobby		SR16636: Change Write to WriteLine.  Otherwise in Cache2008 the output all
    ; 								appears on one line.
    ; 01-Nov-2006	JW			SR15160: Added blnClass check
    ; 19-Jul-2005	RobertW		SR12981: Created
    ;-------------------------------------------------------------------------------
	new In,Out,intLength,intCount,intLast,intBlock,strLine,intBlockCount,LineNumber,Vars
	new blnClass
	
	Set In  = ##class(%GlobalCharacterStream).%New()
	Set Out = ##class(%GlobalCharacterStream).%New()
	
	set intLength = 0
	set intCount  = 0
	kill ^CacheTempMultipleIn($job)
	
	for {
		set intLength=32000
		set strLine=pobjIn.ReadLine(.intLength)
		quit:intLength=-1
		
		set ^CacheTempMultipleIn($job,$increment(intCount))=strLine
	}
	set intLast=intCount
	set intCount=""
	set intBlock=0
 
	write:pblnShowHTML "<PRE>"
	for {
		set intCount=$order(^CacheTempMultipleIn($job,intCount))
		quit:intCount=""
		
		set strLine=$get(^CacheTempMultipleIn($job,intCount))
		if $get(^SysSetup("CodeCheck")) set ^zzCodeCheck(intCount) = $tr(strLine,$c(9,10,13)," ")
		
		if ((In.Size+$length(strLine))<32000) && (intCount<intLast) {
			do In.WriteLine(strLine) ;16636
			
		} else {
			; Here is the output
			if intCount=intLast {
				do In.WriteLine(strLine)
			} else {
				set intCount=$increment(intCount,-1)
			}
			do pobjSynColor.Color(In,Out,"COS","S")
 			
 			set intBlockCount=0
			for LineNumber=intBlock:1 {	
				set intLength=32000 set strLine=Out.ReadLine(.intLength)
				quit:intLength=-1
				
			//	do Decode(LineNumber,strLine,pstrGLO,.Vars,pblnShowHTML,pblnStrictParameterCheck,pstrName)	//SR15160
				do Decode(LineNumber,strLine,pstrGLO,.Vars,pblnShowHTML,pblnStrictParameterCheck,pstrName,.blnClass)
				set intBlockCount=intBlockCount+1
			}
			do TagEnd(pstrGLO,,pblnShowHTML)

			set intBlock=intBlock+intBlockCount
			do In.Clear()
			do Out.Clear()
		}
	}
	
	kill ^CacheTempMultipleIn($job)
	write:pblnShowHTML "</PRE>"
	
	quit
 
CheckAll(pblnAll=$$$NO)
    ;-------------------------------------------------------------------------------
    ; Check all the existing modules.
    ;
    ; Params:
    ;
    ; Returns:
    ;
    ; History:
    ; 12-Sep-2014	SCR		CORE-312: Check for unused Code
    ; 30-Jul-2009	shobby	SRAdhoc: MED
    ; 20-Jul-2005	PO		Added parentheses to tag CheckAll
    ; 20-Jul-2005	RobertW	SR12981: Created
    ;-------------------------------------------------------------------------------
	do CheckModule("COM")
	do CheckModule("FIN")
	do CheckModule("SAL")
	do CheckModule("STK")
	do CheckModule("CST")
	do CheckModule("REP")
	do CheckModule("MED")
	do CheckModule("VAR")
	
	if pblnAll {
		do CheckModule("IN")
		do CheckModule("WWW")
	}
	
	quit


]]></Routine>
</Export>