<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="CACHE" ts="2001-01-01 00:00:00">
<Routine name="INERECH1" type="MAC" languagemode="0" timestamp="58440,0"><![CDATA[
INERECH1
#include COMSYS
#include INConst
#include FINConst
	
#define LogR(%1,%2) 	;
#define LogRx(%1)		;
#;define LogR(%1,%2) 	$$$JournalOff s ^zzLogR($g(YBED,"UNK"),$i(^zzLogR))=%1_"^INERECH1("_%2_") : "_$zh $$$JournalOn
#;define LogRx(%1)		$$$JournalOff s ^zzLogR($g(YBED,"UNK"),$i(^zzLogR))=%1 $$$JournalOn
	
	;-------------------------------------------------------------------------------
	; Description of Function :
	;		VORGABE DER RECHNUNGSWERTE
	;		DEFAULT OF THE INVOICE AMOUNTS
	; 
	; Called by :
	; 	Form     : INERECH1 "Edit Line Item Invoice" - After Button
	; 				  (called from INAUFP "Edit Supplier Invoice" button)
	;   Routines : INERECH1D13
	;              FINAPInvPostCost
	;              INSERV191
	;              INERECH1P1
	;   
	; Inputs : 
	;	YFORM		Form Name					INAUFPK,INERECH1
	;	YKEY		Order No "," Order Line
	;	YDATEI		Class Name					INERECH1
	;	
	; ByRef : 
	; 	YFELD		Order record
	; 	YVOR		?objWWW120?
	;
	; Returns : Nothing
	;
	; History :
	; 03-Nov-2009	GRF		SR16871: remove old commented code blocks
	; 24-Jun-2009	GRF		Key macros
	; 04-Sep-2006	GRF		SR12027: Naked Reference
	; 27-Jan-2006	GRF		SR14203: Doco
	; 06-Sep-2005	GRF		Doco
	; 10-Oct-2000	DT		Created
	;-------------------------------------------------------------------------------
	NEW AUF,POS,KOND,YI,RECHNUNG
	
	SET AUF = $$$KEY1(YKEY)            QUIT:AUF=""
	SET POS = $$$KEY2(YKEY)            QUIT:POS=""
	
	;IF $$$KEY3(YKEY)="" DO  ;LIEFERANT
	;. SET $$$KEY3(YKEY)  = $PIECE($GET(^INAUFP(YM,AUF,POS,1)),Y,12)
	;. SET $$$KEY3(YFKEY) = $PIECE($GET(^INAUFP(YM,AUF,POS,1)),Y,12)
	
	QUIT:$TRANSLATE(YFELD,Y)'=""  ;SCHON DATEN ERFASST ;already has data         ; FIXME : #1 see note below <GRF>
	
	/*++++++++++++++++++++++++++++++++++++++
	;	KOND		objINAUFPK		Item Supplier Terms
	;	KOND		objINAUFPA		Order Confirmation Supplier Terms
	;	RECHNUNG	objINERECH		Supplier Invoices
	;+++++++++++++++++++++++++++++++++++++++*/
	
	SET KOND=$GET(^INAUFPK(YM,AUF,POS,1))
	
	/*++++++++++++++++++++++++++++++++++++++
	;	D16		$$$INAUFPKPurchaseQuantity()
	;	D41		$$$INAUFPKConversionFactorQuantity()
	;	
	;	D5		$$$INAUFPQuantity()
	;+++++++++++++++++++++++++++++++++++++++*/
	IF YFORM="INAUFPK" IF $PIECE(YFELD,Y,16)="" DO
	. SET $PIECE(KOND,Y,16) = $PIECE($GET(^INAUFP(YM,AUF,POS,1)),Y,5)  ;MENGE  ;quantity 
	. IF +$PIECE(KOND,Y,41)'=0 SET $PIECE(KOND,Y,16)=$PIECE(KOND,Y,16)*$PIECE(YFELD,Y,41)  ; FIXME : #2 see note below <GRF>
	
	; FIXME NOTE : This can ONLY be multiplying by zero since routine quits at FIXME #1 if YFELD
	;              has ANY value.  The whole point of this is unclear anyway and should be clarified.
	;              The duplicated line below was only adding to the confusion. <GRF>
	
	; 04-Sep-2006 vvv use objINAUFPK
	set objINAUFPK = $GET(^INAUFPK(YM,AUF,POS,1))
	IF $PIECE(YFELD,Y,16)="" DO
	. IF YFORM'="INAUFPK" IF +$PIECE(objINAUFPK,Y,41)'=0 SET $PIECE(KOND,Y,16) = $PIECE(objINAUFPK,Y,16) QUIT
	. IF YFORM="INERECH1" IF $PIECE(objINAUFPK,Y,18)'="" IF $PIECE(objINAUFPK,Y,18)'=$PIECE($GET(^INAUFP(YM,AUF,POS,1)),Y,40) IF +$PIECE(objINAUFPK,Y,16)'=0 SET $PIECE(KOND,Y,16) = $PIECE(objINAUFPK,Y,16) QUIT  ;FIS;23.07.04;26142
	. SET $PIECE(KOND,Y,16) = $PIECE($GET(^INAUFP(YM,AUF,POS,1)),Y,5)  ;MENGE ;quantity 
	; 04-Sep-2006 ^^^
	
	IF $PIECE(KOND,Y,16)="" SET $PIECE(KOND,Y,16) = $PIECE($GET(^INAUFP(YM,AUF,POS,1)),Y,5)  ;MENGE ;quantity 
	
	IF $GET(YDATEI)="INERECH1" DO  ;SUCHEN AUFTRAGSBESTÄTIGUNG ;seek order confirmation 
	. NEW LIEFAB,ABNUM
	. SET LIEFAB = $ORDER(^INAUFPA(YM,AUF,POS,""),-1)           QUIT:LIEFAB=""       ;LETZTER LIEFERANT ;last supplier 
	. SET ABNUM  = $ORDER(^INAUFPA(YM,AUF,POS,LIEFAB,""),-1)    QUIT:ABNUM=""        ;LETZTE AB ;last order confirmation
	. SET KOND   = $GET(^INAUFPA(YM,AUF,POS,LIEFAB,ABNUM,1))                         ;AUS AB    ;from order confirmation 
	
	SET ME=$PIECE(KOND,Y,18)  ;EINHEIT ;unit 
	IF ME'="" SET $PIECE(YFELD,Y,18)=$PIECE($GET(^WWW101(0,"EINHEIT",SPRACHE,ME,1)),Y,1)
	;FOR YI=2,3,4,5,6,7,9,10,12,13,15,16,21,47,25 {
	FOR YI=2,3,4,5,6,7,9,10,12,13,15,16,21,47,25,68,78,79 {
		;KOPIEREN DATEN AUS POSITION
		SET $PIECE(YFELD,Y,YI)=$PIECE(KOND,Y,YI) 
		SET $PIECE(^WWWDATEN(YM,+$HOROLOG,YUSER,YFORM,"D",1),Y,YI)=$PIECE(KOND,Y,YI)  ;FIS;FREMDWÄHRUNGSBETRAG;27.04.08;26316
	}
	
	IF $GET(%(YQUERY,"YYKNUM"))'="" SET $PIECE(YFELD,Y,25) = $GET(%(YQUERY,"YYKNUM"))  ;KREDITORENRECHNUNGSNUMMER
	IF $GET(%(YQUERY,"YYRDAT"))'="" SET $PIECE(YFELD,Y,1)  = $GET(%(YQUERY,"YYRDAT"))  ;RECHNUNGSDATUM ;date of invoice 
	SET YI=22 SET $PIECE(YFELD,Y,YI) = $$^INNETTO(YFELD,1)   ;KOPIEREN DATEN AUS POSITION ;out of 
	
	;INFO AUS ANDEREN RECNUNGEN ;out of 
	IF YFORM="INERECH1" IF $PIECE(YFELD,Y,1)'="" IF $$$KEY3(YKEY)'="" IF $$$KEY4(YKEY)'="" DO
	. SET RECHNUNG=$GET(^INERECH(YM,$$$KEY3(YKEY),$$$KEY4(YKEY),$PIECE(YFELD,Y,1),1))
	. ;SET $PIECE(YFELD,Y,1)=$PIECE(YKEY,",",5)     ;RECHNUNGSNUMMER
	. SET $PIECE(YFELD,Y,21)=$PIECE(RECHNUNG,Y,6)   ;STEUERN ;tax 
	. ;SET $PIECE(YFELD,Y,7)=$PIECE(RECHNUNG,Y,12)  ;SKONTO
	. if $PIECE(RECHNUNG,Y,12)'="" set $PIECE(YFELD,Y,7)  = $piece($get(^INKOND(YM,$PIECE(RECHNUNG,Y,12),1)),Y,3)      ;BEC;26662;17.11.04
	. if $PIECE(RECHNUNG,Y,12)'="" set $PIECE(YFELD,Y,9)  = $piece($get(^INKOND(YM,$PIECE(RECHNUNG,Y,12),1)),Y,2)      ;BEC;26662;17.11.04
	. if $PIECE(RECHNUNG,Y,12)'="" set $PIECE(YFELD,Y,10) = $piece($get(^INKOND(YM,$PIECE(RECHNUNG,Y,12),1)),Y,4)      ;BEC;26662;17.11.04
	. ;
	. ;FREMDWÄHRUNG AUS RECHNUNG ÜBERNEHMEN;FIS;27.08.04;26316
	. IF $PIECE(RECHNUNG,Y,131)'="" IF $PIECE(RECHNUNG,Y,131)'=YWHR IF +$PIECE(RECHNUNG,Y,129)'=0 DO
	. . ;;;SET $PIECE(YFELD,Y,68)=$PIECE(RECHNUNG,Y,129)  ;BETRAG AUS HAUPTRECHNUNG
	. . IF +$PIECE(RECHNUNG,Y,130)'=0 DO
	. . . SET $PIECE(YFELD,Y,78) = $PIECE(RECHNUNG,Y,130)
	. . . SET $PIECE(YFELD,Y,79) = $PIECE(YFELD,Y,1)
	. . ;
	. . IF +$PIECE(RECHNUNG,Y,130)=0 DO
	. . . SET $PIECE(YFELD,Y,78) = $PIECE($GET(^WWWWAE(0,$PIECE(RECHNUNG,Y,131),1)),Y,5)
	. . . SET $PIECE(YFELD,Y,79) = +$HOROLOG
	. . ;
	. . SET $PIECE(YFELD,Y,47) = $JUSTIFY($PIECE(YFELD,Y,68)*$PIECE(YFELD,Y,78),0,2)  ;NKOMMA
	. . SET $PIECE(YFELD,Y,12) = $JUSTIFY($PIECE(YFELD,Y,47)*$PIECE(YFELD,Y,16),0,2)  ;MENGE * PREIS ;quantity * price 
	. . SET $PIECE(YFELD,Y,13) = $$^INNETTO(YFELD)
	. . SET $PIECE(YFELD,Y,22) = $$^INNETTO(YFELD,1)  ;OHNE MWST ;without Tax 
	
	QUIT
	
	
WARENEIN                                       ; FIXME : INWE/INWEAUF now DEPRECATED
	;-------------------------------------------------------------------------------
	;	ZUORDNEN WARENEINGÄNGE -> ACHTUNG EINSPRUNG !!
	;	ASSIGN INCOMING GOODS - TO ATTENTION RE-ENTRY POINT!!
	;	
	;	Updates ^INERECH11		Incoming Goods VS Incoming Invoices
	;	
	; Called By:
	;   INERECH1P1
	;   INSERV191	
	;	NOTE : Only internal call to this routine is in disabled block above.
	;	
	; History:
	; 24-Jun-2009	GRF		Key macros
	; 10-Jan-2007	GRF		SR15357: Set YTAB once; simplify strQty
	;-------------------------------------------------------------------------------
	NEW AUF,BET,LAP,LIEF,POS,QtyAdditional,QtyIncoming,RECH,strQty,WE1,WED,WEMERKER,YTAB
	
	;+++++++++++++++++++++++++++++++++++++++
	;	WE1			objINWEAUF		Incoming Goods
	;	WE1			objINWEAUFALT	Incoming Goods
	;+++++++++++++++++++++++++++++++++++++++
	
	SET YKEY = $GET(YKEY)
	SET AUF  = $$$KEY1(YKEY)           QUIT:AUF=""
	SET POS  = $$$KEY2(YKEY)           QUIT:POS=""
	SET LIEF = $$$KEY3(YKEY)           QUIT:LIEF=""
	SET RECH = $$$KEY4(YKEY)           QUIT:RECH=""
	
	set YTAB = $justify("",91)     ; build a string of 91 spaces (Why do we need to pad anyway?)
	
	IF $DATA(^INWEAUF(YM,AUF,POS)) DO
	. IF '$DATA(^INERECH1(YM,AUF,POS,LIEF,RECH)) KILL ^INERECH11(YM,AUF,POS,LIEF,RECH)
	. ;QUIT:$DATA(^INERECH11(YM,AUF,POS,LIEF,RECH))  //BEREITS GESETZT
	. ;
	. SET BET=""
	. FOR  SET BET=$ORDER(^INWEAUF(YM,AUF,POS,BET)) QUIT:BET=""  DO
	. . SET LAP=""
	. . FOR  SET LAP=$ORDER(^INWEAUF(YM,AUF,POS,BET,LAP)) QUIT:LAP=""  DO
	. . . SET WED=""
	. . . FOR  SET WED=$ORDER(^INWEAUF(YM,AUF,POS,BET,LAP,WED)) QUIT:WED=""  DO
	. . . . SET WE1=$GET(^INWEAUF(YM,AUF,POS,BET,LAP,WED,1))
	. . . . set QtyIncoming   = $$$INWEAUFIncomingGoodsQuantity(WE1)
	. . . . set QtyAdditional = $$$INWEAUFAdditionalQuantity(WE1)
	. . . . set strQty = $$^WWWZAHL(QtyIncoming+QtyAdditional,0,$LENGTH($PIECE(QtyIncoming,".",2)))
	. . . . SET WEKEY=BET_LAP_WED
	. . . . SET WEMERKER=$PIECE(WE1,Y,10)
	. . . . IF WEMERKER'="" SET WEMERKER=$PIECE($GET(^INWEMERKER(YM,WEMERKER,1)),Y,1)
	. . . .;SET ^INERECH11(YM,AUF,POS,LIEF,RECH,WEKEY,1)=$EXTRACT($$^WWWZAHL(($PIECE(WE1,Y,4)+$PIECE(WE1,Y,54)),0,$LENGTH($PIECE($PIECE(WE1,Y,4),".",2)))_" x "_$$^WWWDATE(WED)_" ("_BET_"/ "_LAP_") - "_WEMERKER_YTAB,1,91)_Y
	. . . . SET ^INERECH11(YM,AUF,POS,LIEF,RECH,WEKEY,1)=$EXTRACT(strQty_" x "_$$^WWWDATE(WED)_" ("_BET_"/ "_LAP_") - "_WEMERKER_YTAB,1,91)_Y    ; SR15357
	. . . . IF $DATA(^INERECH11(YM,AUF,POS,LIEF,RECH,0)) KILL ^INERECH11(YM,AUF,POS,LIEF,RECH,0)
	
	IF $DATA(^INWEAUFALT(YM,AUF,POS)) DO
	. IF '$DATA(^INERECH1(YM,AUF,POS,LIEF,RECH)) KILL ^INERECH11(YM,AUF,POS,LIEF,RECH)
	. ;QUIT:$DATA(^INERECH11(YM,AUF,POS,LIEF,RECH))  //BEREITS GESETZT
	. ;
	. SET BET=""
	. FOR  SET BET=$ORDER(^INWEAUFALT(YM,AUF,POS,BET)) QUIT:BET=""  DO
	. . SET LAP=""
	. . FOR  SET LAP=$ORDER(^INWEAUFALT(YM,AUF,POS,BET,LAP)) QUIT:LAP=""  DO
	. . . SET WED=""
	. . . FOR  SET WED=$ORDER(^INWEAUFALT(YM,AUF,POS,BET,LAP,WED)) QUIT:WED=""  DO
	. . . . SET WE1=$GET(^INWEAUFALT(YM,AUF,POS,BET,LAP,WED,1))
	. . . . set QtyIncoming   = $$$INWEAUFIncomingGoodsQuantity(WE1)              ; similar structure - no macros for INWEAUFALT
	. . . . set QtyAdditional = $$$INWEAUFAdditionalQuantity(WE1)
	. . . . set strQty = $$^WWWZAHL(QtyIncoming+QtyAdditional,0,$LENGTH($PIECE(QtyIncoming,".",2)))
	. . . . SET WEKEY=BET_LAP_WED
	. . . . SET WEMERKER=$PIECE(WE1,Y,10)
	. . . . IF WEMERKER'="" SET WEMERKER=$PIECE($GET(^INWEMERKER(YM,WEMERKER,1)),Y,1)
	. . . .;SET ^INERECH11(YM,AUF,POS,LIEF,RECH,WEKEY,1)=$EXTRACT($$^WWWZAHL(($PIECE(WE1,Y,4)+$PIECE(WE1,Y,54)),0,$LENGTH($PIECE($PIECE(WE1,Y,4),".",2)))_" x "_$$^WWWDATE(WED)_" ("_BET_"/ "_LAP_") - "_WEMERKER_YTAB,1,91)_Y
	. . . . SET ^INERECH11(YM,AUF,POS,LIEF,RECH,WEKEY,1)=$EXTRACT(strQty_" x "_$$^WWWDATE(WED)_" ("_BET_"/ "_LAP_") - "_WEMERKER_YTAB,1,91)_Y    ; SR15357
	. . . . IF $DATA(^INERECH11(YM,AUF,POS,LIEF,RECH,0)) KILL ^INERECH11(YM,AUF,POS,LIEF,RECH,0)
	
	IF '$DATA(^INWEAUF(YM,AUF,POS)) IF '$DATA(^INWEAUFALT(YM,AUF,POS)) DO
	. KILL ^INERECH11(YM,AUF,POS,LIEF,RECH)
	. SET ^INERECH11(YM,AUF,POS,LIEF,RECH,0,1)=$$^WWWTEXT(33937)  ;keine zuordnung erfolgt ; "No Allocation" 
	
	QUIT
	; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DEPRECATED CODE
	
	
KOPIE
	/*------------------------------------------------------------------------------
	;	KOPIE IN ANDERE POSITIONEN  ;copy within 
	;	
	;	Updates INERECH1, INAUFP
	; 
	; Called by:  After Saving Data in form INERECH1
	;	
	; ByRef :
	;	VORG(1)
	;	YKEY
	;	YFELD
	;
	; History :
	; 24-Jun-2009	GRF		Key macros
	;-----------------------------------------------------------------------------*/
	NEW AUF,POS,SATZ,POSX,LIE,RE,SATZ1,I,GESAMT,AB
	
	;+++++++++++++++++++++++++++++++++++++++
	;	POSX1		objINAUFP
	;	SATZ		objINAUFP		Order Line
	;	SATZ		objINAUFPA
	;	SATZ		objINAUFPK
	;+++++++++++++++++++++++++++++++++++++++
	
	QUIT:+$GET(VORG(1))=0  ;KEINE KOPIE ;no copy 
	QUIT:$GET(YKEY)=""
	SET AUF = $$$KEY1(YKEY)            QUIT:AUF=""
	SET POS = $$$KEY2(YKEY)            QUIT:POS=""
	SET LIE = $$$KEY3(YKEY)            QUIT:LIE=""
	SET RE  = $$$KEY4(YKEY)            QUIT:RE=""
	
	;---------------------------------------
	
	SET GESAMT = ""
	SET POSX   = ""
	FOR  SET POSX = $ORDER(^INAUFP(YM,AUF,POSX)) QUIT:POSX=""  DO
	. SET SATZ = $GET(^INAUFP(YM,AUF,POSX,1))
	. QUIT:$PIECE(SATZ,Y,12)'=LIE                                    ;LIEFERANT NICHT GLEICH ;supplier Not without delay 
	. SET AB = $ORDER(^INAUFPA(YM,AUF,POSX,LIE,""),-1)               ;PRÜFUNG OB AB DA ;check whether there is Confirmation 
	. IF AB'="" SET SATZ = $GET(^INAUFPA(YM,AUF,POSX,LIE,AB,1))      ;WENN AB DA,DATEN AUS AB
	. IF AB=""  SET SATZ = $GET(^INAUFPK(YM,AUF,POSX,1))             ;WENN AB NICHT DA,DATEN AUFPK
	. SET GESAMT = GESAMT+$$^INNETTO(SATZ,1)
	
	SET PRUEF = $TRANSLATE(GESAMT-VORG(1),"-")
	IF PRUEF>1 QUIT             ;MEHR ALS 1 EINHEIT UNTERSCHIED ;more when unit difference 
	
	SET POSX = ""
	FOR  SET POSX = $ORDER(^INAUFP(YM,AUF,POSX)) QUIT:POSX=""  IF POSX'=POS DO
	. SET SATZ = $GET(^INAUFP(YM,AUF,POSX,1))
	. QUIT:$PIECE(SATZ,Y,12)'=LIE                  ;LIEFERANT NICHT GLEICH ;supplier Not without delay 
	. QUIT:$DATA(^INERECH1(YM,AUF,POSX,LIE,RE,1))  ;SCHON RE VORHANDEN ;yet on hand 
	. ;
	. ;PRÜFUNG OB AB VON LIEFERANTEN DATEN DA IST ;check whether there is Confirmation
	. SET AB = $ORDER(^INAUFPA(YM,AUF,POSX,LIE,""),-1)
	. IF AB'="" SET SATZ = $GET(^INAUFPA(YM,AUF,POSX,LIE,AB,1))     ;AUS AUFTRAGBESTÄTIGUNG VON LIEFERANTEN ;out of 
	. IF AB=""  SET SATZ = $GET(^INAUFPK(YM,AUF,POSX,1))            ;AUS AUFTRAG LIEFERANTENINFO ;out of order 
	. QUIT:SATZ=""
	. ;
	. SET SATZ1=YFELD
	. ;FOR I=2,3,4,5,6,7,8,9,10,12,13,16,22,18,47,26,15 SET $PIECE(SATZ1,Y,I)=$PIECE(SATZ,Y,I)  ;AUS INAUFPK  ;FIS;FREMDWÄHRUNGSFELDER;27.04.08;26316
	. FOR I=2:1:10,12,13,15,16,18,22,26,47,68,78,79 SET $PIECE(SATZ1,Y,I) = $PIECE(SATZ,Y,I)  ;AUS INAUFPK  ; SR15357
	. SET $PIECE(SATZ1,Y,13) = $$^INNETTO(SATZ1)
	. SET $PIECE(SATZ1,Y,22) = $$^INNETTO(SATZ1,1)
	. SET YOK = $$^WWWSPEI("INERECH1",AUF_","_POSX_","_LIE_","_RE,SATZ1)  ;SPEICHERN UND SORTKEY ;Save And
	. ;
	. ;Bei Bestellsystem (Internet) Eingangsrechnung=Wareneingang/AUSGANG;FIS;18.01.05
	. IF $PIECE($GET(^INLIEF(YM,LIE,1)),Y,244)=1 DO
	. . NEW POSX1,POSXX
	. . SET POSX1 = $GET(^INAUFP(YM,AUF,POSX,1))
	. . QUIT:$PIECE(POSX1,Y,91)'=""                    ;SCHON OK 
	. . ;
	. . SET $PIECE(POSX1,Y,90) = 1                       ;AUSLIEFERFÄHIG
	. . SET $PIECE(POSX1,Y,85) = "SYSTEM"                ;BESTELLUNG
	. . SET $PIECE(POSX1,Y,83) = +$HOROLOG               ;DRUCKDATUM      ; FIXME : avoid time changing <GRF>
	. . SET $PIECE(POSX1,Y,84) = $PIECE($HOROLOG,",",2)  ;UHRZEIT
	. . SET $PIECE(POSX1,Y,91) = "AUTO"                  ;LIEFERSCHEIN
	. . SET $PIECE(POSX1,Y,92) = +$HOROLOG               ;DRUCKDATUM
	. . SET $PIECE(POSX1,Y,93) = $PIECE($HOROLOG,",",2)  ;UHRZEIT
	. . SET $PIECE(POSX1,Y,94) = "SYSTEM"
	. . NEW YFORM,YVOR,YOK
	. . SET YOK = $$^WWWSPEI("INAUFP",AUF_","_POSX,POSX1,$$$YES)
	. . ;
	. . ; ZUSATZBESTELLPOSITION EBENFALLS AUF GELIEFERT SETZEN;FIS;02.03.05;27043
	. . IF $DATA(^INAUFPs(YM,14,$$^WWWUMLAU(AUF,1),$$^WWWUMLAU("#"_POSX,1))) DO
	. . . SET POSXX = $ORDER(^INAUFPs(YM,14,$$^WWWUMLAU(AUF,1),$$^WWWUMLAU("#"_POSX,1),AUF,""))
	. . . QUIT:POSXX=""
	. . . SET POSX1 = $GET(^INAUFP(YM,AUF,POSXX,1))
	. . . QUIT:$PIECE(POSX1,Y,91)'=""                    ;SCHON OK 
	. . . ;
	. . . SET $PIECE(POSX1,Y,90) = 1                       ;AUSLIEFERFÄHIG
	. . . SET $PIECE(POSX1,Y,85) = "SYSTEM"                ;BESTELLUNG
	. . . SET $PIECE(POSX1,Y,83) = +$HOROLOG               ;DRUCKDATUM
	. . . SET $PIECE(POSX1,Y,84) = $PIECE($HOROLOG,",",2)  ;UHRZEIT
	. . . SET $PIECE(POSX1,Y,91) = "AUTO"                  ;LIEFERSCHEIN
	. . . SET $PIECE(POSX1,Y,92) = +$HOROLOG               ;DRUCKDATUM
	. . . SET $PIECE(POSX1,Y,93) = $PIECE($HOROLOG,",",2)  ;UHRZEIT
	. . . SET $PIECE(POSX1,Y,94) = "SYSTEM"
	. . . NEW YFORM,YVOR,YOK
	. . . SET YOK=$$^WWWSPEI("INAUFP",AUF_","_POSXX,POSX1,$$$YES)
	
	QUIT
	
	
PRUEF1(YKEY,YFELD,YDATEI,RECHEPFINOverride,pidLocn,pidStkLocn)
	;-------------------------------------------------------------------------------
	; Wrapper to keep passing of RECHEPFINOverride as a persistent variable within this routine.
	; need to cover any existing calls to PRUEF^INERECH1
	;
	; Called by:
	;	PostINERECH^FINAPInvPostCost
	;
	; Inputs : 
	;	YKEY		pidINERECH1  Order No "," Order Line "," Supplier "," InvoiceNo(*)
	;	YFELD		objINERECH1
	;	YDATEI		Class Name  "INERECH1"
	;	pidLocn		| Receipt Location
	;	pidStkLocn	|
	; 
	; (*)  This is
	;           Supplier's_InvoiceNo
	;      or   Shipping_Cost_Supplier's_InvoiceNo#CostType
	; 
	; History:
    ; 15-Jul-2006	GRF		SR14471: Get and pass pidInvLine to PRUEF1^INERECH1
	; 06-Jul-2006	GRF		SR14471: Created
	;-------------------------------------------------------------------------------
	; NOTE : YFELD may be overwritten by a later Invoice Line for the same order line
	;        (e.g. when two receipts for an order line are processed on the same Invoice
	;        as separate lines)
	;        At the time this routine is called the INERECH record matches the Invoice line.
	;        It shows the quantity being invoiced - not the quantity being received.
	;        e.g.  Order 18   Receive 12 + 6    Invoice 1 Line 1   10
	;                                           Invoice 1 Line 2    6
	;                                           Invoice 2 Line 1    2
	;              INERECH1 D16 will show 10 then 6 for Invoice 1 (using Supplier's InvoiceNo)
	;                                 and  2        for Invoice 2
	;-------------------------------------------------------------------------------
	do PRUEF
	quit
	
PRUEF
	/*------------------------------------------------------------------------------
	; 	EVTL. PREISKORREKTUR IN INWE BZW. INWEAUF  
	; 	MÖGLICHE PREISKORREKTUR HINZUGEFÜGT
	; 
	; 	Updates ^INWE, ^INWEAUF
	; 
	; Called by:
	;   <After Saving Data> in form INERECH1  (POST of SUPPLIER INVOICE)
	;	INSERV191
	;	No internal call
	; 
	; TODO : Will 15-Jul-2006 changes cause problems if this subroutine is called from
	;        some other area - especially via form INERECH1? <GRF>  Should be checked in
	;        that particular case for Shipping Costs.
	; 
	; Params:
	;	YKEY
	;	
	; ByRefs:
	;	YFELD		        (objINERECH1)
	;	RECHEPFINOverride   (passed from PRUEF1)
	;	                    (built from $$GetReceiptUnitCost^FINAPInvPrePostCost which is
	;	                    the unit cost for the invoice line averaged for invoiced and
	;	                    uninvoiced quantities
	;   pidLocn,pidStkLocn  Receipt Location from FINAPInvPostCost
	;   
	; Returns: nothing
	;
	; History:
	; 24-Jun-2009	GRF		Key macros
	; 15-Sep-2006	GRF		SR14471: use received quantity, expand comments - move outside dots
	; 25-Jul-2006	GRF		SR14471: INERECH1 D72 not managing FC Var - test not
	; 						needed for AvgCost update?
	; 15-Jul-2006	GRF		SR14471: Get Receipt Locations & use in StockVal
	; 15-Jul-2006	GRF		SR14471: relocate large block of disabled code
	; 11-Jul-2006	GRF		SR14471: use UnitCostWithoutSC/UnitCostWithSC
	; 13-Jun-2006	GRF		SR14471: Add call to INShipVal;
	; 01-Feb-2006	GRF		SR14203: Revise^INARTAVG extracted from INERECH1 & INSHIPINFOCOSTS
	; 10-Jun-2005	JW		SR12484: Use receipt unit cost.
	; 02.Aug.2004	FIS		26170
	; 23.Jul.2004	FIS		26142 WE IST NICHT ZUGEORDNET
	; 08.Apr.2004	FIS		25521
	; 28.Nov.2003	WEM		24630
	;-----------------------------------------------------------------------------*/
	new ART,AUF,BET,curPrevCost,invoiceQty,LIE,LIEF,LP,MENGE1,MENGEG,NOSET,objAvge
	new POS,RE,receiptQty,receiptUnitCost,RECH,RECHEE,RECHEP,RECHEP1,SATZ2,SATZ3
	new ServiceCosts,UEBERTR,WE,KEY,YOK,YQ
	
	$$$LogR("PRUEF1",$g(YKEY))
	quit:$get(YKEY)=""
	
	SET AUF  = $$$KEY1(YKEY)           QUIT:AUF=""      ; Order No
	SET POS  = $$$KEY2(YKEY)           QUIT:POS=""      ; Order Line
	SET LIE  = $$$KEY3(YKEY)           QUIT:LIE=""      ; Supplier
	SET RECH = $$$KEY4(YKEY)           QUIT:RECH=""     ; Internal Invoice No
	
	/*++++++++++++++++++++++++++++++++++++++
	;	YFELD		objINERECH1 - Input record
	;	RECH1		objINERECH1 - review all Suppliers
	;	SATZ2		objINWE
	;	SATZ3		objINWEAUF
	;	WE1			objINWEAUF
	;+++++++++++++++++++++++++++++++++++++++*/
	
	SET YFELD = $GET(YFELD)
	IF YFELD="" SET YFELD = $GET(^INERECH1(YM,AUF,POS,LIE,RECH,1))
	
	;		D72		$$$INERECH1TransferNetPurchasePriceI    ;...Into Inventory
	IF '$DATA(^INWEAUF(YM,AUF,POS)) DO  QUIT  ;KEINE WE VORHANDEN;TYBD;28,11,2003
	. QUIT:$PIECE(YFELD,Y,72)=""
	. SET $PIECE(^INERECH1(YM,AUF,POS,LIE,RECH,1),Y,72)=""  ;LÖSCHEN KLICKFELD ;Delete 
	. SET $PIECE(YFELD,Y,72)=""
	
	
	
	
	
	;-------------------------------------------------------------------------------
	;
	;
	; As ^INWEAUF is no longer maintained the following code will never be executed.
	; FIXME : Does this mean we are missing some necessary update from 3WM variations?
	; 
	;
	;-------------------------------------------------------------------------------
	
	
	
	
	
	
	
	SET ART = $PIECE($GET(^INAUFP(YM,AUF,POS,1)),Y,4) ; ARTIKELNUMMER    ; Item No.
	
	;--------------------------------------- vvv
	; FIXME : see FIXME below re MENGE
	;
	; proposed code change <GRF>
	; 15-Sep-2006
	;
	set MENGE = $$$INAUFPIncomingGoodsQuantity($GET(^INAUFP(YM,AUF,POS,1)))   ; D109
	if 'MENGE set MENGE = $$$INAUFPQuantity($GET(^INAUFP(YM,AUF,POS,1)))      ; D5
	quit:'MENGE
	;
	;---------------------------------------
	
	;SET MENGE = $PIECE($GET(^INAUFP(YM,AUF,POS,1)),Y,5) ; AUFTRAGSMENGE    ; Order Quantity
	;IF +MENGE=0 QUIT
	
	;--------------------------------------- ^^^
	
	;-------------------------------------------------------------------------------
	;  Unit Price Without Service Charges (RECHEP)     ;EINZEL-EK    NEU;FIS;08.04.04;25521
	;  Calculated in EINZELEK
	;-------------------------------------------------------------------------------
	SET RECHEP=0  
	DO EINZELEK    ; sets MENGE1 & RECHEP
	
	;-------------------------------------------------------------------------------
	;  Invoiced Service Cost (SERVCOST)                     ZZGL. SERVICEKOSTENRECHNUNGEN;FIS;09.09.04;25736
	;  Go through *ALL* Supplier Invoices for this order line, not just the one
	;  being posted.
	;  Add to Unit Price
	;  D13		$$$INERECH1NetPurchasePrice()
	;  D72		$$$INERECH1TransferNetPurchasePriceI()  ...IntoInventory
	;  D75		$$$INERECH1MatchedIncomingGoods()
	;  D80		$$$INERECH1ServiceCostsInvoice()
	;  D81		$$$INERECH1PlusServiceCostsInvoice()
	;-------------------------------------------------------------------------------
	
	;-------------------------------------------------------------------------------
	;  Receipt UNIT cost - supplied stock unit cost
	;                      
	;  RECHEPFINOverride (if called from PostINERECH^FINAPInvPostCost) may provide
	;                      overriding supplied stock value from combination of
	;                      Invoiced and Uninvoiced supplied stock with current
	;                      service costs.
	;  
	;  Note : variable "WE" may have the form "date.seq" in INWE and INWEAUF
	;-------------------------------------------------------------------------------
	set ServiceCosts = $$CurrentServiceCosts(AUF,POS)
	
	;---------------------------------------
	; FIXME : This MENGE appears to be the order quantity, not the
	;         Goods Received Quantity and as such can result in an
	;         inflated figure.
	;         e.g.
	;         Costs of $670.00 for 335 items is stored as $2.00
	;         When 345 are received ServiceCosts is returned as
	;         $690.00 but MENGE is still 335 calculating as $2.06
	;         instead of $2.00.                                   <GRF>
	;         Use INAUFP D109 Incoming Goods Quantity rather than
	;         D5 Order Quantity?
	;---------------------------------------
	
	set receiptUnitCost = $justify($get(RECHEPFINOverride,RECHEP) + (ServiceCosts/MENGE),0,2)
	
	;-------------------------------------------------------------------------
	;  Update INWE and INWEAUF with new Unit Price With Service Charges
	;  Note : variable "WE" may have the form "date.seq" in INWE and INWEAUF
	;  
	;  FIXME : ? Doesn't seem to be happening - possibly due to D72 or D75 <GRF>
	;  NOTE  : D75 does store BET,LP,WE in one field without intervening delimiters.
	;-------------------------------------------------------------------------
	
	;vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv FIXME : INWE/INWEAUF now DEPRECATED
	
	SET UEBERTR=0
	IF receiptUnitCost'=0 IF +$PIECE(YFELD,Y,72)=1 DO  ;PREISE ÜBERTRAGEN (WENN NOCH NICHT GESCHEHEN);FIS;14.07.04 ;transport yet Not 
	. SET BET=""
	. FOR  SET BET=$ORDER(^INWEAUF(YM,AUF,POS,BET)) QUIT:BET=""  DO
	. . SET LP=""
	. . FOR  SET LP=$ORDER(^INWEAUF(YM,AUF,POS,BET,LP)) QUIT:LP=""  DO
	. . . SET WE=""
	. . . FOR  SET WE=$ORDER(^INWEAUF(YM,AUF,POS,BET,LP,WE)) QUIT:WE=""  DO
	. . . . ;
	. . . . IF $PIECE(YFELD,Y,75)'="" QUIT:'$FIND(";"_$PIECE(YFELD,Y,75)_";",";"_BET_LP_WE_";")  ;FIS;WE IST NICHT ZUGEORDNET;26142;23.07.04
	. . . . ;
	. . . . IF ART'="" DO
	. . . . . ;SET UEBERTR=1 ;table-mat 
	. . . . . ;---------------------------------------------------------------------
	. . . . . ;  Update Unit Lot Cost (D8) in Stock On Hand record (INWE)
	. . . . . ;---------------------------------------------------------------------
	. . . . . IF $DATA(^INWE(YM,ART,BET,LP,WE)) DO
	. . . . . . SET SATZ2=$GET(^INWE(YM,ART,BET,LP,WE,1))
	. . . . . . IF SATZ2'="" IF +$PIECE(SATZ2,Y,8)'=+receiptUnitCost DO  ;NICHT UMGELAGERT, INWE EK UNGLEICH INRECH EK -> ÄNDERUNG IN INWE
	. . . . . . . ;IF ($PIECE(SATZ2,Y,28)'=AUF) || ($PIECE(SATZ2,Y,29)'=POS) QUIT  ;WE NICHT AUS DIESER POSITION
	. . . . . . . SET KEY = ART_","_BET_","_LP_","_WE
	. . . . . . . DO ^INSYSLOG("INERECH1","INWE",$TRANSLATE(KEY,",",";"),8,1,$PIECE(SATZ2,Y,8),receiptUnitCost)
	. . . . . . . ;SET $PIECE(SATZ2,Y,8)=RECHEP                               ; UPDATE INWE EK DURCH E-RG. EK ;Planned Cost trans- Planned Cost 
	. . . . . . . SET $PIECE(SATZ2,Y,8)=receiptUnitCost  ;SR12484
	. . . . . . . DO
	. . . . . . . . NEW YFORM,YVOR,YOK
	. . . . . . . . SET YOK=$$^WWWSPEI("INWE",KEY,SATZ2,$$$YES)
	. . . . . . . . SET UEBERTR=1
	. . . . . ;
	. . . . . ;---------------------------------------------------------------------
	. . . . . ;  Update Unit Price (D8) in Incoming Goods record (INWEAUF)
	. . . . . ;  Have just used $order so do we need $data?
	. . . . . ;---------------------------------------------------------------------
	. . . . . IF $DATA(^INWEAUF(YM,AUF,POS,BET,LP,WE)) DO
	. . . . . . SET SATZ3=$GET(^INWEAUF(YM,AUF,POS,BET,LP,WE,1))
	. . . . . . IF SATZ3'="" DO
	. . . . . . . IF $PIECE($GET(^INAUF(YM,AUF,1)),Y,2)=0 DO    ; KUNDENAUFTRAG -> ÄNDERUNGEN IN INWEAUF ;customer´s order within 
	. . . . . . . . SET KEY = AUF_","_POS_","_BET_","_LP_","_WE
	. . . . . . . . DO ^INSYSLOG("INERECH1","INWEAUF",$TRANSLATE(KEY,",",";"),8,1,$PIECE(SATZ3,Y,8),receiptUnitCost)
	. . . . . . . . ;SET $PIECE(SATZ3,Y,8)=RECHEP                 ; UPDATE INWEAUF EK DURCH E-RG. EK ;Planned Cost trans- Planned Cost 
	. . . . . . . . SET $PIECE(SATZ3,Y,8)=receiptUnitCost  ;SR12484
	. . . . . . . . DO
	. . . . . . . . . NEW YVOR,YFORM
	. . . . . . . . . SET YOK=$$^WWWSPEI("INWEAUF",KEY,SATZ3,$$$YES)
	. . . . . . . . . IF $PIECE($GET(^INAUF(YM,AUF,1)),Y,2)'=2 SET UEBERTR=1    ; not a Purchase Order
	
	; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DEPRECATED CODE
	
	;-------------------------------------------------------------------------
	;  Update the INStockVal records BEFORE losing accuracy.
	;-------------------------------------------------------------------------
	;do StockVal(AUF,POS,ART,receiptUnitCost)  ;15-Jul-2006
	do StockVal(AUF,POS,ART,receiptUnitCost,pidLocn,pidStkLocn)  ; see PRUEF1 tag
	
	;KORRIGIEREN DURCHSCHNITTLICHER EK;FIS;25398;24.03.04  -> ACHTUNG: BENÖTIGT AUCH VARIABLEN VON OBEN !!
	;CORRECT AVERAGE COST - NOTE: ALSO NEED VARIABLES FROM ABOVE
	;-------------------------------------------------------------------------------
	; Loop through all the Storages & Receipt Dates for an order
	; Find matching average cost history entry and replace the "Received Goods" unit price
	; ready for recalculation.
	; 
	; NOTE #1
	; DAT,UHR are horolog date and time
	;   Where an order line is received as multiple deliveries on the same date,
	;   UHR will have .00001 increments so each has its own INWEAUF record - these
	;   will also be unique references within the Average Cost History.
	;   
	;   Each INARTAVG record is updated separately - one INWEAUF to one INARTAVG -
	;   and the earliest INARTAVG entry is identified to allow Revise^INARTAVG to
	;   process from that point forward.
	;
	; TODO : Simplify with use of pidLocn,pidStkLocn for BET,LAP shortcut <GRF>
	;-------------------------------------------------------------------------------

	IF receiptUnitCost'=0 IF ART'="" IF $DATA(^INARTAVG(YM,ART)) DO
	. NEW AVERAGE,AVG1,BET,DAT,DATX,LAP,MENGEX,SUCH,UHR,UHRX,WED
	. SET MENGEX=0
	. SET DATX=""
	. SET UHRX=""
	. IF $DATA(^INWEAUF(YM,AUF,POS)) DO
	. . SET BET=""
	. . FOR  SET BET=$ORDER(^INWEAUF(YM,AUF,POS,BET)) QUIT:BET=""  DO  QUIT:MENGEX'<MENGE1
	. . . SET LAP=""
	. . . FOR  SET LAP=$ORDER(^INWEAUF(YM,AUF,POS,BET,LAP)) QUIT:LAP=""  DO  QUIT:MENGEX'<MENGE1
	. . . . SET WED=""
	. . . . FOR  SET WED=$ORDER(^INWEAUF(YM,AUF,POS,BET,LAP,WED)) QUIT:WED=""  DO  QUIT:MENGEX'<MENGE1
	. . . . . SET WE1=$GET(^INWEAUF(YM,AUF,POS,BET,LAP,WED,1))
	. . . . . ;IF $PIECE(WE1,Y,105)'="" QUIT       ;BEREITS KORRIGIERT  ;IMMER RECHNEN;FIS;26170;02.08.04
	. . . . . ;-----------------------------
	. . . . . ;  INCOMING GOODS ARE NOT ASSIGNED   ;WE IST NICHT ZUGEORDNET
	. . . . . ;  FIXME : ? What circumstances stop D75 being set to this string? <GRF>
	. . . . . ;          Evidence in Ad*** that it is empty.
	. . . . . IF $PIECE(YFELD,Y,75)'="" QUIT:'$FIND(";"_$PIECE(YFELD,Y,75)_";",";"_BET_LAP_WED_";")  ;FIS;27391;23.02.05
	. . . . . SET $PIECE(^INWEAUF(YM,AUF,POS,BET,LAP,WED,1),Y,105)=1     ; Avg Cost Corrected with Invoice - Direct Save
	. . . . . IF $PIECE(WE1,Y,4)'>0 QUIT
	. . . . . SET MENGEX=MENGEX+$PIECE(WE1,Y,4)   ; Total qty received for order line
	. . . . . ;
	. . . . . ;-----------------------------
	. . . . . ; Order Index for Average Cost History  ; see NOTE #1
	. . . . . ; JW SR11802: There will be no order if it is a Receipt Without Order
	. . . . . ;-----------------------------
	. . . . . SET SUCH=$$^WWWUMLAU(AUF_"-"_POS_"-"_BET_"-"_LAP_"-"_WED,1)
	. . . . . IF '$DATA(^INAUF(YM,AUF,1)) SET SUCH=$$^WWWUMLAU(0_"-"_0_"-"_BET_"-"_LAP_"-"_WED,1)
	. . . . . ;
	. . . . . IF $DATA(^INARTAVGs(YM,1,SUCH)) DO
	. . . . . . SET DAT=""
	. . . . . . FOR  SET DAT=$ORDER(^INARTAVGs(YM,1,SUCH,ART,DAT)) QUIT:DAT=""  DO
	. . . . . . . SET UHR=""
	. . . . . . . FOR  SET UHR=$ORDER(^INARTAVGs(YM,1,SUCH,ART,DAT,UHR)) QUIT:UHR=""  DO
	. . . . . . . . ;SET $PIECE(^INARTAVG(YM,ART,DAT,UHR,1),Y,4)=RECHEP  ;EINZEL-EK KORRIGIEREN
	. . . . . . . . SET $PIECE(^INARTAVG(YM,ART,DAT,UHR,1),Y,4)= receiptUnitCost ;SR12484
	. . . . . . . . IF DATX=""     SET DATX=DAT,UHRX=UHR QUIT  ;MERKEN KEY DER ÄNDERUNG (ÄLTESTER WE) ;KEY the alteration 
	. . . . . . . . IF DATX>DAT    SET DATX=DAT,UHRX=UHR QUIT
	. . . . . . . . IF DATX=DAT IF UHRX>UHR SET UHRX=UHR
	. ;
	. QUIT:+MENGEX=0  ;KEIN WE GEÄNDERT ;NO INCOMING GOODS CHANGED 
	. ;
	. ; Average Cost Recalculation
	. ;+++++++++++++++++++++++++++++++++++++
	. do Revise^INARTAVG("INERECH1",AUF_","_POS_","_LIE_","_RECH_"|"_DATX_","_UHRX,ART,DATX,UHRX)   ; SR14203 Use common code
	
	; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DEPRECATED CODE
	
	
	;+++++++++++++++++++++++++++++++++++++++
	;		D72		$$$INERECH1TransferNetPurchasePriceI()
	;		D73		$$$INERECH1UnitPriceTransferedAt()
	;		D74		$$$INERECH1TransferedUnitPrice()
	;+++++++++++++++++++++++++++++++++++++++
	
	;ACHTUNG: ERST DURCHSCHNITTSKOSTEN RECHNEN, DANN HÄKCHEN ZURÜCKSETZEN !
	IF UEBERTR=1 SET $PIECE(YFELD,Y,73)=+$HOROLOG
	SET $PIECE(YFELD,Y,72)=""  ;HÄKCHEN RAUSNEHMEN
	SET $PIECE(YFELD,Y,74)=RECHEP
	IF UEBERTR=1 SET $PIECE(^INERECH1(YM,AUF,POS,LIE,RECH,1),Y,73)=+$HOROLOG  ;ÜBERTRAGUNGSDATUM
	SET $PIECE(^INERECH1(YM,AUF,POS,LIE,RECH,1),Y,72)=""            ;LÖSCHEN KLICKFELD ;Delete 
	SET $PIECE(^INERECH1(YM,AUF,POS,LIE,RECH,1),Y,74)=RECHEP
	
	QUIT
	; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  DEPRECATED CODE ; SR16871
	
CurrentServiceCosts(pidOrder,pidOrderLine)
	;-------------------------------------------------------------------------------
	; Return the total of the invoiced Shipping Costs at actual value and
	; the uninvoiced Shipping Costs at the initial estimate.  This will be combined
	; with the combined invoiced/uninvoiced unit cost for the main supply.
	;
	; Note : variable "dteRecvd" may have the form "date.seq" in INWEAUF
	; 
	; Inputs : 
	;	pOrderNo
	;	pOrderLine
	; 
	; History:
	; 14-Jul-2006	GRF		SR14471: Replaced INSHIPINFOCOSTS version
	; 12-Jul-2006	GRF		SR14471: Base on INWEAUF
	; 11-Jul-2006	GRF		SR14471: Created
	;-------------------------------------------------------------------------------
	new arrCost,CostType,curActualSC,curEstimatedSC,curInvAmt,curShipCost,dteRecvd,idInvNum,idLocn
	new idShipCost,idStkLocn,idSupplier,IncomingQty
	new objINERECH1,objINWEAUF,objShipCost,ShipCostList,ShipCostNo
	
	set curActualSC    = 0
	set curEstimatedSC = 0
	
	;+++++++++++++++++++++++++++++++++++
	; 1. a) Actual Shipping Costs 
	; FIXME : Multiple A]]><![CDATA[lphalinc Invoice Lines for same order line (matching separate receipts)
	;         will over-write the INERECH1 record. <GRF>
	;         Refers to supplier invoice no rather than Alphalinc Invoice No
	;+++++++++++++++++++++++++++++++++++
	set idSupplier = ""
	for {
		set idSupplier = $order(^INERECH1(YM,pidOrder,pidOrderLine,idSupplier))
		quit:idSupplier=""
		
		set idInvNum = ""
		for {
			set idInvNum = $order(^INERECH1(YM,pidOrder,pidOrderLine,idSupplier,idInvNum))
			quit:idInvNum=""
			
			set objINERECH1 = $get(^INERECH1(YM,pidOrder,pidOrderLine,idSupplier,idInvNum,1))
			set curInvAmt   = $$$INERECH1InvoiceAmount(objINERECH1)    ; D22
			
			if idInvNum["#" {       ; Actual Shipping Costs
				set CostType = $piece(idInvNum,"#",2)
				set arrCost(CostType) = ""
				set curActualSC = curActualSC + curInvAmt
			}
		}
	}
	
	;+++++++++++++++++++++++++++++++++++
	; 2. Estimated Shipping Costs
	;    Extract Shipping Costs from paired entries in string : "%3B"_COSTTYPE_"%7C"_COST
	;+++++++++++++++++++++++++++++++++++
	
	;vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv FIXME : INWE/INWEAUF now DEPRECATED
	set idLocn = ""
	for {
		set idLocn = $order(^INWEAUF(YM,pidOrder,pidOrderLine,idLocn))
		quit:idLocn=""
		
		set idStkLocn = ""
		for {
			set idStkLocn = $order(^INWEAUF(YM,pidOrder,pidOrderLine,idLocn,idStkLocn))
			quit:idStkLocn=""
			
			set dteRecvd = ""
			for {
				set dteRecvd = $order(^INWEAUF(YM,pidOrder,pidOrderLine,idLocn,idStkLocn,dteRecvd))
				quit:dteRecvd=""
				
				set objINWEAUF   = $get(^INWEAUF(YM,pidOrder,pidOrderLine,idLocn,idStkLocn,dteRecvd,1))
				set IncomingQty  = $$$INWEAUFIncomingGoodsQuantity(objINWEAUF)                  ; D4
				
				set ShipCostList = $$$INWEAUFFinanceTxRef(objINWEAUF)    ; D115  Shipping Charges
				set ShipCostNo   = 1           ; always starts with delimiter
				for {
					set ShipCostNo  = ShipCostNo + 1
					set objShipCost = $piece(ShipCostList,"%3B",ShipCostNo)
					quit:objShipCost=""
					
					set idShipCost = $piece(objShipCost,"%7C",1)
					if '$data(arrCost(idShipCost)) {
						set curShipCost    = $piece(objShipCost,"%7C",2) * IncomingQty
						set curEstimatedSC = curEstimatedSC + curShipCost
					}
				}
			}
		}
	}
	; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DEPRECATED CODE
	
	quit (curActualSC+curEstimatedSC)
	
	
GetUninvoicedQty(pidOrder,pidOrderLine)
	;-------------------------------------------------------------------------------
	; If Invoice Qty is less than Receipt Qty need to account for uninvoiced qty at
	; estimated costs.  This returns the uninvoiced qty.
	; 
	; History:
	; 13-Jul-2006	GRF		SR14471/14694: created
	;-------------------------------------------------------------------------------
	new idInvMatch,objCache
	
	set idInvMatch = $order(^FINAPInvMatchCaches(YM,1,$$$Index(pidOrder),$$$Index(pidOrderLine),""),-1)
	set objCache   = $get(^FINAPInvMatchCache(YM,idInvMatch,1))
	quit +$$$FINAPInvMatchCacheUnmatchedQuantity(objCache)
 
	
StockVal(pidOrderNo,pidOrderLine,pidItem,pcurUnitCost,pidXXLocn,pidXXStore)
	;-------------------------------------------------------------------------------
	; 
	; pcurUnitCost (the invoiced amount of this order line) is provided before rounding to
	; 		avoid compounding any rounding loss. [Includes both Supply and Shipping Costs]
	; 
	; History:
	; 12-May-2009	DWR		SR16363: Created - Modified original (OldStockVal) to now
	; 							use INRECSummary 
	;-------------------------------------------------------------------------------
	new curDiff,curEstCost,curEstChgs,curNewValue,curNewSummValue,curOldValue,curOldSummValue
	new fltRecLineQty,fltTotSummQty,idLineType,idLocn,idRecLine,idStore,idSummary,idSummLine
	new idxLineNo,idxOrder,objRecLine,objSumm
		
	$$$LogR("StockVal",pidOrderNo_","_pidOrderLine_":"_pidItem_","_pcurUnitCost)
	
	set curEstCost    = 0
	set curEstChgs    = 0
	set fltTotSummQty = 0
	
	set idxOrder  = $$$Index(pidOrderNo)
	set idxLineNo = $$$Index(pidOrderLine)
	
	set idSummary      = ""
	for {
		set idSummary = $order(^INRECSummarys(YM,1,idxOrder,idxLineNo,idSummary))
		quit:idSummary=""
		
		set idSummLine=""
		for {
			set idSummLine= $order(^INRECSummarys(YM,1,idxOrder,idxLineNo,idSummary,idSummLine))
			quit:idSummLine=""
			
			set objSumm    = $get(^INRECSummary(YM,idSummary,idSummLine,1))
			set idLineType = $$$INRECSummaryLineType(objSumm)
			if idSummLine\1=idSummLine{ 
				if idLineType=0 {   ; standard   FIXME: does this need to include bonus stock also? <DWR>
					set fltTotSummQty = fltTotSummQty + $$$INRECSummaryQuantityReceived(objSumm)
					set curEstCost    = curEstCost    + $$$INRECSummaryExtendedCost(objSumm)    ; Estimated Supply Costs without SC
				}
			
			} else {
				if (idLineType=3) || (idLineType=4) ||(idLineType=5) {   ;3-Tax || 4-Freight || 5-Surcharge
					set curEstChgs = curEstChgs + $$$INRECSummaryCostAfterDiscount(objSumm) 
				}
			}
		}
	;}
		; FIXME : Account for virtual rounding e.g. $10 freight over 3 items allocated separately <GRF>
		set curNewSummValue = pcurUnitCost * fltTotSummQty
		set curOldSummValue = curEstCost   + curEstChgs
		
		set idRecLine = $order(^INRECLine(0,idSummary,idSummLine),-1)
		for {
			set idRecLine = $order(^INRECLine(0,idSummary,idRecLine))
			quit:idRecLine\1'=idSummLine
			
			set objRecLine = $get(^INRECLine(0,idSummary,idRecLine,1))
			set fltRecLineQty = $$$INRECLineQuantity(objRecLine)         
		
			if fltRecLineQty {
				set idLocn  = $$$INRECLineLocation(objRecLine)         
				set idStore = $$$INRECLineStockLocation(objRecLine)    
				
				if fltTotSummQty {
					set curNewValue = curNewSummValue * (fltRecLineQty/fltTotSummQty)
					set curOldValue = curOldSummValue * (fltRecLineQty/fltTotSummQty)
				} else {
					set curNewValue = 0
					set curOldValue = 0
				}
				
				set curDiff = $justify(curNewValue - curOldValue,0,2)
				if curDiff do Update^INStockVal(pidItem,idLocn,idStore,$$$YES,0,curDiff)
			}
		}
	}
	quit
	
	
	;vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv INWE/INWEAUF now DEPRECATED
	/*
oldStockVal(pOrderNo,pOrderLine,pItemNo,pCost,pidLocn,pidStkLocn) ; DO NOT USE - OBSOLETE
	new curEstCost,curEstSC,curShipCost,dteRecvd,objINWEAUF,objShipCost
	new RecQty,ShipCostList,ShipCostNo,TotalRecQty,Value
	
	set curEstCost  = 0
	set curEstSC    = 0
	set TotalRecQty = 0
	set dteRecvd    = ""
		for {
		set dteRecvd = $order(^INWEAUF(YM,pOrderNo,pOrderLine,pidLocn,pidStkLocn,dteRecvd))
		quit:dteRecvd=""
		
		set objINWEAUF  = $get(^INWEAUF(YM,pOrderNo,pOrderLine,pidLocn,pidStkLocn,dteRecvd,1))
		set RecQty      = $$$INWEAUFIncomingGoodsQuantity(objINWEAUF)             ; D4
		set TotalRecQty = TotalRecQty + RecQty
		
		;-----------------------------------
		; 1. Estimated Supply Costs without SC
		;-----------------------------------
		set curEstCost = curEstCost + $$$INWEAUFTotalCostOnLocation(objINWEAUF)   ; D62   Line Cost
	
		;-----------------------------------
		; 2. Extract Shipping Costs from paired entries in string : "%3B"_COSTTYPE_"%7C"_COST
		; 
		; ASSUMPTION : All supplier invoices are processed before any shipping cost invoices
		;              so no need to consider actual/estimates here. 
		;-----------------------------------
		set ShipCostList = $$$INWEAUFFinanceTxRef(objINWEAUF)                     ; D115  Shipping Charges
		set ShipCostNo   = 1                              ; position in list; always starts with delimiter
		for {
			set ShipCostNo  = ShipCostNo + 1
			set objShipCost = $piece(ShipCostList,"%3B",ShipCostNo)
			quit:objShipCost=""
			
			set curShipCost = $piece(objShipCost,"%7C",2) * RecQty
			set curEstSC    = curEstSC + curShipCost
		}
	}
	set Value = $justify((pCost * TotalRecQty) - (curEstCost + curEstSC),0,2)
	do Update^INStockVal(pItemNo,pidLocn,pidStkLocn,$$$YES,0,Value)
	quit
	;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ DEPRECATED CODE
	*/
	
EINZELEK
    ;-------------------------------------------------------------------------------
    ; Unit cost
    ; ACHTUNG EINSPRUNG ;attention re-entry point
    ; 
    ; Note: This is also called by INERECH1D13
    ; 
    ; Inputs:
    ; 	YFELD
    ; 	AUF
    ; 	POS
    ; 
    ; ByRef:
    ; 	RECHEP
    ; 	RECHEE	Purchase Price - not used above.  FIXME : Should we new this? <GRF>
    ;   MENGE1	(Which?) Quantity - used in PRUEF
    ; Returns:
    ;
    ; History:
    ; 08-Apr-2009	GRF		SR16363: permit zero order cost since may not have been
    ; 							available at time order was placed - invoice process
    ; 							deals with variance.
    ; 13-Jun-2006	GRF		SR14471: Doco; combine new commands
    ; 15-Jun-2005	JW		SR12484: Commented, added macros
    ;-------------------------------------------------------------------------------
	new ART,FACTOR,objINAUFPK,objINAUFP
	
	$$$LogR("EINZELEK",AUF_","_POS)
	set objINAUFPK = $GET(^INAUFPK(YM,AUF,POS,1))        ; Item Supplier Terms
	set objINAUFP  = $GET(^INAUFP(YM,AUF,POS,1))         ; Order Line
	
	SET RECHEE = +$$$INERECH1NetPurchasePrice(YFELD)               ; D13 Total Purchase Price
	;IF RECHEE'>0 QUIT                                              ; Quit if Credit Note
	IF RECHEE<0 QUIT                                                ; Quit if Credit Note   ; SR16363
	;---------------------------------------
	; FIXME : Exit here will not set MENGE1 for use in PRUEF <GRF>
	;         What if we are recording free goods?
	;---------------------------------------
	
	;-------------------------------------------------------------------------------
	;  Step 1 : Calculate Quantity (MENGE1)
	;-------------------------------------------------------------------------------
	
	SET MENGE1 = +$$$INERECH1InvoiceQuantity(YFELD)                ; D16
	SET FACTOR = +$$$INAUFPKConversionFactorQuantity(objINAUFPK)   ; D41
	
	// We shouldn't be going through here if zero qty in 3WM
	
	IF +MENGE1=0 {
		IF FACTOR'=0 {
			SET MENGE1=$$$INAUFPKPurchaseQuantity(objINAUFPK)      ; D16   Order (Purchase) Quantity
		}
	}
	
	IF +MENGE1=0 {
		IF $$$INAUFPKDeliveryQuantityFullLot(objINAUFPK)'="" {         ; Quantity Unit
			IF $$$INAUFPKDeliveryQuantityFullLot(objINAUFPK)'=$$$INAUFPQuantityUnit(objINAUFP) { ; Supplier vs Order UOM
				SET MENGE1 = $$$INAUFPKPurchaseQuantity(objINAUFPK)    ; Order (Purchase) Quantity ;FIS;23.07.04;26142
				
				; Fix (JW) This WAS referencing p16 of INAUFP (width) instead of INAUFPK (qty) - using ^(1)
			}
		}
	}
	IF +MENGE1=0 SET MENGE1=MENGE ; MENGE is Order (INAUFP) Quantity
	
	;-------------------------------------------------------------------------------
	;  Step 2 : Calculate Unit Price (RECHEP)
	;-------------------------------------------------------------------------------
	
	;SET MENGEG=$PIECE($GET(^INAUFPK(YM,AUF,POS,1)),Y,16) ;MENGE BEI LIEFERANT
	;IF +MENGEG=0 SET MENGEG=MENGE ;table-mat 
	;IF MENGE1=MENGEG IF MENGE'=0 SET RECHEP=$JUSTIFY(RECHEE/MENGE,0,2)  ;EINZEL-EK
	;IF MENGE1'=MENGEG DO3
	
	IF MENGE1'=0 {
		IF FACTOR'=0 {
			SET RECHEP = $JUSTIFY(RECHEE/(MENGE1/FACTOR),0,6)
			
		} else {
			SET RECHEP = $JUSTIFY(RECHEE/MENGE1,0,6)  ;Unit Price (Total / Qty)
		}
	}
	
	SET ART = $$$INAUFPItemNumber(objINAUFP)
	IF ART'="" {
	;	FIXME : Probably should not bother with the test since if unit-based multiplier
	;	        is used instead (not currently available), it will not be used. <GRF>
		IF $$$INARTPriceUnit($GET(^INART(YM,ART,1)))>1 {    ; If not sold in sales unit (eg 1/10/100/1000)
			SET RECHEP = RECHEP*$$^INQTYUNIT(ART)           ; then multiply
		}
	}
	SET RECHEP = $JUSTIFY(RECHEP,0,2)
	quit
	
	
SERV
	/*------------------------------------------------------------------------------
	; 
	; Called by:
	;	"Before Button Line" in form INERECH1
	; 
	; Params:
	;	YKEY
	;	YFELD
	;	
	; ByRefs:
	;	YVOR
	;	
	; Returns: Nothing
	; 
	; History:
	; 24-Jun-2009	GRF		Key & Authorisation macros
	;------------------------------------------------------------------------------*/
	quit:$GET(YKEY)=""
	quit:$GET(YFELD)=""
	
	IF $TRANSLATE($PIECE(YFELD,Y,80)," ")'="" DO
	. quit:$PIECE($$$KEY4(YKEY),"#",2)'=$PIECE(YFELD,Y,80)
	. set $$$WWW120AuthorizationToModifyData(YVOR) = $$$EnumReadOnly   ; READONLY BEI SERVICEKOSTENRECHNUNG
	
	quit
	
]]></Routine>
</Export>