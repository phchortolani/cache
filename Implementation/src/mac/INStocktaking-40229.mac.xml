<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="CACHE" ts="2001-01-01 00:00:00">
<Routine name="INStocktaking" type="MAC" languagemode="0" timestamp="58440,0"><![CDATA[
INStocktaking
	;###############################################################################
	;  
	;  TREAT MUCH OF THIS CODE AS WORK IN PROGRESS AS THERE ARE INSTANCES
	;  WHERE THE CODE APPEARS TO ONLY BE PARTIALLY COMPLETED OR FLAWED
	;  
	;###############################################################################	
#include COMSYS
#include INConst
		
	; New routines for stocktaking
	; Unit tests for these routines are in INStocktakingUT
 	;
 	; History
 	; 02-Dec-2010	shobby	SRBR014970: Removed some developer code.
 	; 03-Nov-2010	shobby	SR17599: Removed checkup (INARTHIST deprecated)
 
 
 
 
 
	; Access Routines
	; ===============	
GetStocktake(pidStocktake)
	;-------------------------------------------------------------------------------
	; get a stocktake from the database
	;	
	; Params: pidStocktake, the stocktake id
	;
	; Returns: the stocktake object (record from INWEINVP)
	;
	; History:
	; 05-Nov-2007	PJones	BR014730, get a stocktake
	;-------------------------------------------------------------------------------
	new objStocktake
	
	if '$data(YM) do ^WWWVAR
	set objStocktake = $get(^INWEINVP(YM,pidStocktake,1))
	quit objStocktake
	
GetStocktakeLine(pidStocktake, pidLine)
	;-------------------------------------------------------------------------------
	; get a stocktake line from the database (line from the snapshot)
	;	
	; Params: 
	;	pidStocktake, the stocktake id
	;	pidLine, the line in the stocktake snapshot
	;
	; Returns: the stocktake line object (record from INWEINV)
	;
	; History:
	; 05-Nov-2007	PJones	BR014730, get a stocktake line from the database
	;-------------------------------------------------------------------------------
	if '$data(YM) do ^WWWVAR
	quit $get(^INWEINV(YM,pidStocktake,pidLine,1))
	
	
GetCount(pidStocktake,pidLine,pidCount)
	;-------------------------------------------------------------------------------
	;
	; get a stocktake count from the database (record from INWEINVCount)
	;	
	; Params: 
	;	pidStocktake, the stocktake id
	;	pidLine, the line in the stocktake snapshot
	;	pidCount, the count number we're getting
	;
	; Returns: the stocktake count object (record from INWEINVCount)
	;
	; History:
	; 05-Nov-2007	PJones	BR014730, get a stocktake count from the database
	;-------------------------------------------------------------------------------
	if '$data(YM) { do ^WWWVAR }
	quit $$GetCount^INWEINVCount(pidStocktake,pidLine,pidCount)
	
	
SaveStocktake(pidStocktake, objStocktake)
	;-------------------------------------------------------------------------------
	; save a stocktake object back into the database
	;	
	; Params: 
	;	pidStocktake, the stocktake id
	;	objStocktake, the INWEINVP record
	;	
	; Returns: a status from $$$Save
	;
	; History:
	; 08-Nov-2007	PJones	save a stocktake to the database
	;-------------------------------------------------------------------------------
	quit $$$Save("INWEINVP",pidStocktake,objStocktake,$$$YES)
	
	
StartIterator(&line)
	;-------------------------------------------------------------------------------
	; First of a pair of iterator routines. Use with NextLine below
	;	
	; Params: 
	;	BYREF : line, will be the line index this iterator counts through
	;	
	; History:
	; 22-Jul-2008	PJones	iteration through stocktake lines
	;-------------------------------------------------------------------------------
	set line = 0
	quit
	
	
NextLine(pidStocktake,&line,&obj)
	;-------------------------------------------------------------------------------
	; Second of a pair of iterator routines. Updates and returns 
	; the line index and object value 
	;	
	; Params: 
	;	BYREF : line, will be the line index this iterator counts through
	;	BYREF : obj,
	;	
	; Returns: boolean - Line found
	;
	; History:
	; 18-Mar-2010	GRF		use blnResult
	; 22-Jul-2008	PJones	iteration through stocktake lines
	;-------------------------------------------------------------------------------
	new blnResult
	
	set blnResult = $$$NO
	set line = $order(^INWEINV(YM,pidStocktake,line))
	if line'="" {
		set obj = $$GetStocktakeLine(pidStocktake,line)
		set blnResult = $$$YES
	}
	quit blnResult
	
	
MakeLine(pidItem,pidLocn,pidStore,pdteReceived,pfltTarget,pfltCounted)  
	;-------------------------------------------------------------------------------
	; Make a stocktake line
	;	
	; Params: 
	;	pidItem			item id
	;	pidLocn			location
	;	pidStore		storage
	;	pdteReceived	date received 
	;	pfltTarget		snapped quantity
	;	pfltCounted		current counted quantity
	;
	; Returns: a new INWEINV object
	;
	; History:
	; 14-Oct-2008	GRF		SR15810: Variable prefixes & naming
	; 23-Nov-2007	PJones	created
	;-------------------------------------------------------------------------------
	new objLine
	
	set objLine = ""
	set $$$INWEINVActualQuantity(objLine)   = pfltCounted
	set $$$INWEINVTargetQuantity(objLine)   = pfltTarget
	set $$$INWEINVItemNumber(objLine)       = pidItem
	set $$$INWEINVLocation(objLine)         = pidLocn
	set $$$INWEINVStockLocation(objLine)    = pidStore
	set $$$INWEINVGoodsReceiptDate(objLine) = pdteReceived
 
	quit objLine
 
 
SaveLine(pidStocktake,pidLine,objINWEINV)
	;-------------------------------------------------------------------------------
	; save a stocktake-line object back into the database
	;	
	; Params: 
	;	pidStocktake, the stocktake id
	;	pidLine, the line in the stocktake snapshot
	;	objINWEINV, the line object (record)
	;
	; Returns: a status from $$$Save
	;
	; History:
	; 14-Oct-2008	GRF		SR15810: extra quotes in key are not necessary
	; 05-Nov-2007	PJones	BR014730, get a stocktake count from the database
	;-------------------------------------------------------------------------------
	new strKeys,strStatus
	
	set strKeys   = pidStocktake_$$$COMMA_pidLine
	set strStatus = $$$Save("INWEINV",strKeys,objINWEINV,$$$YES)
	quit strStatus
 
 
	; Properties
	; ===============	
	
 
GetItemGroupList(pidStocktake) 
	new objStocktake
	
	set objStocktake = $$GetStocktake(pidStocktake)
	quit $$$INWEINVPItemGroup(objStocktake)
 
GetSiteList(pidStocktake) 
	quit $$$INWEINVPSiteLocation($$GetStocktake(pidStocktake))
 
 
GetIncomingPostedDifference(pidStocktake,pidLine)
	new qty
	
	set qty = $$$INWEINVPostedDifferenceQty($$GetStocktakeLine(pidStocktake,pidLine))
	if qty > 0 { 
		quit qty
	}
	quit 0
	
GetOutgoingPostedDifference(pidStocktake,pidLine)
	new qty
	
	; FIXME : Is it REALLY appropriate to lose the direction of the difference?
	;         - This may be correct depending on how the value is used.
	
	set qty = $$$INWEINVPostedDifferenceQty($$GetStocktakeLine(pidStocktake,pidLine))
	if qty < 0 { 
		quit -qty
	}
	quit 0
 
	
IsConsolidatedObj(pidStocktake) 
	new blnResult,objStocktake
	
	set objStocktake = $$GetStocktake(pidStocktake)
	if $$$INWEINVPConsolidateReceiptDates(objStocktake) {
		set blnResult= $$$YES
	} else {
		set blnResult = $$$NO
	}
	quit blnResult
 
ItemGroupCheckById(pidItem,pstrGroups)
	;-------------------------------------------------------------------------------
	; Checks if the group of the item refered in the stocktake line is within the list 
	; of groups defined for the stocktake
	;
	; Params: idItem, the item number of an item
	;		  pstrGroups, a semi-colon separated list of item groups
	;
	; Returns: returns $$$OK if the itemGroup of the objItem is in the list pstrGroups
	;
	; History:
	; 14-Jan-2008	PJones	Created, to support test in callback to INART for INWEINVELine 
	;-------------------------------------------------------------------------------
	new objItem,strStatus
	
	set strStatus = $$ValidItem^INART(pidItem)
	if $$$ISOK(strStatus) {
		set objItem   = $$GetItem^INART(pidItem)
		set strStatus = $$ItemGroupCheck(objItem,pstrGroups,pidItem)
	}
	quit strStatus
	
	
ItemGroupCheck(pobjItem,pstrGroups,pidItem)
	;-------------------------------------------------------------------------------
	; Checks if the group of the item refered in the stocktake line is within the 
	; list of groups
	;
	; Params: objLine, the object containing the stocktake line
	;		  pstrGroups, a semi-colon separated list of item groups
	;		  pidItem, item id used for error reporting
	;
	; Returns: returns $$$OK if the itemGroup of the objItem is in the list pstrGroups
	;
	; History:
	; 13-Feb-2008	PJones	Changed default behaviour, if there's no group, accept it
	; 21-Jan-2008	GRF		Added text as comment
	; 20-Dec-2007	PJones	Created
	;-------------------------------------------------------------------------------
	new itemGroup,strStatus
 
	set strStatus = $$$OK
	set itemGroup= $$$INARTItemGroup(pobjItem)
	
	; FIXME : If an Item has no group it uses the Default Group defined in INVORG General Parameters
	
	if itemGroup = "" {
		; behaviour changed 
		set strStatus = $$$OK ; keep it OK if item doesn't have a group	
		;set strStatus = $$$MakeStatus("IN00830",pidItem)
		; FIXME : this assumes that we *won't* match an item who's group-id field is empty 
		; with the list, *even* if the list is empty.
		; Is this the behaviour we want?
	} 
	if $$$ISOK(strStatus) {
		if $get(pstrGroups) '= "" {
			; there are restrictions by group, so we want to fail if 
			; we can't find the item's group in our list of groups 
			;SR14681: Group limiter // SR14857
			
			if '($find(";"_pstrGroups_";",";"_itemGroup_";")) {
				set strStatus = $$$MakeStatus("IN00812",itemGroup)
			;	The Item Group (%1) was not specified as part of this stocktake (when the stocktake was created)
			}
		}
	}	
	quit strStatus
 
 
SiteCheck(pidSite,pstrSiteLocations)
	;-------------------------------------------------------------------------------
	; Checks if the site is within a list of site locations 
	; 
	; Params: pidSite, a site
	;		  pstrSiteLocations, a comma separated list of site locations
	;
	; Returns: the "true" if the stocktake line's site is one of the items in the list
	;
	; History:
	; 14-Jan-2008	PJones	Refactored out of LineSiteCheck
	;-------------------------------------------------------------------------------
	new strStatus, strSiteLocations
	
	set strStatus = $$$OK
	
	set strSiteLocations = $translate(pstrSiteLocations,",",";")
	;set strSiteLocations = pstrSiteLocations
	if (pidSite = "") {
		set strStatus = 0_"Site Location is blank"    ; FIXME : WWW009 text required
	
	} elseif '($find(";"_strSiteLocations_";",";"_pidSite_";")) {
		set strStatus = 0_"Site location wasn't specified as part of this stocktake : "_pidSite_ " :: "_strSiteLocations
	}
	quit strStatus
 
 
LineSiteCheck(objLine,pstrSiteLocations)
	;-------------------------------------------------------------------------------
	; Checks if the site refered in the stocktake line is within the list 
	; of site locations defined for the stocktake
	;
	; Params: objLine, the object containing the stocktake line
	;		  pstrSiteLocations, a comma separated list of site locations
	;
	; Returns: the "true" if the stocktake line's site is one of the items in the list
	;
	; History:
	; 20-Dec-2007	PJones	Created
	;-------------------------------------------------------------------------------
	new idSiteLocation
	
	set idSiteLocation = $$$INWEINVLocation(objLine)
	quit $$SiteCheck(idSiteLocation,pstrSiteLocations)
 
 
StorageRangeCheck(pidStorage,pidBinFrom,pidBinTo) 
	;-------------------------------------------------------------------------------
	; Checks if the storage of the item refered in the stocktake line is within the 
	; range of storages (aka bins, aka stock-locations) defined for the stocktake
	;
	; Params: pidStorage, the storage id
	;		  pidBinFrom, the first storage in the range
	;		  pidBinTo, the last storage in the range
	;
	; Returns: $$$OK if the storage is in the range, otherwise $$$NO
	;
	; History:
	; 15-Oct-2008	GRF		SR15810: revised message
	; 15-Jan-2007	PJones	Broken out from StorageCheckById we don't need idSite 
	;				call this one.
	;-------------------------------------------------------------------------------
	; check storage is in the range
	; FIXME : someone should look at this to see if it makes sense to 
	; treat ranges of storage locations as something that the ] operator can test for?
	; originally SR14681: Stock location limiter
 
	new strStatus
	
	set strStatus = $$$OK	
	
	; "The storage for this line (%1) does not match the stocktake requirements."
	if (pidBinFrom '= "") && (pidBinFrom ] pidStorage) {   ; FIXME : Should consider ]] rather than ]
		set strStatus = $$$MakeStatus("IN00809",pidStorage)
		
	} elseif (pidBinTo '= "") && (pidStorage ] pidBinTo) {
		set strStatus = $$$MakeStatus("IN00809",pidStorage)
	}
	quit strStatus
	
	
StorageCheckById(pidSite,pidStorage,pidBinFrom,pidBinTo)
	;-------------------------------------------------------------------------------
	; Checks if the storage exists and is within range defined by stocktake
	;
	; Params: pidSite, the site id
	;		  pidStorage, the storage id
	;		  pidBinFrom, the first storage in the range
	;		  pidBinTo, the last storage in the range
	;
	; Returns: $$$OK if the storage is in the range, otherwise $$$NO
	;
	; History:
	; 25-Sep-2008	GRF		SR15932: Storage text
	; 15-Jan-2007	PJones	Some refactoring into StorageRangeCheck 
	; 14-Jan-2007	PJones	Broken out from StorageCheck
	;-------------------------------------------------------------------------------
	new strStatus
	
	set strStatus = $$$OK
	
	; check storage exists
	
	if pidStorage="" {
		set strStatus = $$$MakeStatus("IN00813")        ; "No storage given"
		
	} elseif '$data(^INLP(YM, pidSite, pidStorage,1)) { ; "Storage (%1) is blank or not recognised for this location (%2)"
		set strStatus = $$$MakeStatus("IN00811",pidStorage,pidSite)
	}
	if $$$ISOK(strStatus) {
		set strStatus = $$StorageRangeCheck(pidStorage,pidBinFrom,pidBinTo)
	}
	quit strStatus
 
StorageCheck(pobjLine,pidBinFrom,pidBinTo)
	;-------------------------------------------------------------------------------
	; Checks if the storage of the item refered in the stocktake line is within the 
	; range of storages (aka bins, aka stock-locations) defined for the stocktake
	;
	; Params: pobjLine		the object containing the stocktake line
	;		  pidBinFrom	the first storage in the range
	;		  pidBinTo		the last  storage in the range
	;
	; Returns: $$$OK if the storage is in the range, otherwise $$$NO
	;
	; History:
	; 8-Jan-2007	PJones	Moved to INStocktaking from INWEINRUECK
	; 20-Dec-2007	PJones	Created
	;-------------------------------------------------------------------------------
	new idStorage, strStatus, idSite
	
	set idStorage = $$$INWEINVStockLocation(pobjLine)
	set idSite    = $$$INWEINVLocation(pobjLine)
	
	quit $$StorageCheckById(idSite,idStorage,pidBinFrom,pidBinTo)
 
 
LineFallsWithinStocktake(pobjLine,pobjStocktake) 
	;-------------------------------------------------------------------------------
	; Returns : $$$OK if the line falls within the bounds defined for this stocktake
	; (particularly, the item is of the right item group and the storage location 
	; is within the range of "bins" defined for this stocktake)
	; 
	; Params: 
	;	objLine, the stocktake line (ie. record from INWEINV)
	;	objStocktake, the stocktake object (record from INWEINVP)
	;	
	;
	; History:
	; 14-Oct-2008	GRF		SR15810: item group not required; prefixes
	; 14-Jan-2007	PJones	Refactored here from INWEINRUECK
	; 05-Nov-2007	PJones	BR014730, created
	;-------------------------------------------------------------------------------
	new idItem,objItem,strStatus
	
	set strStatus = $$$OK
	set idItem    = $$$INWEINVItemNumber(pobjLine)
	set strStatus = $$ValidItem^INART(idItem)
	
	if $$$ISOK(strStatus) {
		set objItem = $$GetItem^INART(idItem)
		set strStatus = $$ItemGroupCheck(objItem,$$$INWEINVPItemGroup(pobjStocktake))
	}
	if $$$ISOK(strStatus) {
		set strStatus = $$LineSiteCheck(pobjLine,$$$INWEINVPSiteLocation(pobjStocktake))	
	}
	if $$$ISOK(strStatus) {
		set strStatus = $$StorageCheck(pobjLine,$$$INWEINVPFromStockLocation(pobjStocktake),$$$INWEINVPToStockLocation(pobjStocktake))
	}
	quit strStatus
 
	; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	; Testing for creating, editing, closing, counts
 
	
CanCloseCount(pidStocktake,pidCount="")  ; SEE INStocktakeCount SR15810
	;-------------------------------------------------------------------------------
	; Returns : $$$OK if we can close a particular count for this stocktake
	; 
	; Note : you can only close a count if *all* INWEINVCounts have 
	; had some value entered into them and you are in a CountOpen status
	;	
	; Params: 
	;	pidStocktake, the stocktake id
	;	pidCount, which count number do we want to close?
	;
	; History:
	; 05-Nov-2007	PJones	SRBR014730: created (also SRBR014771)
	;-------------------------------------------------------------------------------
	new strStatus, idLine, idCount,objCount, objStocktake, objLine
	
	if pidCount = "" {
		; if count arg is not given or empty, we'll use the latest
		set objStocktake = $$GetStocktake(pidStocktake)
		set pidCount = $$$INWEINVPNumberofCounts(objStocktake)
	}
	
	set strStatus = $$IsCountOpen^INWEINVPStatus(pidStocktake)
	
	if $$$ISOK(strStatus) {
		set idLine = ""
		for {
			set idLine = $order(^INWEINV(YM,pidStocktake,idLine))
			quit:idLine=""
			
			set objCount = $$GetCount(pidStocktake,idLine,pidCount)
			if objCount '= "" {
				set objLine = $$GetStocktakeLine(pidStocktake,idLine)
				if ($$$INWEINVCountQuantity(objCount) = "") && ($$$INWEINVStockType(objLine) '= "R") {
					set strStatus = $$$MakeStatus("IN00789",idLine)
	;	"You can't close the count because some items have not been counted. Check the snapshot line %1"
				}
			}
		}
	}
	
	quit strStatus
	
CloseCount(pidStocktake,pidCount="")  ; SEE INStocktakeCount SR15810
	;-------------------------------------------------------------------------------
	; Close the current (or pidCount) count for the stocktake pidStocktake and put into 
	; a CountComplete status. Can only be closed if $$canCloseCount is true.
	; 
	; Params: 
	;	pidStocktake, the stocktake id
	;	pidCount, which count number do we want to close?
	;
	; Returns: a status which $$$ISOK if we can close the count
	;
	; History:
	; 05-Nov-2007	PJones	SRBR014730: created (also SRBR014771)
	;-------------------------------------------------------------------------------
	new strStatus, objStocktake
	
	if pidCount = "" {
		; if count arg is not given or empty, we'll use the latest
		set objStocktake = $$GetStocktake(pidStocktake)
		set pidCount = $$$INWEINVPNumberofCounts(objStocktake)
	}
	set strStatus = $$CanCloseCount(pidStocktake,pidCount)
	if $$$ISOK(strStatus) {
		set strStatus = $$SetCountComplete^INWEINVPStatus(pidStocktake)
	}
	quit strStatus
	
CloseCountButtonHandler(pidStocktake)  ; SEE INStocktakeCount SR15810
	;-------------------------------------------------------------------------------
	; The "close count" button on INWEINVD should call this routine, 
	; it will call the main close function and then follow through to the next form
	; 
	; This routine exists to separate the user-interface action from the model logic
	; and could be over-ridden if necessary
	; 
	; Params: 
	;	pidStocktake, the stocktake id
	;
	; Returns: the status from trying to close the count
	;
	; History:
	; 21-Jan-2008	GRF		Added missing SR details below
	; 13-Nov-2007	shobby	SRBR014557: Redirect to the same form with the key loaded.
	; 09-Nov-2007	PJones	SRBR014771: created
	;-------------------------------------------------------------------------------
	new strStatus,intMaxCounts
	
	set intMaxCounts = $$$INVORGStocktakeMaxCount($$Get^INVORG())
	set strStatus    = $$CanCloseCount(pidStocktake,intMaxCounts) 
	if $$$ISOK(strStatus) {
		set strStatus = $$CloseCount(pidStocktake)
	} else {
		$$$Alert(strStatus)
		$$$YQHandler(strStatus)
	}
	;do ReloadForm^COMUtilForm()
	do RedirectForm^COMUtilForm(YFORM,$get(VORG(1)),YBACK,YPARA,YSEITE)
	quit strStatus
	
	
CanEditCount(pidStocktake) 
	;-------------------------------------------------------------------------------
	; Returns $$$OK if you can edit a count 
	; (essentially, if the stocktake is in CountOpen status)
	;	
	; Params: 
	;	pidStocktake, the stocktake id
	;
	; History:
	; 21-Jan-2008	GRF		Added missing SR details below
	; 10-Dec-2007	GRF		SRBR014557: Corrected tag name - updated in INWEINVPStatus
	;							but not here
	; 07-Nov-2007	PJones	SRBR014771: Created
	;-------------------------------------------------------------------------------
	if (+$$$WWWClientParamCoreChangesHEVA($get(^WWWClientParam(YM,YM,1)))) {
		if (($$$INWEINVPFREE1($get(^INWEINVP(YM,pidStocktake,1))) = 1) &&
			($$$INWEINVPStatus($get(^INWEINVP(YM,pidStocktake,1))) = 2)){
			quit $$$MakeStatus("INWEINVD001")
		}			
	}
	quit $$IsCountOpen^INWEINVPStatus(pidStocktake)
	
	
CanCreateNewCount(pidStocktake,pintMaxCounts=0)
	;-------------------------------------------------------------------------------
	; Returns $$$OK if you can create a new count
	; (essentially, if the stocktake is in CountComplete status)
	; 
	; This is tested when creating a new count 
	; (transition between status Started or CountComplete)
	;	
	; Params: 
	;	pidStocktake, the stocktake id
	;
	; History:
	; 14-Oct-2008	GRF		SR15810: Language text
	; 07-Nov-2007	shobby	SRBR014764: Pass MaxCount and MinCount as parameters.
	; 05-Nov-2007	shobby	SRBR014764: Test that we are not exceeding maximum counts. 
	; 05-Nov-2007	PJones	SRBR014730: created (also SRBR014771)
	;-------------------------------------------------------------------------------
	new strStatus,objINWEINVP
	
	if pidStocktake'="" {
		set objINWEINVP=$$GetStocktake(pidStocktake)
		if $$IsCountOpen^INWEINVPStatus(pidStocktake) {
		; "Can not open a new count while the previous count is still open."
		;	set strStatus = 0_"Não é possível abrir uma nova contagem pois já existe uma contagem aberta."
			set strStatus = $$$MakeStatus("IN00772")
		
		} elseif $$IsCountProcessClosed^INWEINVPStatus(pidStocktake) {
		; "Can not open a new count once the counting process has been closed."
		;	set strStatus = 0_"Não é possível abrir uma nova contagem pois as contagens já foram encerradas."
			set strStatus = $$$MakeStatus("IN00771")
		
		} elseif $$IsStocktakeComplete^INWEINVPStatus(pidStocktake) {
		; "Stocktake is already completed." / "Esse inventário já foi completado."
		;	set strStatus = 0_"Não é possível abrir uma nova contagem pois este inventário já foi completado."
			set strStatus = $$$MakeStatus("IN00775")
		
		} elseif '$$IsCountCompleteObj^INWEINVPStatus(objINWEINVP) {
			set strStatus = $$$MakeStatus("IN00779") ; "It was not possible to create a new count due to wrong status."
		
		} elseif ($$$INWEINVPNumberofCounts(objINWEINVP)'<pintMaxCounts)&&(+pintMaxCounts>0) {
			set strStatus = $$$MakeStatus("IN00790",pintMaxCounts)  ; "Can't create more counts.  Maximum allowed is %1."
		
		} else {
			set strStatus = $$$OK
		}
		
	} else {
	;	"It is not possible to create a new count because no stocktake number was given."
		set strStatus = $$$MakeStatus("IN00782")
	}
	
	$$$YQHandler(strStatus)
	quit strStatus
	
CreateNewCount(pidStocktake) 
	;-------------------------------------------------------------------------------
	; Creates a new count for a particular stocktake
	; 
	; Params: 
	;	pidStocktake, the stocktake id
	;
	; Returns: a status which $$$ISOK if we created a new count
	;
	; History:
	; 13-Dec-2007	shobby	BR014798: Call out to a routine to reset some values
	;							in INWEINV so they can be repopulated with default
	;							values at the start of a new count.
	; 14-Nov-2007	PJones	BR014770, changed to select between standard rules in INVORG
	; 05-Nov-2007	PJones	SRBR014730: created (also SRBR014771)
	;-------------------------------------------------------------------------------
	new strStatus, objStocktake, objINVORG
	
	set strStatus = $$$OK
	set objStocktake = $$GetStocktake(pidStocktake)
	
	if pidStocktake '= "" {
		set strStatus = $$CanCreateNewCount(pidStocktake)
		if $$$ISOK(strStatus) {
			set objINVORG = $$Get^INVORG()
			
			if ($$$INVORGStocktakeCountRule(objINVORG) = 3)     &&
			   ($$$INVORGVARStocktakeCountRule(objINVORG) '= "")  {
		; This let's us over-ride the standard rules with a VAR routine
		; currently this isn't available from the core UI (ie. INSTOCKTAKECOUNTRULE
		; doesn't have a "3" but could be made available via customization
		; Needs testing 
					xecute "set strStatus = $$"_$$$INVORGVARStocktakeCountRule(objINVORG)_"("_pidStocktake_")"
							
			} elseif $$$INVORGStocktakeCountRule(objINVORG) = 2 {
		; create a new count unless the last was equal to either SOH or an earlier count
				set strStatus = $$CreateRuleTwoCount^INWEINVCount(pidStocktake)
			
			} else {
		; default is rule 1, create new count unless last count was equal to Stock-on-hand
				set strStatus = $$CreateRuleOneCount^INWEINVCount(pidStocktake)
			}
			do SetCountOpen^INWEINVPStatus(pidStocktake)
			set strStatus = $$Reset(pidStocktake)
		}
	
	} else {
		set strStatus = $$$MakeStatus("IN00782")
	} ; "It is not possible to create a new count because no stocktake number was given."
	quit strStatus
	
	
Reset(pidStocktake)
	;-------------------------------------------------------------------------------
	; Routine to reset some values in INWEINV so that default values will be populated 
	; when starting the next count.
	;
	; Params:
	;
	; Returns:
	;
	; History:
	; 13-Dec-2007	shobby		SRBR014798: Created
	;-------------------------------------------------------------------------------
	new idLine,objINWEINV,strStatus
	
	set strStatus = $$$OK
	set idLine    = ""
	for {
		set idLine = $order(^INWEINV(YM,pidStocktake,idLine))
		quit:idLine=""
		
		set objINWEINV = $get(^INWEINV(YM,pidStocktake,idLine,1))
		set $$$INWEINVDifferenceAdjustment(objINWEINV) = ""
		set strStatus = $$$Save("INWEINV",pidStocktake_","_idLine,objINWEINV,$$$YES)
		quit:'$$$ISOK(strStatus)
	}
	quit strStatus
	
	
CreateNewCountButtonHandler(pidStocktake)
	;-------------------------------------------------------------------------------
	; The "create new count" button on INWEINVD should call this routine, 
	; it will call the main create new count function and then follow through to the next form
	; 
	; This routine exists to separate the user-interface action from the model logic
	; and could be over-ridden if necessary
	; 
	; Params: 
	;	pidStocktake, the stocktake id
	;
	; Returns: the status from trying to create a new count
	;
	; History:
	; 07-Nov-2007	shobby	SRBR014764: Determined value for MaxCount
	; 05-Nov-2007	PJones	SRBR014730: created (also SRBR014771)
	;-------------------------------------------------------------------------------
	new strStatus,intMaxCounts,YKEY
	
	set intMaxCounts=$$$INVORGStocktakeMaxCount($$Get^INVORG())
	
	set strStatus = $$CanCreateNewCount(pidStocktake,intMaxCounts) 
	if $$$ISOK(strStatus) {
		set strStatus = $$CreateNewCount(pidStocktake)
		;do RedirectForm^COMUtilForm("INWEINVEHeader",pidStocktake,YFORM_",",YPARA,YSEITE)
	} else {
		$$$Alert(strStatus)
		$$$YQHandler(strStatus)	
	}
	do ReloadForm^COMUtilForm()
	quit strStatus
	
CanCloseCounting(pidStocktake, pintMinCounts=0)
	;-------------------------------------------------------------------------------
	; Returns $$$OK if you can close counting
	; (essentially that we're in a CountComplete status and have at least our minimal number 
	; of counts if there are any differences )
	; 
	; Params: 
	;	pidStocktake	the stocktake id
	;	pintMinCounts	the minimum number of counts we're allowed to do if there's 
	;					a difference
	;
	; History:
	; 14-Oct-2008	GRF		SR15810: Language text
	; 05-Nov-2007	shobby	SRBR014764: Test if minimum number of counts have been done.
	; 05-Nov-2007	PJones	SRBR014730: created (also SRBR014771)
	;-------------------------------------------------------------------------------
	new strStatus,intMinCounts,objINWEINVP
	
	if pidStocktake'="" {
		set objINWEINVP=$$GetStocktake(pidStocktake)
 
		if $$IsStocktakeComplete^INWEINVPStatus(pidStocktake) {
		; "Stocktake is already completed." / "Esse inventário já foi completado."
		;    set strStatus = 0_"Não é possível encerrar as contagens pois esse inventário já foi completado."
			set strStatus = $$$MakeStatus("IN00775")
			
		} elseif $$IsCountProcessClosed^INWEINVPStatus(pidStocktake) {
		; "The counting process has already been closed."
		;	set strStatus = 0_"As contagens já foram encerradas."	
			set strStatus = $$$MakeStatus("IN00774")
 
		} elseif $$IsCountOpen^INWEINVPStatus(pidStocktake) {
		; "All counts must be closed before the counting process can be closed."
		;	set strStatus = 0_"Não é possível encerrar o processo de contagem pois existe uma contagem aberta."	
			set strStatus = $$$MakeStatus("IN00773")
 
		} elseif ($$$INWEINVPNumberofCounts(objINWEINVP)<pintMinCounts)&&(+pintMinCounts>0) {
		;	"Can't close counting.  Minimum counts that must be performed is %1."
			set strStatus = $$$MakeStatus("IN00791",pintMinCounts)
		} else {
			set strStatus = $$$OK
		}
	} else {
	; "It is not possible to close the count because no stocktake was loaded."
		set strStatus = $$$MakeStatus("IN00781")
	}
		
	$$$YQHandler(strStatus)
	quit strStatus
	
CloseCountingButtonHandler(pidStocktake)
	;-------------------------------------------------------------------------------
	; The "close counting" button on INWEINVD should call this routine, 
	; it will call the main close counting function and then follow through to the next form
	; 
	; This routine exists to separate the user-interface action from the model logic
	; and could be over-ridden if necessary
	; 
	; Params: 
	;	pidStocktake, the stocktake id
	;
	; Returns: the status from trying to close counting
	;
	; History:
	; 05-Nov-2007	shobby	SRBR014764: Validation check should have been to canCloseCounting.
	; 05-Nov-2007	PJones	SRBR014730: created (also SRBR014771)
	;-------------------------------------------------------------------------------
	new strStatus, intMinCounts
	
	set intMinCounts = $$$INVORGStocktakeMinCount($$Get^INVORG())
	set strStatus = $$CanCloseCounting(pidStocktake,intMinCounts) 
	
	if $$$ISOK(strStatus) {
		set strStatus = $$CloseCounting(pidStocktake)
	} else {
		$$$Alert(strStatus)
		$$$YQHandler(strStatus)	
	}
 
	do ReloadForm^COMUtilForm()
	quit strStatus
	
	
CloseOneLine(pidStocktake,pidLine) 
	;-------------------------------------------------------------------------------
	; Closes counting for one line of a stocktake snapshot
	; when we close a line, we're making sure all the fields in INWEINV
	; have got up-to-date information about the *last* count for that line
	; and any dependent calculations for this line are also up-to-date
	; 
	; Params: 
	;	pidStocktake, the stocktake id
	;	pidLine, the line id
	;
	; Returns: a status which $$$ISOK if we managed to update and save the line
	;
	; History:
	; 05-Nov-2007	PJones	SRBR014730: created (also SRBR014771)
	;-------------------------------------------------------------------------------
	new objLine,strStatus
	
	set objLine = $$GetINWEINVwithLatestCount^INWEINVCount(pidStocktake,pidLine)
	;set $$$INWEINVFinalQuantityAdjusted(objLine) = $$$INWEINVActualQuantity(objLine)
	set $$$INWEINVCalculatedDifferenceQty(objLine) = $$AdjustedDifference(
																	$$$INWEINVActualQuantity(objLine),
																	$$$INWEINVTargetQuantity(objLine),
																	0)
	set strStatus = $$SaveLine(pidStocktake,pidLine,objLine)
	quit strStatus
 
 
CanAdjustHandler(pidStocktake) 
	;-------------------------------------------------------------------------------
	; 
	; Params:
	;
	; Returns:
	;
	; History:
	; 14-Oct-2008	GRF		SR15810: Language text exists
	; 23-Apr-2008	PJones	We need to restrict the manager's view (adjust) button
	;							to only being accessible AFTER the counting process
	;							has closed but this no longer is the same as 
	;							"CanPost" because CanPost also takes into account
	;							the earliest post date, and this doesn't.
	;							This is for testing that we're in the right status
	;							but without using CanPost
	; 21-Jan-2008	GRF		Added missing SR details below
	; 07-Jan-2008	PJones	SRBR014866: Created (broken out of CanPost so we can 
	;							keep unit-testing the model parts of the CanPost
	;							test. This now handles only the stuff which needs
	;							to be tested in the context of a form (ie. RecallField)
	;-------------------------------------------------------------------------------
	new strStatus
	
	set strStatus = $$$OK
	if $$RecallField^WWWRECALL(YBED,YFORM,"M",13)="" {
		; Was } elseif ($get(%("%KEY","YINWEINVDM13"))="")&&($piece($get(FMFELD),Y,13)="") {
		; Reason code.
		; Note: Criticism regarding the appropriateness of this line will only be accepted
		;       with working examples of 'the better way'.
		set strStatus=$$$MakeStatus("IN00489")   ; "A reason code is required to adjust stock"
		
	} else {
]]><![CDATA[		set strStatus = $$CanAdjust(pidStocktake)
	}
	quit strStatus
	
	
CanAdjust(pidStocktake)
	;-------------------------------------------------------------------------------
	; 
	; Params:
	;
	; Returns:
	;
	; History:
	; 23-Apr-2008	PJones	We need to restrict the manager's view (adjust) button
	;							to only being accessible AFTER the counting process
	;							has closed but this no longer is the same as 
	;							"CanPost" because CanPost also takes into account
	;							the earliest post date, and this doesn't.
	;							This is for testing that we're in the right status
	;							but without using CanPost.
	; 21-Jan-2008	GRF		Added missing SR details below
	; 07-Jan-2008	PJones	SRBR014866: Move ReasonCode test out to CanPostHandler
	;							so we can still unit test this
	; 07-Jan-2008	shobby	SRBR014866: Get the value of 'Reason Code' from WWWRECALL
	; 03-Jan-2008	shobby	SRBR014827: Disable the post button if no reason code selected.
	; 16-Nov-2007	shobby	SRBR014741: Upgraded error message IN00783 to provide
	;							more information
	;-------------------------------------------------------------------------------
	new strStatus,strRequiredStatus
	
	set strStatus = $$$OK
 
	if pidStocktake'="" {
		if $$IsStocktakeComplete^INWEINVPStatus(pidStocktake,.strRequiredStatus) {
			set strStatus=$$$MakeStatus("IN00486")
		;	"Cannot update stock, as stocktake has already been completed."
		;	FIXME - other message here
			
		} elseif '($$IsCountProcessClosed^INWEINVPStatus(pidStocktake,.strRequiredStatus)) {
			set strStatus=$$$MakeStatus("IN00783",strRequiredStatus) ; FIXME other message here
	; "It is not possible to post the stocktake because the counting process has not finished. The stocktake must be in a status of '%1' to be posted."
		}
	} else {
		set strStatus=$$$MakeStatus("IN00784")
	;	"It is not possible to post the stocktake because no stocktake has been loaded."
	}
	$$$YQHandler(strStatus)
	quit strStatus
 
	
CloseCounting(pidStocktake)
	;-------------------------------------------------------------------------------
	; This routine moves the counting finished status
	;
	; Params:
	;
	; Returns:
	;
	; History:
	; 24-Oct-2008	GRF		Restored unlocking
	; 19-Apr-2008	PJones	Commented Unlocking because we're only going to unlock
	; 							when we do do conciliation for SES
	; 09-Nov-2007	shobby	SRBR014781 Use type and reference when unlocking a
	;							Site Location
	; 21-Jan-2008	GRF		Added missing SR details below
	; 07-Nov-2007	PJones	SRBR014771: Created
	;-------------------------------------------------------------------------------
	new strLocations,strStatus
	
	set strStatus = $$SetCountProcessClosed^INWEINVPStatus(pidStocktake)
	
	;  vvv  19-Apr-2008 commented   24-Oct-2008 reverted comment
	if $$$ISOK(strStatus) {    ; unlock any locked locations
		set strLocations = $$$INWEINVPSiteLocation($$GetStocktake(pidStocktake))
		do UnlockSiteLocationList^INLocking(strLocations,$$$EnumINLOCKTYPEStocktake,pidStocktake) ;BR014781
	}
	; ^^^
	quit strStatus
	
	
CanPostHandler(pidStocktake) 
	;-------------------------------------------------------------------------------
	; 
	; Params:
	;
	; Returns:
	;
	; History:
	; 14-Oct-2008	GRF		SR15810: Language text exists
	; 24-Sep-2008	GRF		SR15810: Form Specific - use variable strReasonCode
	; 21-Jan-2008	GRF		Added missing SR details below
	; 07-Jan-2008	PJones	SRBR014866: Created (broken out of CanPost so we can 
	;							keep unit-testing the model parts of the CanPost
	;							test. This now handles only the stuff which needs
	;							to be tested in the context of a form (ie. RecallField)
	;-------------------------------------------------------------------------------
	new strReasonCode,strStatus
	
	; SRBR014866
	; Was } elseif ($get(%("%KEY","YINWEINVDM13"))="")&&($piece($get(FMFELD),Y,13)="") {
	; Reason code.
	; Note: Criticism regarding the appropriateness of this line will only be accepted
	;       with working examples of 'the better way'.
	
	set strStatus = $$$OK
	; vvv SR15810
	;if $$RecallField^WWWRECALL(YBED,YFORM,"M",13)="" {
	set strReasonCode = ""
	if YFORM = "INWEINVD" set strReasonCode = $$RecallField^WWWRECALL(YBED,YFORM,"M",13)
	if strReasonCode="" {
	; ^^^	
		set strStatus=$$$MakeStatus("IN00489") ; "A reason code is required to adjust stock"
	} else {
		set strStatus = $$CanPost(pidStocktake)
	}
	quit strStatus
	
	
CanPost(pidStocktake)
	;-------------------------------------------------------------------------------
	; 
	; Params:
	;
	; Returns:
	;
	; History:
	; 24-Sep-2008	GRF		SR15810: Corrected error codes; add new entry for
	;							hard-coded text; locale date format not $zdate
	; 21-Jan-2008	GRF		Added missing SR details below
	; 07-Jan-2008	PJones	SRBR014866: Move ReasonCode test out to CanPostHandler
	;							so we can still unit test this
	; 07-Jan-2008	shobby	SRBR014866: Get the value of 'Reason Code' from WWWRECALL
	; 03-Jan-2008	shobby	SRBR014827: Disable the post button if no reason code selected.
	; 16-Nov-2007	shobby	SRBR014741: Upgraded error message IN00783 to provide more
	;							information
	;-------------------------------------------------------------------------------
	new strEarliestDate,strRequiredStatus,strStatus
	
	set strStatus = $$$OK
 
	if pidStocktake'="" {
		if $$IsStocktakeComplete^INWEINVPStatus(pidStocktake,.strRequiredStatus) {
			set strStatus=$$$MakeStatus("IN00486")
		;	"Cannot update stock, as stocktake has already been completed."
			
		} elseif '$$IsCountProcessClosed^INWEINVPStatus(pidStocktake,.strRequiredStatus) {
			set strStatus=$$$MakeStatus("IN00783",strRequiredStatus)
		;	FIXME : <GRF> is this too long for a reasonable alert message?
		;	"It is not possible to post the stocktake because the counting process has not finished. The stocktake must be in a status of '%1' to be posted."
		
		} elseif $$TooEarly(pidStocktake) {
			; $zdate($$GetEarliestPostDate(pidStocktake),4)
			set strEarliestDate = $$^WWWDATE($$GetEarliestPostDate(pidStocktake))
			set strStatus = $$$MakeStatus("IN00776",strEarliestDate)
			; "The earliest stocktake posting date is %1."  /  "A data mínima de conciliação do inventário é %1."
		}
	} else {
		set strStatus=$$$MakeStatus("IN00784")
	;	"It is not possible to post the stocktake because no stocktake has been loaded."
	}
	$$$YQHandler(strStatus)
	quit strStatus
	
	
GetUnadjustedDifference(pidStocktake,pidLine,pidCount)
	;-------------------------------------------------------------------------------
	; returns the difference between a counted quantity and a target 
	; ignoring any movements
	; 
	; History
	; 06-Dec-2007	PJones	SR??? : Created (added 21-Jan-2008)
	;-------------------------------------------------------------------------------
	new objCount,objLine
	
	set objLine  = $$GetStocktakeLine(pidStocktake,pidLine)
	set objCount = $$GetCount^INWEINVCount(pidStocktake,pidLine,pidCount)
	quit ($$$INWEINVCountQuantity(objCount) - $$$INWEINVTargetQuantity(objLine))
 
 
StocktakeStartDate(pidStocktake)
	quit $$$INWEINVPSystemDate($$GetStocktake(pidStocktake))
	
	
CountDate(pidStocktake,pidLine,pidCount)	
	quit $$$INWEINVCountTimestamp1($$GetCount(pidStocktake,pidLine,pidCount))
	
	
ListOfItemsInSnapshot(pidItem,pidStocktake)
	new list,res,sql
	
	set list = ""
	set sql = "select ItemNumber from INWEINV where ItemNumber = '"_pidItem_"' and DateOfStocktaking='"_pidStocktake_"'"
	set res = $$NewQuery^INARTHISTL(sql)
	do res.Execute()
	while res.Next() { 
		set list = list_";"_res.Data("ItemNumber")
	}
	quit list
 
	;ItemInSnapshot(pidItem,pidStocktake)
	; find if a particular item number is in the snapshot for a particular stocktake
	;new res, sql, contains
	;set contains = $$$NO
	;set sql = "select ItemNumber from INWEINV where ItemNumber = '"_pidItem_"' and DateOfStocktaking='"_pidStocktake_"'"
	;set res = $$NewQuery^INARTHISTL(sql)
	;do res.Execute()
	;while res.Next() {
	;	set contains = $$$YES
	;}
	;quit contains
	
	
ItemInSnapshot(pidItem,pidStocktake)
	;-------------------------------------------------------------------------------
	; History :
	; 03-Oct-2008	GRF		SR15810: Although this is not being used in my revisions
	;							the bug which checked against the item being in ANY
	;							previous stocktake cannot be left as is.
	;-------------------------------------------------------------------------------
	/*
	new contains
	set contains = $$$NO
	if $data(^INWEINVs(YM,100,pidItem)) {
		set contains = $$$YES
	}
	quit contains
	*/
	quit ''$data(^INWEINVs(YM,100,pidItem,pidStocktake))
	
	
GetMovementsForThisLine(pidStocktake,pidLine,pidCount) 
	;-------------------------------------------------------------------------------
	; we're defining a particular snapshot line
	; what we want back is total of movements that impact it
	; so want the item, site, storage, and date range
	; then calculate movements there
	;-------------------------------------------------------------------------------
	new idItem, idSite, idStorage, hStart, hEnd, dteStart, dteEnd, tmStart, tmEnd
	new objLine, objResult
 
	set hStart = $$StocktakeStartDate(pidStocktake)         ; from the snapshot (should be horolog format)
	set hEnd   = $$CountDate(pidStocktake,pidLine,pidCount) ; to this count     (should be horolog format)
 
	set objLine   = $$GetStocktakeLine(pidStocktake, pidLine)
	set idItem    = $$$INWEINVItemNumber(objLine)
	set idSite    = $$$INWEINVLocation(objLine)
	set idStorage = $$$INWEINVStockLocation(objLine)
 
	set objResult = $$QueryHistory^INARTHISTL(idItem, idSite, idStorage, hStart, hEnd)
 
	quit $$GetTotalMovements^INARTHISTL(objResult)
	
	
GetDifferenceAdjustedByMovements(pidStocktake,pidLine,pidCount) 
	;-------------------------------------------------------------------------------
	; returns the difference between a counted quantity and a target 
	; taking into account any movements that there have been since the snapshot
	;-------------------------------------------------------------------------------
	new stmpSnapshot,stmpCount,qtyCount,qtyTarget,qtyDiff,qtyMoves,qtyAdjDiff
	new objCount,objLine,idItem,strLocnList,objStocktake,idFromStore,idToStore
	
	; Get stocktake info
	set objStocktake = $$GetStocktake(pidStocktake)
	set strLocnList  = $$$INWEINVPSiteLocation(objStocktake)         ; FIXME : This variable is not used
	set idFromStore  = $$$INWEINVPFromStockLocation(objStocktake)    ; FIXME : This variable is not used
	set idToStore    = $$$INWEINVPToStockLocation(objStocktake)      ; FIXME : This variable is not used
 
	; Get line info
	set objLine = $$GetStocktakeLine(pidStocktake,pidLine)
	set stmpSnapshot = $$$INWEINVCountTimestamp(objLine)             ; FIXME : This variable is not used
	set idItem       = $$$INWEINVItemNumber(objLine)                 ; FIXME : This variable is not used
	
	set objCount  = $$GetCountObjNearestTo^INWEINVCount(pidStocktake,pidLine,pidCount) 
	set stmpCount = $$$INWEINVCountTimestamp1(objCount)              ; FIXME : This variable is not used
	
	set qtyDiff   = $$GetUnadjustedDifference(pidStocktake,pidLine,pidCount)
	quit qtyDiff - $$GetMovementsForThisLine(pidStocktake,pidLine,pidCount) 
	
		
AdjustedDifference(fltCounted,fltTarget,fltMove)
	;-------------------------------------------------------------------------------
	; This calculation broken out from INWEINVDif 
	; calculates the "difference" for the difference report
	; fltCounted is what was counted, fltTarget is what we expect to find
	; fltMove is some movements that we'd 
	;-------------------------------------------------------------------------------
	quit fltCounted-fltTarget-fltMove
 
 
LastLineKey(pidStocktake)
	;-------------------------------------------------------------------------------
	; count lines in a stocktake
	;-------------------------------------------------------------------------------
	quit $order(^INWEINV(YM,pidStocktake,""),-1) 
	
	
CreateNewLineKey(pidStocktake)
	;-------------------------------------------------------------------------------
	; find key of last line and return it + 1 (next available key)
	;-------------------------------------------------------------------------------
	quit $$LastLineKey(pidStocktake) + 1 
	
	
AddUnknownItemLine(pidStocktake, pidItem, pidSite, pidStockLocation, pDate, pQty)
	;-------------------------------------------------------------------------------
	; Creates a new line to add to the snapshot
	;-------------------------------------------------------------------------------
	new objLine,newKey,objStocktake,strStatus,objCount,intCount,noCounts
	
	set objLine = $$MakeLine(pidItem,pidSite,pidStockLocation,pDate,"",pQty)
	set newKey  = $$CreateNewLineKey(pidStocktake)
	
	set strStatus = $$SaveLine(pidStocktake,newKey,objLine)
	
	if $$$ISOK(strStatus) {
		set noCounts = +$$$INWEINVPNumberofCounts($$GetStocktake(pidStocktake))
		for intCount=1:1:(noCounts-1) {
			set strStatus = $$CreateAndStore^INWEINVCount("","",pidStocktake,newKey,intCount) 
		}
		set strStatus = $$CreateAndStore^INWEINVCount(pQty,"",pidStocktake,newKey,noCounts) 
	}
 
	quit strStatus
 
 
PrintHistory(idItem)
	new objResult
	
	set objResult = $$QueryHistoryByItemId^INARTHISTL()
	do objResult.Execute(idItem)
	while (objResult.Next()) {
		write !,objResult.Data("Item")_", "_objResult.Data("Date1")_", "_objResult.Data("Quantity")
	}
	do objResult.Close()
	quit
 
 
ItemInGrid(pidItem,pstrKey1,&parrGrid,pidCurrentLine=0)
	;-------------------------------------------------------------------------------
	; check whether an item with idItem is already in the grid
	; 
	; Params :
	;	pidItem        - an item id
	;	pstrKey1       - assuming this is called from INWEINV pidStocktake, the first key of the grid
	;	&parrGrid      - ByRef list containing the grid contents
	;	pidCurrentLine - ignore this line of the grid 
	;
	;	Note : if you're calling this as the user is entering an item into the grid, the 
	;	line where the user enters the new item will already be set within parrGrid 
	;	so you need to send the current line number as the "ignore". Otherwise 
	;	this routine will always return true : is the item I just entered in the grid?
	;
	; History:
	; 10-Apr-2010	GRF		SR17177: parrGrid rather than gridData; Non-standard for
	;							loop format; non-compliant prefixes
	;-------------------------------------------------------------------------------
	new blnFoundInGrid,index,objData,idLineItem
	
	set blnFoundInGrid = $$$NO
 
	set loop = ""
	for {
		set loop = $order(parrGrid(pstrKey1,loop))
		quit:loop=""
		
		set objData    = parrGrid(pstrKey1,loop)
		set idLineItem = $$$INWEINVItemNumber(objData)
		
		if (idLineItem=pidItem) && (loop'=pidCurrentLine) {
			set blnFoundInGrid = $$$YES
			quit
		}
	}
	quit blnFoundInGrid
	
	
GetINWEQty(item,site,store)
	new index,total
	
	set index = ""
	set total = 0
	for {
		set index = $order(^INWE(YM,item,site,store,index))
		quit:index=""
		
		set total = total + $$$INWEQuantity($get(^INWE(YM,item,site,store,index,1)))
	}
	quit total
	
	
GetNumberOfHighestCount(pidStocktake)
	quit $$$INWEINVPNumberofCounts($$GetStocktake(pidStocktake))
 
GetEarliestPostDate(pidStocktake)
	quit $$$INWEINVPEarliestPostDate($$GetStocktake(pidStocktake))
	
	
TooEarly(pidStocktake)
	;-------------------------------------------------------------------------------
	; History:
	; 24-Sep-2008	GRF		SR15810: $data test meaningless - standardise variables
	;-------------------------------------------------------------------------------
	new blnReturn,earliestPostDate
	
	set earliestPostDate = $$GetEarliestPostDate(pidStocktake)
	set blnReturn = $$$NO
	
	;if ($data(earliestPostDate) && (+$horolog < earliestPostDate) ) { ; SR15810
	if (earliestPostDate'="") && ($horolog<earliestPostDate) {
		set blnReturn = $$$YES
	}
	
	quit blnReturn
]]></Routine>
</Export>