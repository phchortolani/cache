<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="CACHE" ts="2001-01-01 00:00:00">
<Class name="alSYS.Compile.piScriptCompile">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

The primary Compiling object for scripts and rules <code>alSYS.Script.iScript</code><br>

This class takes a <code>alSYS.Script.data.dScriptClass</code> object and
creates a class based on the parameters extracted from it. <br>
The <code>alSYS.Script.data.dScriptMethod</code> states the methods the object 
contains while <code>alSYS.Script.data.dScriptLogicLine</code> and
<code>alSYS.Script.data.dScriptNode</code> pertain to the actual logic of each
method.<p><br>

The nodes are compiled as though they each take a part the logic of a method and
may effect the methods parameters. <br>

Because of the nature of the compiler (pre-compiler really), a few passes are 
made over the object in question (similar to that of a C/C++ compiler); each
pass taking into account an aspect of the code. As each pass goes over the code,
the saved code is placed into <code>arrLogicLineInfo</code>.  This contains
lists of the line of code to be injected into the method. <p>

The Method contains        <br>
	Description            <br>
		The in-code comment of the method contains <br>
			* a psudeo code version of the script  <br>
			* Time of Compliation                  <br>
			* User information                     <br><br>
		
	Return statement <br>
		The type of Object that is to be expected to be returned <br>
	Parameters <br>
		<code>arrParameters</code> The paramters that will be passed into the script so the 
		script can access them. This is handy for @net manager objects being passsed in as objects<br>
	Header <br>
		The creation and setting up of needed variables and other objects for the scripts main boddy
		this occurs at the top of the method <br>
	Core logic <br>
		<code>arrLogicLineInfo</code> conatins Lists. Each list is a line of logic to be 
		injected to the method as needed <br>
	Footer <br>
		Closing braces and end logic that is needed <br>
		<p><p><br>
		
Compiling Phases                        <br>
   GlobValNumCheck                      <br>
   		Checks and replaces             <br>
   			- Variable                  <br>
   			- Method calls              <br>
   			- Objects                   <br>
   			- return statements (quits) <br>
   			- tests ($$$NULLOREF)       <br><br>
   	
   CondPlacement<br>
   		checks and replaces syntax code <br>
   		 	- if, else,                 <br><br>
 
   SetUpMethod<br>
    creates the following ready for insertion into the method comments <br>
		- Creates a psudeo version of the code <br>
		- stamps with compilation time <br>
		<br>
		
TODO  <br> Feel free to add to this list <br>
- Change the header to a list or array to better function with object checks, 
  as at the moment each object is created seperately, even if it is referencing
  the same thing<br>
- Better Logic passing, allowing the compiler to check for errors BEFORE it
  tries to compile. <br>
- Add indent level in generated code and comments converts to a number of tabs;
  one extra for each indent reducing when the indent level drops <br>
- USER INFOMATION logging, plug into the user data structure and or interface
  ...when there is one<br>
<br>


<b>Adding new Types/Nodes Scripts</b><br>
see <code>alSYS.Script.data.dScriptType</code> documentation <br>
]]></Description>
<ClassType/>
<IncludeCode>%occInclude,COMSYS,WWWConst</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>%RegisteredObject</Super>

<Property name="arrLogicLineInfo">
<Description><![CDATA[
Storage area for the code of each method<br>
As it passes through each compilation phase the code is stored here before being
written to the method instance.]]></Description>
<Type>%ArrayOfDataTypes</Type>
</Property>


<Property name="arrParameters">
<Description><![CDATA[
Similar to <code>arrLogicLineInfo</code>, this allows any parameters needed by a
method to be built up before being injected to the method's strFormalspec.]]></Description>
<Type>%ArrayOfDataTypes</Type>
</Property>


<Property name="arrFooter">
<Type>%ArrayOfDataTypes</Type>
</Property>

<UDLText name="T">
<Content>
//++++++++++++++++++++++++++++++++++++++++++

</Content>
</UDLText>


<Method name="getErrorMessage">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

Error deconstructor tool<br>

<b>Params:</b><br>
 pidStatus		The Error as a Status <br>

<b>Returns:</b><br>
The string value of the error<br>
]]></Description>
<FormalSpec>pidStatus:%Status</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	;-------------------------------------------------------------------------------
	; History:
	; 10-Oct-2007	LB		SR15616: Created 
	;-------------------------------------------------------------------------------
	set strMessage = ""
	do DecomposeStatus^%apiOBJ(pidStatus,.errlist,"-d")
	for loopK=1:1:errlist {
		set strMessage = strMessage_errlist(loopK)
	}
	quit strMessage
]]></Implementation>
</Method>

<Method name="compileScript">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

The initial entry of the compliation of a script<br>
Starts the inital compilation of the class<br>
The class' data and paramaters are set up here. <br>
All scripts extend the <code>alSYS.Script.dtScriptBase</code> class <br><p>

<b>Params:</b><br>
 piScriptGroup		The Script group <code>alSYS.Script.data.dScriptClass</code>

<b>Returns:</b><br>
 The status of the compilation<br>]]></Description>
<FormalSpec>piScriptGroup:alSYS.Script.data.dScriptClass</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;-------------------------------------------------------------------------------
	; History:
	; 10-Oct-2007	LB		SR15616: Created 
	;-------------------------------------------------------------------------------
	set delim         = $$$CRLF
	set classname     = piScriptGroup.Name
	set packagename   = "script."_piScriptGroup.ClassAttachment
	set objCacheClass = ""
	
	if ##class(%Dictionary.ClassDefinition).%ExistsId(packagename_"."_classname) {
		set SUCCESS = ##class(%Dictionary.ClassDefinition).%DeleteId(packagename_"."_classname)
	}
	set objCacheClass = ##class(%Dictionary.ClassDefinition).%New(packagename_"."_classname)
	
	set objCacheClass.Abstract = 1
	
	set strDescrip = piScriptGroup.Name_delim
	set strDescrip = piScriptGroup.ClassAttachment_delim_delim
	set strDescrip = piScriptGroup.Description_delim
	
	set objCacheClass.Description    = strDescrip
	set objCacheClass.IncludeCode    = "%occInclude,COMSYS"
 	set objCacheClass.Import         = ""
	set objCacheClass.ProcedureBlock = 1	
	set objCacheClass.Super          = "alSYS.Script.dtScriptBase,%XML.Adaptor" 
	
	for loopi = 1:1:piScriptGroup.Methods.Count() {
		set method       = piScriptGroup.Methods.GetAt(loopi)
		set objCacheMeth = ..SetUpMethod(method)		
		do objCacheClass.Methods.Insert(objCacheMeth)
	
	}
	//relationship Methods     As %Dictionary.MethodDefinition      [Inverse = parent; Cardinality = children;]
	//relationship Parameters  As %Dictionary.ParameterDefinition   [Inverse = parent; Cardinality = children;]
	//relationship Projections As %Dictionary.ProjectionDefinition  [Inverse = parent; Cardinality = children;]
	//relationship Properties  As %Dictionary.PropertyDefinition    [Inverse = parent; Cardinality = children;]
	//relationship Queries     As %Dictionary.QueryDefinition       [Inverse = parent; Cardinality = children;]
	//relationship Storages    As %Dictionary.StorageDefinition     [Inverse = parent; Cardinality = children;]
	//relationship Triggers    As %Dictionary.TriggerDefinition     [Inverse = parent; Cardinality = children;]
	//relationship UDLTexts    As %Dictionary.UDLTextDefinition     [Inverse = parent; Cardinality = children;]
	//relationship XDatas      As %Dictionary.XDataDefinition       [Inverse = parent; Cardinality = children;]
	
	//tstart 
	set sc = objCacheClass.%Save()             ; FIXME : Not (re)testing sc
	set sc = objCacheClass.%Close()            ; Not required?
	set sc = $System.OBJ.Compile(packagename_"."_classname,,.ERR)

	// TODO This is set to emulate a deployed state ie delete/remove the source 
	//set sc=##class(%Dictionary.ClassDefinition).%DeleteId(packagename_"."_classname)
	//set sc=piScriptGroup.%Close()
	
	/*
	 if ($$$ISERR(sc)) {
     // one of the saves failed, rollback
     TROLLBACK
	 } else {
	     // everything is ok, commit
	  TCOMMIT($tlevel>0)
	 }
	*/
	quit sc
]]></Implementation>
</Method>

<Method name="GlobValNumCheck">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

The first phase of the compilation<br>

This phase focuses on logic and varables<br>
* SYSTEMINPUT         <br>
* USERINPUT           <br>
* CONSTANT            <br>
* RETURN              <br>
* TEST                <br><br>

As a logic line is referenced, each of its nodes are checked for a value.<br>
If it corresponds to one of the above, a code representation of it is placed
into <code>arrLogicLineInfo</code> in the relevant place.<br>
The header and footer are changed and added to as needed. (The header where
varables are initialised and the footer where braces are closed.) <br><br>

Because of the nature of the precompiler, it is difficult to determine what type
of object a variable is; the DISCLINC standard of using str, int, bln, etc. for 
the variable type is therefore unavailable. <br>
Thus a prefix of "V" (for variable) is assigned with a number ie V1.<br>
This can be seen in the generated code<br><br>
 
 <b>TODO</b><br> 
 * Correct return settings <br>
 * Better Logic passing    <br><p>

<b>Params:</b><br>
     pMethod		The Method Object that is being complied <code>alSYS.Script.data.dScriptMethod</code>

<b>Returns:</b><br>
	The header of the method<br>]]></Description>
<FormalSpec>&amp;pMethod:alSYS.Script.data.dScriptMethod</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	;-------------------------------------------------------------------------------
	; History:
	; 05-Dec-2007	GRF		bln... rather than bol...
	; 10-Oct-2007	LB		SR15600: Created 
	;-------------------------------------------------------------------------------
	set delim           = $$$CRLF
	set tab             = $$$TAB
	set blnFoundTest    = $$$NO
	set strHeader       = ""
  	set variablecounter = 1               ; $a("a")
   
	for intLoopi=1:1:pMethod.LogicLines.Count() {
		set currentlogicline 	= pMethod.LogicLines.GetAt(intLoopi)
		set intCount 			= 1
		set loginLineArguments  = ##class(%Library.ListOfDataTypes).%New()
		if ..arrLogicLineInfo.GetAt(intLoopi) '=$$$NULLOREF {
			set loginLineArguments = ..arrLogicLineInfo.GetAt(intLoopi) 
		}  
		
		set rsNodes = ##class(alSYS.Script.iScript).getOrderNodes(currentlogicline.%Id(),intLoopi)
		while (rsNodes.Next(.sc)) {
		  if ($$$ISOK(sc)) {
			set strVName = "" 
			set currentNode = ##class(alSYS.Script.iScript).getNode(rsNodes.Data("ID"))
			set objNodeType = ##class(alSYS.Script.iScript).getNodeType(rsNodes.Data("NodeType"))
			
			if (objNodeType.screenType = "SYSTEMINPUT")  {  //System input	 
				Set pdef = ##class(%Library.MethodDefinition).%OpenId(currentNode.Method)
				set strParams = ..setMethodParameters(.strHeader,.variablecounter,currentNode)
				
				if pdef.ClassMethod = $$$NO { 
					set strVName 	= "OBJ"_variablecounter_"."_pdef.Name_"("_strParams_")"
					set strHeader 	= strHeader_" Set "_strVName_" = ##class("_pdef.ClassName_").%New()"
					set variablecounter = variablecounter + 1
				} else {
					set strVName 	="##class("_pdef.ClassName_")."_pdef.Name_"("_strParams_")"
				}
			  	if intCount > loginLineArguments.Count() {
				  	for intLoop1 = loginLineArguments.Count():1:intCount {
					  	set sc = loginLineArguments.Insert("")
				  	}
			  	}
			  	
			  	if blnFoundTest {
				  	set strVName     = strVName_")"
				  	set blnFoundTest = $$$NO
			  	}
				do loginLineArguments.SetAt(strVName,intCount)
				
			  				  	
			} elseif (objNodeType.screenType = "STATUS") {    // 
				set strVName = ..setUpStatus(.strHeader,currentNode,.variablecounter)
				if blnFoundTest {
				  	set strVName     = strVName_")"
				  	set blnFoundTest = $$$NO
			  	}
			  	if intCount > loginLineArguments.Count() {
				  	for loopjK = loginLineArguments.Count():1:intCount {
					  	set sc = loginLineArguments.Insert("")
				  	}	
			  	}	
				set sc = loginLineArguments.SetAt(strVName,intCount)
				
				
			} elseif (objNodeType.screenType = "USERINPUT") {    //user input 
				set strVName = ..setUpUserInput(.strHeader,currentNode,.variablecounter)
				if blnFoundTest {
				  	set strVName     = strVName_")"
				  	set blnFoundTest = $$$NO
			  	}
			  	set strHeader = strHeader_delim
			  	if intCount > loginLineArguments.Count() {
				  	for loopjK = loginLineArguments.Count():1:intCount {
					  	set sc = loginLineArguments.Insert("")
				  	}	
			  	}	
			  	set sc = loginLineArguments.SetAt(strVName,intCount)
			  	
			  	
		   } elseif (objNodeType.screenType = "CONSTANT") {    //Constants
				set strVName = ..setUpConstants(.strHeader,objNodeType,.variablecounter)
				
				if blnFoundTest {
				  	set strVName     = strVName_")"
				  	set blnFoundTest = $$$NO
			  	}
				
			  	if intCount > loginLineArguments.Count() {
				  	for loopjK = loginLineArguments.Count():1:intCount {
					  	set sc = loginLineArguments.Insert("")
				  	}	
			  	}	
				set sc = loginLineArguments.SetAt(strVName,intCount)
				
				
		   } elseif (objNodeType.screenType = "RETURN") {    //RETURN
				set strVName = " quit "
			  	if intCount > loginLineArguments.Count() {
				  	for loopjK = loginLineArguments.Count():1:intCount {
					  	set sc = loginLineArguments.Insert("")
				  	}	
			  	}	
				set sc = loginLineArguments.SetAt(strVName,intCount) 
				
				
		   } elseif (objNodeType.screenType = "TEST") {    //TEST
		   		set blnFoundTest = $$$YES 
				set strVName = ..setUpTests(.strHeader,objNodeType,.variablecounter) 
			  	if intCount > loginLineArguments.Count() {
				  	for loopjK = loginLineArguments.Count():1:intCount {
					  	set sc = loginLineArguments.Insert("")
				  	}	
			  	}	
				set sc = loginLineArguments.SetAt(strVName,intCount)
				
				
		   } elseif (objNodeType.screenType = "THIS") {    //This
		   
				set strVName = ..setUpThis(.strHeader,currentNode,.variablecounter)	
				if blnFoundTest {
				  	set strVName     = strVName_")"
				  	set blnFoundTest = $$$NO
			  	}
			  	if intCount > loginLineArguments.Count() {
				  	for loopjK = loginLineArguments.Count():1:intCount {
					  	set sc = loginLineArguments.Insert("")
				  	}	
			  	}	
				set sc = loginLineArguments.SetAt(strVName,intCount) 
				
				
		   } elseif (objNodeType.screenType = "SYSMETHOD") {    //System Methods
				set strVName = ..setSysMethods(.strHeader,currentNode,.variablecounter)	
			  	if intCount > loginLineArguments.Count() {
				  	for loopjK = loginLineArguments.Count():1:intCount {
					  	set sc = loginLineArguments.Insert("")
				  	}	
			  	}	
			  	set sc = loginLineArguments.SetAt(strVName,intCount) 
		   }
		   
		   set intCount = intCount+1
		  }
	    }
		do ..arrLogicLineInfo.Insert(loginLineArguments) 
	}
	
 quit strHeader
]]></Implementation>
</Method>

<Method name="setSysMethods">
<Description><![CDATA[
System Method that are allowed by the script compiler are implimeneted here
setSysMethods<br><br>

<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>
This phase focuses on logic and variables<br>
* SYSTEMINPUT  <br>
* USERINPUT    <br>
* CONSTANT     <br>
* RETURN       <br>
* TEST         <br><br>

As a logic line is referenced, each of its nodes are checked for a value.<br>
If it corresponds to one of the above, a code representation of it is placed
into <code>arrLogicLineInfo</code> in the relevant place.<br>
The header and footer are changed and added to as needed. (The header where
varables are initialised and the footer where braces are closed.) <br><br>

Because of the nature of the precompiler, it is difficult to determine what type
of object a variable is; the DISCLINC standard of using str, int, bln, etc. for 
the variable type is therefore unavailable. <br>
Thus a prefix of "V" (for variable) is assigned with a number ie V1.<br>
This can be seen in the generated code<br><br>
 
<b>TODO</b><br> 
 * Correct return settings <br>
 * Better Logic passing    <br><p>

<b>Params:</b><br>
	pMethod		The Method Object that is being complied <code>alSYS.Script.data.dScriptMethod</code><br>
<b>Returns:</b><br>
	The header of the method<br>]]></Description>
<FormalSpec>&amp;pheader:%String,pNode:alSYS.Script.data.dScriptNode,&amp;pCount:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set strReturn = ""
	set strNodeType = pNode.NodeType.Type

	if (strNodeType = 50) {            // ???
		set strReturn = "$ZUTIL(188)"

	} elseif (strNodeType = 51) {      // ???
		set strReturn = "$HOROLOG"
	}
	quit strReturn
]]></Implementation>
</Method>

<Method name="setUpStatus">
<FormalSpec>&amp;pheader:%String,pNode:alSYS.Script.data.dScriptNode,&amp;pCount:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	;-------------------------------------------------------------------------------
	; History:
	; 04-Aug-2008	Luke		 corrected Status Writing to script
	; 12-Oct-2007	Luke		SR15600: Created 
	;-------------------------------------------------------------------------------

	
	set strReturn = ""
	set strNodeType = pNode.NodeType.Type

	if (strNodeType = 70) {            //Object
		set strReturn ="$$$ERROR($$$GeneralError,$$$Text("""_pNode.Method_""")) " // SR15814:

		//set strReturn = "$$$MakeStatus("""_pNode.Method_""")"   //SR10044:

	} elseif (strNodeType = 121) {     //Property
 		//set strReturn = "$$$MakeStatus("""_pNode.Method_""")"
	}
	
	quit strReturn
]]></Implementation>
</Method>

<Method name="setMethodParameters">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

Parameter Construction of a Method Call<br>
The creation and setting up of parameters to a method<br>
When a node has parameters attached to it (usually a method), it is constructed
with the parameters ready to be passed in to the object.<br><br>

This method is called via the <code>GlobValNumCheck</code> phase of the
complation as it looks for method.<br>
It passes in any the Header, the variable counter by reference to allow 
any changes needed to effect the reference in the calling method.<br><br><p>

<b>Params:</b><br>
	pheader		The header of the method being created 
	pCount		The variable counter of the method
	pNode		The node being worked on

<b>Returns:</b><br>
	Code ready to be injected into the <code>arrLogicLineInfo/<code><br>]]></Description>
<FormalSpec>&amp;pheader:%String,&amp;pCount:%String,pNode:alSYS.Script.data.dScriptParamNode</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	;  FIXME : Consider rearranging parameter order so consistent with other methods <GRF>
	;-------------------------------------------------------------------------------
	; History:
	; 09-Apr-2008	GRF		bln... rather than bol...; not required?
	; 12-Oct-2007	LB		SR15600: Created 
	;-------------------------------------------------------------------------------
	set delim     = $$$CRLF
	set strReturn = ""
	set key       = ""
	set loginLineArguments = ##class(%Library.ListOfDataTypes).%New()

	for intLpi = 1:1:pNode.Parameter.Count() {
		set objCurrParmNode = pNode.Parameter.GetNext(.key)
		set objType = objCurrParmNode.NodeType 
		
		if (objType.screenType = "SYSTEMINPUT")  {         // System input
			set pdef = ##class(%Library.MethodDefinition).%OpenId(pNode.Method)
			set strParams = ..setMethodParameters(.pheader,.pCount,pNode.Parameter.GetAt(intLpi))
			if pdef.ClassMethod = $$$NO { 
				set strVName  = "OBJ"_variablecounter_"."_pdef.Name_"("_strParams_")"
				set strHeader = strHeader_" Set "_strVName_" = ##class("_pdef.ClassName_").%New()"
				set variablecounter = pCount + 1
			} else {
				set strVName ="##class("_pdef.ClassName_")."_pdef.Name_"("_strParams_")"
			}
		  	do loginLineArguments.Insert(strVName)
			
			
		} elseif (objType.screenType= "USERINPUT") {       // user input 
			set strVName = ..setUpUserInput(.pheader,objCurrParmNode,.pCount)
			set pheader  = pheader_delim
			do loginLineArguments.Insert(strVName)
			
			
		} elseif (objType.screenType = "CONSTANT") {       // Constants
			set strVName = ..setUpConstants(.pheader,objType,.pCount)
			do loginLineArguments.Insert(strVName)     
			
			
		} elseif (objType.screenType = "TEST") {           // TEST
			set blnFoundTest = $$$YES                                  ; FIXME: Not used?
			set strVName = ..setUpTests(.pheader,objType,.pCount)
			do loginLineArguments.Insert(strVName)
			
			
		} elseif (objType.screenType = "THIS") {           // THIS
			set strVName = ..setUpThis(.pheader,objCurrParmNode,.pCount)
		}
		; FIXME: else situation?  error handling?
	}
	
	for loopi=1:1:loginLineArguments.Count() {
		set strReturn = strReturn_loginLineArguments.GetAt(loopi)
		if (loopi) < loginLineArguments.Count() {
			set strReturn = strReturn_","
		}
	}

	quit strReturn
]]></Implementation>
</Method>

<Method name="setUpThis">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

The method for setting up code for This (this calling object) AKA ##THIS<br>
This allows variables that are passed in that are instances of ##THIS to be
referenced properly and reach properly.<br><br><p>

<b>Params:</b><br>
	pheader		The header of the method being created 
	pNode		The node being worked on
	pCount		The variable counter of the method

<b>Returns:</b><br>
	Code ready to be injected into the <code>arrLogicLineInfo/<code><br>]]></Description>
<FormalSpec>&amp;pheader:%String,pNode:alSYS.Script.data.dScriptNode,&amp;pCount:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	;-------------------------------------------------------------------------------
	; History:
	; 06-Dec-2007	PP		15616 Parameters need to be defined as 'par:class'
	; 							NOT 'par As Class'; Studio sees ':' in oddDEF and
	; 							then converts to 'As' for the user
	; 12-Oct-2007	LB		15616: Created 
	;-------------------------------------------------------------------------------
	set strReturn   = ""
	set strNodeType = pNode.NodeType.Type
	
	if (strNodeType = 120) {                               // Object
	    set strReturn = ..checkParameters(pNode.Class)
	    if strReturn = "" { 
	    	set strReturn = "pOBJ"_pCount
			set pCount = pCount + 1
		//	set strInsert = strReturn_" as "_pNode.Class		; SR15600
			set strInsert = strReturn_":"_pNode.Class
			do ..arrParameters.Insert(strInsert)
	    }
		
		
	} elseif (strNodeType = 121) {                         // Property
	    set strReturn = ..checkParameters(pNode.Class)
	    if strReturn = "" { 
	    	set strReturn = "pOBJ"_pCount
			set pCount = pCount + 1
			set strInsert = strReturn_":"_pNode.Class
			do ..arrParameters.Insert(strInsert)
	    }
		set strReturn = strReturn_"."_pNode.Method
		
		
	} elseif (strNodeType = 122) {                         // Method
	    set strReturn = ..checkParameters(pNode.Class)
	    if strReturn = "" { 
	    	set strReturn = "pOBJ"_pCount
			set pCount = pCount + 1
			set strInsert = strReturn_":"_pNode.Class
			do ..arrParameters.Insert(strInsert)
	    }
		
		if pNode.Parameter.Count()>0 {
			set strParams = ..setMethodParameters(.pheader,.pCount,pNode)
		} else {
			set strParams =""
		}
		set strReturn = strReturn_"."_pNode.Method_"("_strParams_")"	
		
		
	} elseif (strNodeType = 123) {                         // Object NEW
	//	set strReturn = ..checkParameters(pNode.Class)
	//	if strReturn = "" { 
	    	set strReturn = "OBJ"_pCount
	    	set pheader = pheader_" set "_strReturn_" = ##class("_pNode.Class_").%New()"
			set pCount = pCount + 1
	//		set strInsert = strReturn_":"_pNode.Class
	//		do ..arrParameters.Insert(strInsert)
	//	}


	} elseif (strNodeType = 124) {                         // Property
	    set strReturn = "OBJ"_pCount
	    set pheader = pheader_" set "_strReturn_" = ##class("_pNode.Class_").%New()"
		set pCount = pCount + 1
		set strReturn = strReturn_"."_pNode.Method
		
		
	} elseif (strNodeType = 125) {                         // Method
    	set strReturn = "OBJ"_pCount
    	set pheader   = pheader_" set "_strReturn_" = ##class("_pNode.Class_").%New()"
		set pCount    = pCount + 1
		
		if pNode.Parameter.Count()>0 {
			set strParams = ..setMethodParameters(.pheader,.pCount,pNode)
		} else {
			set strParams =""
		}
		set strReturn = strReturn_"."_pNode.Method_"("_strParams_")"	
		
		
	} elseif (strNodeType = 126) {                         // Object From ID
		set strReturn = "OBJ"_pCount
	    set strParams = ..setMethodParameters(.pheader,.pCount,pNode)
	    set pheader   = pheader_" set "_strReturn_" = ##class("_pNode.Class_").%OpenId("_strParams_")"
		set pCount    = pCount + 1
		
		
	} elseif (strNodeType = 127) {                         // Property
	    set strReturn = "OBJ"_pCount
	    set strParams = ..setMethodParameters(.pheader,.pCount,pNode)
	    set pheader   = pheader_" set "_strReturn_" = ##class("_pNode.Class_").%OpenId("_strParams_")"
		set pCount    = pCount + 1
		set strReturn = strReturn_"."_pNode.Method
		
		
	} elseif (strNodeType = 128) {                         // Method  
    	set strReturn = "OBJ"_pCount
    	set strParams = ..setMethodParameters(.pheader,.pCount,pNode)
    	set pheader   = pheader_" set "_strReturn_" = ##class("_pNode.Class_").%OpenId("_strParams_")"
		set pCount    = pCount + 1
		/*
		if pNode.Parameter.Count()>0 {
			set strParams = ..setMethodParameters(.pheader,.pCount,pNode)
		} else {
			set strParams =""
		}*/
		set strReturn = strReturn_"."_pNode.Method_"()"	
		
		
	} else {
		set strReturn = ""
	}

	quit strReturn
]]></Implementation>
</Method>

<Method name="checkParameters">
<FormalSpec>pClass:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	; FIXME : coding standards - "CheckParameters"
	;-------------------------------------------------------------------------------
	; History:
	; 06-Dec-2007	PP		SR15616 Parameters need to be defined as 'par:class'
	; 							NOT 'par As Class'; Studio sees ':' in oddDEF and
	; 							then converts to 'As' for the user
	; 12-Oct-2007	LB		SR15616: Created 
	;-------------------------------------------------------------------------------
	set strfound = ""
	for intLoopJ=1:1:..arrParameters.Count() {
		set temp = $translate($piece(..arrParameters.GetAt(intLoopJ),":",2)," ")
		if temp=pClass {
			set strfound = $translate($piece(..arrParameters.GetAt(intLoopJ),":",1)," ")
		}
	}
	quit strfound
]]></Implementation>
</Method>

<Method name="setUpTests">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

Sets up the syntax for Caché test, i.e. <code>$$$ISERR</code> or
<code>$$$ISOK</code><br><br>

This allows ease of use for external calls (such as from the compiler) to get
relevant information<br><br>

<b>Params:</b><br>
	pheader				The header of the class <br>
	pType				The type of node we are playing with  <br>
	pCount				The count of the varables, used in a V1, obj1 fashion.<br>
<b>Returns:</b><br>
	The code that will be injected to the class for this portion of the script.<br>]]></Description>
<FormalSpec>&amp;pheader:%String,pType:alSYS.Script.data.dScriptType,&amp;pCount:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (pType.Type = 110) {
		set strReturn = "$$$ISERR("
		
	} elseif (pType.Type = 111) {
		set strReturn = "$$$ISOK("
		
	} else {
		set strReturn = ""
	}
	quit strReturn
]]></Implementation>
</Method>

<Method name="setUpConstants">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

Sets up the syntax for Caché Constants, i.e. <code>$$$YES</code> or
<code>$$$NULLOREF</code><br><br>
 
<b>Params:</b><br>
	pheader			The header of the class <br>
	pType				The type of node we are playing with  <br>
	pCount				The count of the varables, used in a V1, obj1 fashion<br>
<b>Returns:</b><br>
	The code that will be injected to the class for this portion of the script.<br>]]></Description>
<FormalSpec>&amp;pheader:%String,pType:alSYS.Script.data.dScriptType,&amp;pCount:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (pType.Type = 80) {
		set strReturn = "$$$YES"
		
	} elseif (pType.Type = 81) {
		set strReturn = "$$$NO"
		
	} elseif (pType.Type = 82) {
		set strReturn = "$$$NULLOREF"
		
	} elseif (pType.Type = 83) {
		set strReturn = "$$$OK"
		
	} else {
		set strReturn = ""
	}
	quit strReturn
]]></Implementation>
</Method>

<Method name="setUpUserInput">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

Sets up user input, such as user defined Constants or reading from the keyboard
(very useful in a web application :) ) <br>
It manipulates the header as needed and places new variables into the generated
code, if needed.<br><br>
 
<b>Params:</b><br>
	pheader			The header of the class <br>
	pNode				The node we are playing with.<br>
	pCount				The count of the varables, used in a V1, obj1 fashion  <br>
<b>Returns:</b><br>
	The code that will be injected to the class for this portion of the script.<br>]]></Description>
<FormalSpec>&amp;pheader:%String,pNode:alSYS.Script.data.dScriptNode,&amp;pCount:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set strNodeType = pNode.NodeType.Type
	if (strNodeType = 40) {
		set strReturn = "V"_pCount
	  	set pheader   = pheader_"  read "_strReturn
	  	set pCount    = pCount + 1
	  	
	} elseif (strNodeType = 41) {                          //User set Constant
		set strReturn = """"_pNode.Method_""""
		
	} else {
		set strReturn = ""
	}
	quit strReturn
]]></Implementation>
</Method>

<Method name="CondPlacement">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

Parsing the <code>alSYS.Script.data.dScriptMethod</code> to getting COMMAND and
Conditional type nodes out of the method object.<br><br>
 
This is the second pass over the Method object (and the last for the code
generation) primarily focused in Caché commands and method flow - not variables,
logic or objects<br><br>
 
The generation can be broken into 3 main parts;<br>
The Header <br>
 - which is focused on the construction of objects and other variables and
   generally not used in the process<br>
The Body <br>
 - Stored as a global list to this class. The core code, much of the data for
   this is obtained from this method. <br>
The Footer <br>
 - Mostly closing of braces<br><br>
 
<b>Params:</b><br>
	pMethod			The method we are creating.<br>
<b>Returns:</b><br>
	The code that will be injected to the class for this Method.<br>]]></Description>
<FormalSpec>&amp;pMethod:alSYS.Script.data.dScriptMethod</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set delim     = $$$CRLF
	set tab       = $$$TAB
	set sc        = $$$OK
	set strFooter = ""
  	set lstConditions = ##class(alSYS.Script.iScript).getConditionList()
   	set addTooFooter  = $$$YES
   	
	for intLoopi=1:1:pMethod.LogicLines.Count() {
		set loginLineArguments = ##class(%Library.ListOfDataTypes).%New()
		set objCurLogicLine    = pMethod.LogicLines.GetAt(intLoopi) //get based on sequnce 
		set intCount = 1
		if ..arrLogicLineInfo.GetAt(intLoopi)'=$$$NULLOREF {
			set loginLineArguments = ..arrLogicLineInfo.GetAt(intLoopi) 
		} 
		set rsNodes = ##class(alSYS.Script.iScript).getOrderNodes(objCurLogicLine.%Id(),intLoopi)
		while (rsNodes.Next(.sc)) {
			if ($$$ISOK(sc)) {
				set currentNode = ##class(alSYS.Script.iScript).getNode(rsNodes.Data("ID"))
				set objType     = currentNode.NodeType 
	  			
		  		if (objType.screenType = "COMMAND") {
					if objType.Type = 1 {
						set strCodeVal = "if ("
						
					} elseif objType.Type = 2 { 
						set strCodeVal = " } else {" 
						
					} elseif objType.Type = 3 {       //then
						set strCodeVal = ") {"  
						if addTooFooter {
							set strFooter = strFooter_" }" 
						}
						
					} elseif objType.Type = 4 {
						set strCodeVal =  " do "
						
					} elseif objType.Type = 5 {
						set strCodeVal =  " set "
						
					} elseif objType.Type = 6 {
						set strCodeVal =  " } elseif ("
						set addTooFooter = $$$NO
					}
					
					if intCount > loginLineArguments.Count() {
					  	for loopjK = loginLineArguments.Count():1:intCount {
						  	set sc = loginLineArguments.Insert("")
					  	}	
				  	}	
				  	do loginLineArguments.SetAt(strCodeVal,intCount) 
					
				} elseif(objType.screenType = "Conditional") {
					if objType.Type = 10 { 
						set strCodeVal =  " = "
					} elseif objType.Type = 11 {
						set strCodeVal =  " '= "
					} elseif objType.Type = 12 {
						set strCodeVal =  " > "
					} elseif objType.Type = 13 {
						set strCodeVal =  " < "
					} elseif objType.Type = 13 {
						set strCodeVal =  " >= "
					} elseif objType.Type = 14 {
						set strCodeVal =  " <= "
					} elseif objType.Type = 15 {
						set strCodeVal =  " && " 
					} elseif objType.Type = 16 {
						set strCodeVal =  ") && ("
					} elseif objType.Type = 17 {
						set strCodeVal =  ") || ("
					}
					
					if intCount > loginLineArguments.Count() {
					  	for loopjK = loginLineArguments.Count():1:intCount {
						  	set sc = loginLineArguments.Insert("")
					  	}	
				  	}	
				  	do loginLineArguments.SetAt(strCodeVal,intCount) 
				}
				set intCount = intCount+1
			}
			do ..arrLogicLineInfo.SetAt(loginLineArguments,intLoopi)
		}
	}
	quit strFooter
]]></Implementation>
</Method>

<Method name="GetParameterDescription">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

The Parameters to a node are worked on to gather data for the description of the
method (ie the pseudo code)<br><br>

<b>Params:</b><br>
	pnode			The node we are playing with<br>
<b>Returns:</b><br>
	The Description that will be injected to the method's description <br>]]></Description>
<FormalSpec>pnode:alSYS.Script.data.dScriptParamNode</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set strReturn = ""
	
	set objNodeType = pnode.NodeType
	if (objNodeType.screenType = "SYSTEMINPUT") {  
		set strReturn = strReturn_" "_rsNodes.Data("Method")_"("
		
		if currentNode.Parameter.Count() '= 0 {
			for loopi = 1:1:currentNode.Parameter.Count {
				set strReturn = strReturn_..GetParameterDescription(currentNode.Parameter.GetAt(loopi))
			}
		}
		set strReturn = strReturn_" )"
		
		
	} elseif (objNodeType.screenType= "USERINPUT") {
		set strReturn = strReturn_" User Input "
		
		
	} else {
		set strReturn =  strReturn_" "_$$$Text(objNodeType.OScreenText)
	}
	
	if pnode.Parameter.Count() '= 0{		   
		for loopi = 1:1:currentNode.Parameter.Count {
			set strReturn = strReturn_..GetParameterDescription(currentNode.Parameter.GetAt(loopi))
		}
	}
	quit strReturn
]]></Implementation>
</Method>

<Method name="setMethodDescrip">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

Creates the comment at the beginning of each script / method <br>
each contains :<br>
 - pseudocode<br>
 - user information (this is not currently implimented) based on who compiled it<br>
 - generation time <br><br>
 
This is injected into the methods description, before the method is save into the class<br><br>

<b>Params:</b><br>
      The method we are playing with<br>
<b>Returns:</b><br>
      The method's description <br>]]></Description>
<FormalSpec>&amp;pMethod:alSYS.Script.data.dScriptMethod</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set delim = $$$CRLF
	set tab   = "    "    ; FIXME : <GRF> four spaces - Should be $$$TAB
	//set delim = $char(13,10,9)    ;$char(0)	

	set foundtab  = $$$NO
	set tablevel  = 1
	set tabinsert = tab
	
	set strReturn = ""
	for intLoopi=1:1:pMethod.LogicLines.Count() {
		set objLogicLine = pMethod.LogicLines.GetAt(intLoopi)
		//write !," tablevel "_tablevel

		for loopTab = 1:1:tablevel {
			set tabinsert = tabinsert_tab
		}

		if foundtab {
			set foundtab = $$$NO
			set tablevel = tablevel + 1
		}
		set rsNodes = ##class(alSYS.Script.iScript).getOrderNodes(objLogicLine.%Id(),intLoopi)

		while (rsNodes.Next(.sc)) {
			if ($$$ISOK(sc)) {
				set currentNode = ##class(alSYS.Script.iScript).getNode(rsNodes.Data("ID")) 
				set objNodeType = ##class(alSYS.Script.iScript).getNodeType(rsNodes.Data("NodeType")) 
				
				if (objNodeType.screenType = "SYSTEMINPUT") {   
					set strReturn = strReturn_" "_rsNodes.Data("Method")_"("
					if currentNode.Parameter.Count() '= 0 {
						for loopi = 1:1:currentNode.Parameter.Count() {
							set strReturn = strReturn_..GetParameterDescription(currentNode.Parameter.GetAt(loopi))
						}
					}
					set strReturn = strReturn_" )"
					
					
				} elseif (objNodeType.screenType= "COMMAND") {
					if (objNodeType.Type) = 1 {            // if or else
						set tablevel = tablevel + 1
					} elseif (objNodeType.Type = 2) {
						set tablevel = tablevel - 1
						set foundtab = $$$YES
					}
					set strReturn = strReturn_" "_$$$Text(objNodeType.OScreenText)
					
					
				} elseif (objNodeType.screenType= "USERINPUT") {
					set strReturn = strReturn_" User Input"
					
					
				} else {
					set strReturn = strReturn_" "_$$$Text(objNodeType.OScreenText)
				}
			}
		}
		
		set strReturn = strReturn_tabinsert
		set tabinsert = tab
		set strReturn = strReturn_delim
	}

 ///  TODO - USER INFOMATION logging
 //	set strReturn = strReturn_delim_"    COMPILED AT :"_$zdatetime($Horolog,1,1,0)
	set strReturn = strReturn_delim_"    GENERATED AT :"_$zdatetime($Horolog,1,1,0)
	
	quit strReturn
]]></Implementation>
</Method>

<Method name="SetUpMethod">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

The primary controlling method for compilation.<br>
This method calls each stage of the complation process on the
<code>alSYS.Script.data.dScriptMethod</code> data structure, and creates code
based on the data it contains. <br><br>

To generate scripts please see the <code>alSYS.Script</code> package.<br><br> 

<b>Params:</b><br>
 pMethod			The method we are playing with<br>
<b>Returns:</b><br>
 the MethodDefinition to be injected to the classdefinition <br>]]></Description>
<FormalSpec>pMethod:alSYS.Script.data.dScriptMethod</FormalSpec>
<ReturnType>%Dictionary.MethodDefinition</ReturnType>
<Implementation><![CDATA[
	set delim = $$$CRLF
	set tab   = $$$TAB
	
	set ..arrLogicLineInfo       = ""
	set ..arrLogicLineInfo       = ##class(%Library.ListOfDataTypes).%New()
	set ..arrParameters          = ##class(%Library.ListOfDataTypes).%New()
	set sc = ..arrLogicLineInfo.Clear()
	
	; FIXME : <GRF> Test for sc?
	set objCacheMeth             = ##class(%Dictionary.MethodDefinition).%New()
	set objCacheMeth.Name        = pMethod.MethodName
	set objCacheMeth.ReturnType  = pMethod.ReturnType   
	set objCacheMeth.ClassMethod = 1
	set implement = ""
	
	// sanity test not sure if this is needed .... as it won't compile @ a method level 
	
	// method wide variable checking
	set strheader = ..GlobValNumCheck(.pMethod)
	
	// scope stack placement (not sure here) 
	
	//Conditional Placement 
	set strFooter = ..CondPlacement(.pMethod)
	
	// replace variable 
	// tab
	set tablevel = 1
	
	for intLoopJ=1:1:..arrLogicLineInfo.Count() {
		/*
		set tabinsert = ""	
		set checktab = ..arrLogicLineInfo.GetAt(intLoopJ).GetAt(1)
		if checktab = "if " {
			set tablevel = tablevel + 1
		} elseif checktab = "} else {" {
			set tablevel = tablevel - 1
		}
		for loopTab = 1:1:tablevel {
			set tabinsert = tabinsert_tab
		}*/
		
		for loopi=1:1:(..arrLogicLineInfo.GetAt(intLoopJ)).Count() {
			set implement = implement_..arrLogicLineInfo.GetAt(intLoopJ).GetAt(loopi)
		}
		
		//if tablevel > 1 set tablevel = tablevel - 1
		set implement = implement_" "_delim
	}

	set strFormalspec = "" 
	for intLoopJ=1:1:..arrParameters.Count() {
		set strFormalspec = strFormalspec_..arrParameters.GetAt(intLoopJ)
		if intLoopJ '= ..arrParameters.Count() {
			set strFormalspec = strFormalspec_","
		}
	}

	set objCacheMeth.FormalSpec  = strFormalspec
	//LogicLines
	
	set implement = strheader_delim_"  "_implement_delim_" "_strFooter
	
	//for intPiece=1:1:$length(implement,delim) {
	//	set strFragment = $piece(implement,delim,intPiece)
	//	write !,strFragment
		do objCacheMeth.Implementation.Write(implement)    // (strFragment)
	//}
	set objCacheMeth.Description = ..setMethodDescrip(.pMethod)
	
	//do objCacheMeth.Implementation.Write(implement)

	quit objCacheMeth
]]></Implementation>
</Method>

<Method name="getSysteminput">
<Description><![CDATA[
<b>NOTE : NOT FOR EXTERNAL USE OUTSIDE PACKAGE : see iCompile for external Usage</b><br><br>

Gets the System input, i.e. from an interface class method. This may or may not
have either parameters or return values. <br><br>

<b>Params:</b><br>
	piNode			The Node we are playing with<br>
<b>Returns:</b><br>
	The system information expressed as Caché code <br>]]></Description>
<FormalSpec>piNode:alSYS.Script.data.dScriptNode</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set returnString = ""
	set classInfo = ""
	set scriptNode=piNode
	set pdef = ##class(%Library.MethodDefinition).%OpenId(piNode.Method)
	if pdef.ClassMethod = 1 { 
		set classInfo = "##class("_pdef.ClassName_")."
	} 
	
	set returnString = classInfo_pdef.Name_"("
	
	if piNode.Parameter.Count() '= 0 {
		for i=1:1:piNode.Parameter.Count() {
			set returnString = ..getSysteminput(piNode.Parameter.GetAt(i))
		}	
	}
	
	set returnString = returnString_")"
	quit returnString
]]></Implementation>
</Method>
</Class>
</Export>