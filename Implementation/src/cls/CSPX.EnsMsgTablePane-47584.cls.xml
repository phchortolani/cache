<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="CACHE" ts="2001-01-01 00:00:00">
<Class name="CSPX.EnsMsgTablePane">
<Description><![CDATA[
Specialized pane for displaying a list of messages.]]></Description>
<ClassType/>
<IncludeCode>Ensemble,EnsUI</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>CSPX.SQLQueryPane,Ens.Util.FunctionSet</Super>
<System>3</System>

<Parameter name="IDCOL">
<Description><![CDATA[
Name of ID Column if "More Data" link is to be offered ($NextID variable must be supported in CreateResultSet() also)]]></Description>
<Default>ID</Default>
</Parameter>


<Parameter name="TOPCOUNT">
<Description><![CDATA[
Number to use in SELECT TOP, if any. Use this to affect the SQL query optimizer. Set it substantially larger than MAXROWS if FilterRS() might invalidate some of the rows returned from SQL.]]></Description>
<Default>10000000</Default>
</Parameter>


<Property name="Tree">
<Description><![CDATA[
Parse tree of additional filter criteria terms
Top level nodes are OR'ed groups of terms; 2nd level nodes are AND'ed terms; 3d level are OR'ed conditions, 4th level are AND'ed conditions]]></Description>
<MultiDimensional>1</MultiDimensional>
</Property>


<Property name="BodyClasses">
<MultiDimensional>1</MultiDimensional>
</Property>


<Property name="SearchTables">
<MultiDimensional>1</MultiDimensional>
</Property>


<Property name="NumSearchTabConds">
<Type>%Integer</Type>
<MultiDimensional>1</MultiDimensional>
</Property>


<Property name="UseSTIN">
<Type>%Boolean</Type>
</Property>


<Property name="Hidden">
<MultiDimensional>1</MultiDimensional>
</Property>


<Property name="ValNodes">
<Description><![CDATA[
tree of flags for which nodes have published a value, so we can go back and fill in those that didn't]]></Description>
<MultiDimensional>1</MultiDimensional>
</Property>


<Property name="%colNames">
<MultiDimensional>1</MultiDimensional>
</Property>


<Property name="CurrRow">
<Type>%Integer</Type>
</Property>


<Method name="CreateResultSet">
<FormalSpec>&amp;pID:%String,&amp;pRS:%ResultSet</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK

	#; if not an explicit execute request (or history), skip it
	If ($G(^Ens.Debug("DelayQueries"))&&'$D(%request.Data("$EXEC",1))) {
		Set pRS = $$$NULLOREF
		Quit $$$OK
	}
	#; get request parms via object
	Set tFilterObj = ##class(CSPX.EnsMsgFilterForm).CreateInstance(.pID)
	Set tNextId=$G(%request.Data("$NextID",1))
 w:$G(^Ens.Debug("UtilEnsMessages","terms")) "terms count="_tFilterObj.%Terms.Count()_", name='"_tFilterObj.%Name_"',tNextId="_tNextId_"<br>"
	Set pID(2)=tFilterObj, pID(3)=tNextId

	&html<<input type='hidden' name='Status' value='#(tFilterObj.Status)#'>>
	&html<<input type='hidden' name='StartTime' value='#(tFilterObj.StartTime)#'>>
	&html<<input type='hidden' name='EndTime' value='#(tFilterObj.EndTime)#'>>
	&html<<input type='hidden' name='StartId' value='#(tFilterObj.StartId)#'>>
	&html<<input type='hidden' name='EndId' value='#(tFilterObj.EndId)#'>>
	&html<<input type='hidden' name='Type' value='#(tFilterObj.Type)#'>>
	&html<<input type='hidden' name='Source' value='#(tFilterObj.Source)#'>>
	&html<<input type='hidden' name='IsError' value='#(tFilterObj.IsError)#'>>
	&html<<input type='hidden' name='MaxRows' value='#(tFilterObj.MaxRows)#'>>
	&html<<input type='hidden' name='SortOrder' value='#(tFilterObj.SortOrder)#'>>
	&html<<input type='hidden' name='TimeFormat' value='#(tFilterObj.TimeFormat)#'>>
	&html<<input type='hidden' name='ColorBy' value='#(tFilterObj.ColorBy)#'>>
	&html<<input type='hidden' name='TermsStr' value='#(tFilterObj.TermsStr)#'>>

	Set pRS = ##class(%ResultSet).%New($$$CurrentClass_":Enumerate")
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExecuteResultSet">
<Description><![CDATA[
This method performs the actual execution of the ResultSet
This can be overridden by subclasses]]></Description>
<FormalSpec>pRS:%ResultSet,&amp;pID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If '$$$IsdefObject(pID(2)) w "No Object pID(2)" Quit tSC // !!!
	Quit pRS.Execute($G(pID(2)),$G(pID(3)),##this) ; FilterObj,NextId
]]></Implementation>
</Method>
<Query name="Enumerate">
<Description><![CDATA[
List the messages matching the given filter object, skipping to start from NextId if given.]]></Description>
<Type>%Query</Type>
<FormalSpec>FilterObj:CSPX.EnsMsgFilterForm,NextId:%String="&quot;,PaneObj:EnsMsgTablePane=$$$NULLOREF</FormalSpec>

<Parameter name="ROWSPEC" value="ID,TimeCreated,Session,Status,Error,Source"/>
</Query>


<Method name="EnumerateExecute">
<ClassMethod>1</ClassMethod>
<FormalSpec>&amp;qHandle:%Binary,pFilterObj:CSPX.EnsMsgFilterForm,pNextId:%String="&quot;,pPaneObj:EnsMsgTablePane=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define fixTime(%d)		$S(""=$ZStrip(%d,"*WC"):"",%d[" ":%d,%d["-":%d,1:$P($ZDT($H,3)," ")_" "_%d)

	Set:'$IsObject(pPaneObj) pPaneObj=..%New()
 	Set qHandle=0, qHandle("pane")=pPaneObj, qHandle("filt")=pFilterObj, qHandle("endTime")=$S('pFilterObj.Timeout:"",1:$zh+pFilterObj.Timeout)
	Set tSC=pPaneObj.parseTerms(pFilterObj)
	Set maxRows = pFilterObj.MaxRows
	Set:(+maxRows<=0) maxRows = 100
	Set pPaneObj.MaxResults = maxRows

	Set dateLen = 12
	Set:pFilterObj.TimeFormat'="" dateLen = pFilterObj.TimeFormat

	#; Only use TOP for Session-Start queries with a simple equality or no SearchTable condition
	Set select = "SELECT "_$S(..#TOPCOUNT&&((0=pFilterObj.Type)&&'(pPaneObj.NumSearchTabConds&&pPaneObj.UseSTIN)):"TOP "_..#TOPCOUNT, 1:"")_" head.ID As ID"
	Set from = " FROM Ens.MessageHeader head", aFrom = 0
	Set where = ""

	Set aSelect=1, aSelect(1)="head.ID"
	Set asName="head.%ID", pPaneObj.HiddenColumns=","_asName_",", pPaneObj.Hidden(asName)=""
	Set asName="%ID", pPaneObj.HiddenColumns=","_asName_",", pPaneObj.Hidden(asName)=""
	Set asName="ID", pPaneObj.Hidden(asName)=""
	Set aSelect($I(aSelect))="{fn RIGHT(%EXTERNAL(head.TimeCreated),"_dateLen_" )} As TimeCreated", aSelect(aSelect(aSelect))=""
	Set asName="head.TimeCreated", pPaneObj.HiddenColumns=pPaneObj.HiddenColumns_asName_",", pPaneObj.Hidden(asName)=""
	Set asName="TimeCreated", pPaneObj.Hidden(asName)=""
	Set aSelect($I(aSelect))="head.SessionId As Session", aSelect(aSelect(aSelect))=""
	Set asName="head.SessionId", pPaneObj.HiddenColumns=pPaneObj.HiddenColumns_asName_",", pPaneObj.Hidden(asName)=""
	Set asName="SessionId", pPaneObj.Hidden(asName)=""
	Set aSelect($I(aSelect))="head.Status As Status", aSelect(aSelect(aSelect))=""
	Set asName="head.Status", pPaneObj.HiddenColumns=pPaneObj.HiddenColumns_asName_",", pPaneObj.Hidden(asName)=""
	Set asName="Status", pPaneObj.Hidden(asName)=""
	Set aSelect($I(aSelect))="CASE head.IsError WHEN 1 THEN 'Error' ELSE 'OK' END As Error", aSelect(aSelect(aSelect))=""
	Set aSelect($I(aSelect))="head.SourceConfigName As Source", aSelect(aSelect(aSelect))=""
	Set asName="head.SourceConfigName", pPaneObj.HiddenColumns=pPaneObj.HiddenColumns_asName_",", pPaneObj.Hidden(asName)=""
	Set asName="SourceConfigName", pPaneObj.HiddenColumns=pPaneObj.HiddenColumns_asName_",", pPaneObj.Hidden(asName)=""
	Set:$$$CurrentClass'="CSPX.EnsMsgTablePane" asName="BodyClassname", pPaneObj.HiddenColumns=pPaneObj.HiddenColumns_asName_",", pPaneObj.Hidden(asName)=""

	Do pPaneObj.addSQLTerms(.aSelect,.aFrom,.xWhere)

	Set aSelect("head.ID")=1
 	Set:$D(aSelect("head.MessageBodyClassName As BodyClassname")) asName="head.MessageBodyClassName" ,pPaneObj.HiddenColumns=pPaneObj.HiddenColumns_asName_",", pPaneObj.Hidden(asName)=""
 	Set:$D(aSelect("head.MessageBodyId As BodyId")) asName="head.MessageBodyId" ,pPaneObj.HiddenColumns=pPaneObj.HiddenColumns_asName_",", pPaneObj.Hidden(asName)=""

	If (pFilterObj.Type = 0) {
		Set where = where_" AND head.SessionId = head.%ID"
	} ElseIf $Case(pFilterObj.Type, 1:1, 2:1, :0) {
		Set dtype = pFilterObj.TypeLogicalToDisplay(pFilterObj.Type)
		If (pFilterObj.Type = $$$eMessageTypeRequest) {
			Set dtypeTerm = ##class(Ens.MessageHeader).TypeLogicalToDisplay($$$eMessageTypeTerminate)
			Set where = where_" AND head.Type IN ('"_dtype_"','"_dtypeTerm_"')"
		} Else {
			Set where = where_" AND head.Type = '"_dtype_"'"
		}
	}
	If (pFilterObj.Status '= "") {
		Set dstatus = pFilterObj.StatusLogicalToDisplay(pFilterObj.Status)
		Set where = where_" AND head.Status = '"_dstatus_"'"
	}
	If (pFilterObj.Source '= "") {
		If (pFilterObj.Source [ "%") {
			Set where = where_" AND head.SourceConfigName LIKE '"_pFilterObj.Source_"'"
		} Else {
			Set where = where_" AND head.SourceConfigName = '"_pFilterObj.Source_"'"
		}
	}
	If (pFilterObj.IsError '= "") {
		Set where = where_" AND head.IsError = '"_pFilterObj.IsError_"'"
	}
	Set tStartTime=$$$fixTime(pFilterObj.StartTime), tEndTime=$$$fixTime(pFilterObj.EndTime)
	Set:""'=tEndTime&&($$$timeCmp(tStartTime,tEndTime)>0) tStartTime = pFilterObj.EndTime, tEndTime = pFilterObj.StartTime

	Set tStartId = pFilterObj.StartId, tEndId = pFilterObj.EndId
	Set:tStartId>tEndId&&(""'=tEndId) tStartId = pFilterObj.EndId, tEndId = pFilterObj.StartId
	If ""'=pNextId { ; support subsequent pages of message results
		If pFilterObj.SortOrder=2 { ; Descending
			Set:pNextId<tEndId||(""=tEndId) tEndId=pNextId }
		Else { Set:pNextId>tStartId tStartId=pNextId }
	}

	Set tTimeQ = 0
	If (tStartId '= "") {
		Set where = where_" AND head.%ID >= '"_tStartId_"'", tTimeQ=tTimeQ-1
	}
	If (tEndId '= "") {
		Set where = where_" AND head.%ID <= '"_tEndId_"'", tTimeQ=tTimeQ-1
	}
	If (pFilterObj.StartTime '= "") {
		Set where = where_" AND head.TimeCreated >= '"_tStartTime_"'", tTimeQ=tTimeQ+1
	}
	If (pFilterObj.EndTime '= "") {
		Set where = where_" AND head.TimeCreated <= '"_tEndTime_"'", tTimeQ=tTimeQ+1
	}
	Set order = " ORDER BY "_$S(tTimeQ>0:"head.TimeCreated"_$S(pFilterObj.SortOrder=2:" Desc", 1:"")_",head.ID",1:"head.ID")_$S(pFilterObj.SortOrder=2:" Desc", 1:"")

 d:$G(^Ens.Debug("UtilEnsMessages","tree"))&&'pFilterObj.Timeout pPaneObj.DumpTree()
	For i=1:1:aSelect { Set:'aSelect(aSelect(i)) select=select_", "_aSelect(i), aSelect(aSelect(i))=1 }
	For i=1:1:aFrom { Set:'aFrom(aFrom(i)) from=from_", "_aFrom(i), aFrom(aFrom(i))=1 }
	Set:""'=xWhere where=where_" AND "_xWhere
	
	Set:where'="" where = " WHERE "_$E(where,$L("AND ")+1,*)
 w:$G(^Ens.Debug("UtilEnsMessages","sql"))&&'pFilterObj.Timeout !,select_from_where_order,!
	Set tSQLRS = ##class(%ResultSet).%New()
	Set tSQLRS.RuntimeMode=pFilterObj.RuntimeMode
	Set tSC=tSQLRS.Prepare(select_from_where_order)  Quit:$$$ISERR(tSC) tSC
	Set tSC=tSQLRS.Execute()  Quit:$$$ISERR(tSC) tSC
	Set pPaneObj.CurrRow=0
	Set pPaneObj.%colNames = tSQLRS.GetColumnCount()
	For i = 1:1:pPaneObj.%colNames {
		Set pPaneObj.%colNames(i) = tSQLRS.GetColumnHeader(i)
	}
	Set qHandle("SQLRS")=tSQLRS, qHandle("basecols")=6, qHandle("rawrows")=0, qHandle=1
	Quit tSC
]]></Implementation>
</Method>

<Method name="EnumeratePrepare">
<ClassMethod>1</ClassMethod>
<FormalSpec>&amp;qHandle:%Binary,p1:%String,p2:%Integer,p3:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	/// As side effect of calling Prepare is to clear RS.HasInfo, which we want in this case.
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="EnumerateGetInfo">
<ClassMethod>1</ClassMethod>
<FormalSpec>colinfo:%List,parminfo:%List,idinfo:%List,qHandle:%Binary,extoption:%Integer=0,extinfo:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s:'($d(^oddCOM("CSPX.EnsMsgTablePane","q","Enumerate",21),clientinfo)#2)&&'$s($d(^(2),clientinfo)#2:$d(^oddCOM(clientinfo,"q","Enumerate",21),clientinfo)#2||($d(^oddDEF(clientinfo,"q","Enumerate",21),clientinfo)#2),1:$d(^oddDEF("CSPX.EnsMsgTablePane","q","Enumerate",21),clientinfo)#2) clientinfo=$g(^%qCacheObjectKey(1,"q",21))
	If clientinfo'="" {
		Set colinfo=$LG(clientinfo,1),parminfo=$LG(clientinfo,2),idinfo=$LG(clientinfo,3),extent=$LG(clientinfo,4)
		Set tLL=$LL(colinfo),tSQLRS=$G(qHandle("SQLRS")), tCC=$S($IsObject(tSQLRS):tSQLRS.GetColumnCount(),1:0)
		$$$ASSERT($G(qHandle("basecols"),tLL)=tLL)
		Set tPaneObj=$G(qHandle("pane"))
		If $IsObject(tPaneObj) {
			For i=tLL+1:1:tCC { Set tColName=tSQLRS.GetColumnName(i)  Continue:""=tColName
				Set:'$D(tPaneObj.Hidden(tColName)) colinfo=colinfo_$LB($LB(tColName,10,tColName))
			}
		}
		Set:$Get(extinfo) extinfo=$s($d(^oddCOM("CSPX.EnsMsgTablePane","q","Enumerate",38))#2:^(38),$d(^oddCOM($g(^(2),"CSPX.EnsMsgTablePane"),"q","Enumerate",38))#2:^(38),1:$s($d(^oddDEF($g(^oddCOM("CSPX.EnsMsgTablePane","q","Enumerate",2),"CSPX.EnsMsgTablePane"),"q","Enumerate",38))#2:^(38),1:$g(^%qCacheObjectKey(1,"q",38))))
		Quit 1
	}
	Quit $$GetInfo^%SYS.DynamicQuery("CSPX.EnsMsgTablePane","Enumerate",.colinfo,.parminfo,.idinfo,.qHandle,extoption,.extinfo)
]]></Implementation>
</Method>

<Method name="EnumerateFetch">
<ClassMethod>1</ClassMethod>
<FormalSpec>&amp;qHandle:%Binary,&amp;Row:%List,&amp;AtEnd:%Integer=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set $ZT="Trap", tSC=$$$OK, Row=""
	If 'qHandle Set AtEnd=1  Quit tSC
	Set tFilterObj=qHandle("filt"), tPaneObj=qHandle("pane")
	If ""'=$G(qHandle("done"))  Set AtEnd=1  Quit tSC
	Set AtEnd=0, tSQLRS=qHandle("SQLRS"), tCols=tPaneObj.%colNames
	While 1 {
		If tFilterObj.Timeout>0&&($zh>=qHandle("endTime")) {
			Set qHandle("done")="<to>", Row=$LB(qHandle("done")) For i=2:1:tCols { Set Row=Row_$LB("") } ; timed-out data flag row
			Quit
		}
		Set:qHandle qHandle=tSQLRS.Next(), qHandle("rawrows")=qHandle("rawrows")+1
		If 'qHandle {
			If ""'=..#TOPCOUNT&&(qHandle("rawrows")>=..#TOPCOUNT) {
				Set qHandle("done")="<tc>", Row=$LB(qHandle("done")) For i=2:1:tCols { Set Row=Row_$LB("") } ; timed-out data flag row
			} Else {
				Set AtEnd=1
			}
			Quit
		}
		Kill tPropVals
		Continue:'tPaneObj.filtPostRS(tFilterObj,tSQLRS,.tPropVals)
		
		Set tPaneObj.CurrRow = tPaneObj.CurrRow+1
		Set Row=""
		If tFilterObj.MaxRows>0&&(tPaneObj.CurrRow>tFilterObj.MaxRows) {
			#; check one extra row
			Set:'$D(tPropVals(..#IDCOL),tValue) tValue=tSQLRS.GetData(1)
			Set AtEnd=1, qHandle("done")="<md>", Row=$LB(tValue,qHandle("done")) For i=3:1:tCols { Set Row=Row_$LB("") } ; more-data flag row
			Quit
		}
		For i=1:1:tCols { Set tColName=tPaneObj.%colNames(i)  Continue:i>qHandle("basecols")&&$D(tPaneObj.Hidden(tColName))
			Set:'$D(tPropVals(tColName),tValue) tValue=tSQLRS.GetData(i)
			Set Row=Row_$ListBuild(tValue)
		}
		Quit
	}
Exit
	Quit tSC
Trap
 	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="EnumerateClose">
<ClassMethod>1</ClassMethod>
<FormalSpec>&amp;qHandle:%Binary</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill qHandle
 	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DumpTree">
<FormalSpec>pWeb=1,level=1,tNode=1</FormalSpec>
<Implementation><![CDATA[
	Set iChild=$P(tNode,",",level)
	Set val=$G(@("..Tree("_tNode_")"))
	w !,$S(pWeb:"<br>",1:"") For p=1:1:level { w "  " } w "Level "_level_" ("_iChild_")"  w:""'=val " = "_val
	Set k="" For { Set k=$O(@("..Tree("_tNode_","""_k_""")"),1,val) Quit:""=k  Continue:+k=k
		w !,$S(pWeb:"<br>",1:"") For p=1:1:level { w $S(pWeb:"&nbsp;",1:"  ") } w " "_k_"="_val
	}
	Set k="" For { Set k=$O(@("..Tree("_tNode_","""_k_""")")) Quit:""=k  Continue:+k'=k
		do ..DumpTree(pWeb, level+1,tNode_","_k)
	}
]]></Implementation>
</Method>

<Method name="parseTerms">
<Description><![CDATA[
Parse the list of filter terms and conditions into a local tree]]></Description>
<FormalSpec>pFilterObj:CSPX.EnsMsgFilterForm</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill ..Tree  New %tree  Set ..NumSearchTabConds=0
	Set tNode="1,1",tLevel=2,%tree(1,"type")="", ..BodyClasses=0, ..SearchTables=0
	For i=1:0 { Set tTerm=pFilterObj.NextTerm(.i)  Quit:'$IsObject(tTerm)
	 w:$G(^Ens.Debug("UtilEnsMessages","terms"))&&'pFilterObj.Timeout !,"<br>next "_i_" = "_tTerm.Type
		If tTerm.Type="OR" {
			Set tParentType=$$parentNodeType()
			If "OR"= tParentType {
				do openNode()
			} ElseIf "AND"=tParentType {
				do insertGrandparent("OR")
			} Else {
				do insertParent("OR")
			}
		} ElseIf "AND"=$$parentNodeType() || $$nodeIsOpen() {
			do addTerm()
		} Else {
			do insertParent("AND")
			do addTerm()
		}
	}
	Kill %tree(1,"type")  Merge ..Tree=%tree(1)
	Do ..reduceTree()
	#; IN is needed in all cases except simple equality condition to generate correct boolean combinations
	Set ..UseSTIN=(..NumSearchTabConds>1 || (..NumSearchTabConds=1 && (("="'=$E(..NumSearchTabConds(1))) || (""=$E(..NumSearchTabConds(1),2,*)))))
	Quit $$$OK

addTerm()
	Set bkLevel=tLevel
	If "Header Field"'=tTerm.Type {
		If "AND"'=$$parentNodeType() {
			do insertParent("AND")
		} Else {
			do openNode()
		}
		Set @("%tree("_tNode_",""type"")")=tTerm.Type
		Set @("%tree("_tNode_",""class"")")=tTerm.SourceClass
		If tTerm.Type="VDoc SearchTable Field" {
			Set:'$D(..SearchTables(tTerm.SourceClass)) ..SearchTables(tTerm.SourceClass)="", ..SearchTables=..SearchTables+1
		} ElseIf tTerm.Type'="Header Field" {
			Set:'$D(..BodyClasses(tTerm.SourceClass)) ..BodyClasses(tTerm.SourceClass)="", ..BodyClasses=..BodyClasses+1
		}
	} 
	For j=1:1:tTerm.Conditions.Count() { Set tCond=tTerm.Conditions.GetAt(j)  Continue:'$IsObject(tCond)||(""=tCond.Prop)
		If $Case(tCond.JoinOp, "IF":1, "":1, $$parentNodeType():1, :0) {
			do addCond()
		} Else {
			do insertParent(tCond.JoinOp)
			do addCond()
		}
	}
	Set tNode=$P(tNode,",",1,bkLevel)
	Set tLevel=bkLevel
	Quit
addCond()
	do openNode()
	Set @("%tree("_tNode_",""type"")")=tTerm.Type
	Set @("%tree("_tNode_",""class"")")=tTerm.SourceClass
	Set @("%tree("_tNode_",""prop"")")=tCond.Prop
	Set @("%tree("_tNode_",""op"")")=tCond.Op
	Set @("%tree("_tNode_",""val"")")=tCond.OpVal
	Set:tTerm.Type="VDoc SearchTable Field"&&'tTerm.Disabled ..NumSearchTabConds=..NumSearchTabConds+1, ..NumSearchTabConds(..NumSearchTabConds)=tCond.Op_tCond.OpVal
	Quit
parentNodeType()
	Quit @("%tree("_$P(tNode,",",1,tLevel-1)_",""type"")")
nodeIsOpen()
	Quit '$D(@("%tree("_tNode_")"))
openNode()
	Set:'$$nodeIsOpen() $P(tNode,",",tLevel) = 1+$P(tNode,",",tLevel)
	Quit
insertParent(type)
	Set tNewNode=tNode_",1"
	Merge tSub=@("%tree("_tNode_")")  Kill @("%tree("_tNode_")")  Merge @("%tree("_tNewNode_")")=tSub  Kill tSub
	Set @("%tree("_tNode_",""type"")")=type
	Set tNode=tNode_",1"
	Set tLevel=tLevel+1
	do openNode()
	Quit
insertGrandparent(type)
	Set tLevel=tLevel-1, tNode=$P(tNode,",",1,tLevel)
	do insertParent(type)
	Quit
]]></Implementation>
</Method>

<Method name="reduceTree">
<Description><![CDATA[
Reduce Terms tree if possible by eliminating common terms]]></Description>
</Method>

<Method name="addSQLTerms">
<Description><![CDATA[
Take from Terms tree whatever is best added to the SQL statement
Return 0 means no SQL for node, 1 means node was partly done in SQL, 2 means node was completely accounted for in SQL]]></Description>
<FormalSpec>&amp;aSelect,&amp;aFrom,*xWhere,level=1,tNode="1&quot;</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set xWhere=""
	Quit:'$D(..Tree) 2
	Set tType=@("..Tree("_tNode_",""type"")")
	If $Case(tType,"AND":1,"OR":1,:0) {
		Set (tSqlEmpty,tSqlSure)=1,(tWhere,k,tGiveUp)=""
		For { Set k=$O(@("..Tree("_tNode_","""_k_""")")) Quit:""=k  Continue:+k'=k
			Set tSql=..addSQLTerms(.aSelect, .aFrom, .tWhere, level+1, tNode_","_k)
			Continue:tGiveUp
			Set:tSql<2 tSqlSure=0
			If tType="AND" {
				Set:""'=tWhere xWhere=xWhere_$S(tSqlEmpty:"(",1:" AND ")_tWhere, tSqlEmpty=0
			} ElseIf ""'=tWhere {
				Set xWhere=xWhere_$S(tSqlEmpty:"(",1:" OR ")_tWhere, tSqlEmpty=0
			} Else {
		w:'tSql !,"Assert: GOT SQL 0 in OR for empty Where"
				Set xWhere="", (tSqlEmpty,tGiveUp)=1  ; give up - no point in testing other OR conditions if this one is 1, but still traverse tree to identify all fields
			}
		}
		Set:'tSqlEmpty xWhere=xWhere_")"
		Set tSql=$S(tSqlEmpty:0, 1:1+tSqlSure)
		Set:tSql @("..Tree("_tNode_",""sqldone"")")=tSql
		Quit tSql
	}
	#; It's a leaf node - do it in SQL if possible
	Set tClass=@("..Tree("_tNode_",""class"")")
	Set tProp=$G(@("..Tree("_tNode_",""prop"")"))
	Set tSql=0
	Set tOp=$G(@("..Tree("_tNode_",""op"")"))
	If tType="Header Field" {
		Set xWhere=$$opWhere(tOp,"head."_tProp,@("..Tree("_tNode_",""val"")"))
		Set tSql=$S(""=xWhere:1,1:2)
		Set aSelect($I(aSelect))="head."_tProp, aSelect(aSelect(aSelect))=":"_tNode
	} ElseIf tType="Body Property" {
		Set asName=$S(..BodyClasses=1:"Body", 1:$TR(tClass,".%","__"))_"_"_$S(""=tProp:"ID", 1:$TR(tProp,"%","_")), @("..Tree("_tNode_",""asname"")")=asName
		If ""=tProp {
			Set tSql=2, aFrom($I(aFrom))=$$$ClassSQLTable(tClass), aFrom(aFrom(aFrom))=":"_tNode
			Set xWhere="head.MessageBodyClassName='"_tClass_"' AND head.MessageBodyId="_$$$ClassSQLTable(tClass)_".%ID"
			Set aSelect($I(aSelect))="head.MessageBodyClassName As BodyClassname", aSelect(aSelect(aSelect))=":"_tNode
			Set aSelect($I(aSelect))="head.MessageBodyId As BodyId", aSelect(aSelect(aSelect))=":"_tNode
			Set:'$D(..Hidden(asName)) ..HiddenColumns=..HiddenColumns_asName_",", ..Hidden(asName)=""
			Set aSelect($I(aSelect))=$$$ClassSQLTable(tClass)_".%ID As "_asName, aSelect(aSelect(aSelect))=":"_tNode
		} Else {
			Set xWhere=$$opWhere(tOp,$$$ClassSQLTable(tClass)_"."_tProp,@("..Tree("_tNode_",""val"")"))
			Set tSql=$S(""=xWhere:1,1:2)
			Set aSelect($I(aSelect))=$$$ClassSQLTable(tClass)_"."_tProp_" As "_asName, aSelect(aSelect(aSelect))=":"_tNode
		}
	} ElseIf tType="VDoc SearchTable Field" {
		Set tDocClass=$zobjclassmethod(tClass,"%GetParameter","DOCCLASS"), @("..Tree("_tNode_",""docclass"")")=tDocClass
		Set tSearchTableSupertable=$$$ClassSQLTable(##class(Ens.VDoc.SearchTableGenerator).GetExtentSuperclass(tClass))
		Set tValue=$G(@("..Tree("_tNode_",""val"")"))
		If ""=tProp {
			If ..UseSTIN {
				Set tSql=2
				Set xWhere="0<>Ens_VDoc.IsASub(head.MessageBodyClassName,'"_tDocClass_"')"
			} Else {
				Set tSql=2, aFrom($I(aFrom))=tSearchTableSupertable, aFrom(aFrom(aFrom))=":"_tNode
				Set xWhere="0<>Ens_VDoc.IsASub(head.MessageBodyClassName,'"_tDocClass_"') AND head.MessageBodyId = "_tSearchTableSupertable_".DocId"
			}
			Set aSelect($I(aSelect))="head.MessageBodyClassName As BodyClassname", aSelect(aSelect(aSelect))=":"_tNode
		} Else {
			Set tPropId=##class(Ens.VDoc.SearchTableGenerator).getPropId(tClass,tProp,.tPropType,.tStoreNulls)
			Set @("..Tree("_tNode_",""propid"")")=tPropId
			Set @("..Tree("_tNode_",""proptype"")")=tPropType
			Set @("..Tree("_tNode_",""storenulls"")")=tStoreNulls
			Set tValue=$Case(tPropType
						,"Boolean":$Case($ZCVT(tValue,"L"),"true":1,"yes":1,"on":1,:''tValue)
						,"Integer":+tValue\1
						,"Numeric":+tValue
						,"String:CaseInsensitive":$ZCVT(tValue,"L")
						,:tValue)
			Set @("..Tree("_tNode_",""val"")")=tValue
			Set asName=$S(..SearchTables=1:"SchTbl", 1:$TR(tDocClass,".%","__"))_"_"_$TR(tProp,"%:.-","____"), @("..Tree("_tNode_",""asname"")")=asName
			If ..UseSTIN {
				#; For negative ops, use NOT IN of the corresponding positive op. This allows exclusion of rows with multiple values where one value matches the negative op
				Set tInv=$$getInverseOp(tOp)  Set:""'=tInv tOp=tInv
				If tOp '= "=" || $L(tValue) {
					Set xSubWhere=$$opWhere(tOp,"SchTbl.PropValue",tValue)
					Set xWhere="head.MessageBodyId"_$S(tOp=tInv:" NOT",1:"")_" IN (SELECT SchTbl.DocID FROM "_tSearchTableSupertable_" SchTbl WHERE "_
						"SchTbl.PropId = "_tPropId_$S(""=xSubWhere:"", 1:" AND "_xSubWhere)_")"
				} Else {
					#; For =/!= on empty value, use a COUNT subquery to include or exclude rows where no SearchTable property exists. This allows exclusion of these from inverse op queries if desired, by ANDing prop!="" with the negative op condition
					Set xSubWhere=$$opWhere("!=","SchTbl.PropValue",tValue)
  					Set xWhere="0"_$S(tOp=tInv:"<>",1:"=")_"(SELECT COUNT(*) FROM "_tSearchTableSupertable_" SchTbl WHERE SchTbl.DocID = head.MessageBodyId AND "_
						"SchTbl.PropId = "_tPropId_$S(""=xSubWhere:"", 1:" AND "_xSubWhere)_")"
				}
				Set tSql=$S(""=xSubWhere:1,1:2)
				Set aSelect($I(aSelect))="(SELECT LIST(PropValue) FROM "_tSearchTableSupertable_" WHERE head.MessageBodyId = DocId And PropId="_tPropId_") As "_asName, aSelect(aSelect(aSelect))=":"_tNode
			} Else {
				Set asName2=$S(..SearchTables=1:"SchTbl", 1:$TR(tDocClass,".%","__"))_"_PropId", @("..Tree("_tNode_",""asname2"")")=asName2
				Set xSubWhere=$$opWhere(tOp,tSearchTableSupertable_".PropValue",tValue)
				Set xWhere=tSearchTableSupertable_".PropId = "_tPropId  	Set:""'=xSubWhere xWhere=xWhere_" AND "_xSubWhere
				Set tSql=$S(""=xSubWhere:1,1:2)
				Set aSelect($I(aSelect))="(SELECT LIST(PropValue) FROM "_tSearchTableSupertable_" WHERE head.MessageBodyId = DocId And PropId="_tPropId_") As "_asName, aSelect(aSelect(aSelect))=":"_tNode
				Set:'$D(..Hidden(asName2)) ..HiddenColumns=..HiddenColumns_asName2_",", ..Hidden(asName2)=""
				Set aSelect($I(aSelect))=tSearchTableSupertable_".PropId As "_asName2, aSelect(aSelect(aSelect))=":"_tNode
			}
		}
	} ElseIf $Case(tType,"VDoc Property Path":1, "VDoc Segment Field":1, :0) {
		If ""=tProp {
			Set tSql=2, aFrom($I(aFrom))=$$$ClassSQLTable(tClass), aFrom(aFrom(aFrom))=":"_tNode
			Set xWhere="head.MessageBodyClassName='"_tClass_"' AND head.MessageBodyId="_$$$ClassSQLTable(tClass)_".%ID"
			Set aSelect($I(aSelect))="head.MessageBodyClassName As BodyClassname", aSelect(aSelect(aSelect))=":"_tNode
			Set aSelect($I(aSelect))="head.MessageBodyId As BodyId", aSelect(aSelect(aSelect))=":"_tNode
			Set asName=$S(..BodyClasses=1:"Body", 1:$TR(tClass,".%","__"))_"_ID", @("..Tree("_tNode_",""asname"")")=asName
			Set:'$D(..Hidden(asName)) ..HiddenColumns=..HiddenColumns_asName_",", ..Hidden(asName)=""
			Set aSelect($I(aSelect))=$$$ClassSQLTable(tClass)_".%ID As "_asName, aSelect(aSelect(aSelect))=":"_tNode
		} Else {
			Set tSql=1
			Set f=$F(tProp,":{") Set:'f&&(tType="VDoc Segment Field") f=$F(tProp,":[")
			If f {
				Set tPropPath=$E(tProp,f-1,*)
			} ElseIf ":"=$E(tProp,*) {
				Set tPropPath=""
			} Else {
				Set:":"=$E(tProp) $E(tProp)=""
				Set tPropPath=tProp
			}
			Set cMatch=$Case($E(tPropPath),"[":"]","{":"}",:"")
			If ""'=cMatch {
				Set $E(tPropPath)=""
				Set:cMatch=$E(tPropPath,*) $E(tPropPath,$L(tPropPath))=""
			}
			Set tProp=tPropPath ; don't put docType or {} or [] in asName for column
			Set asName=$S(..BodyClasses=1:"Body", 1:$TR(tClass,".%","__"))_"_"_$TR(tProp,"%:.-()","______"), @("..Tree("_tNode_",""asname"")")=asName
			Set aSelect($I(aSelect))="null As "_asName, aSelect(aSelect(aSelect))=":"_tNode
		}
		Set @("..Tree("_tNode_",""asname"")")=asName
	}
	Set:tSql @("..Tree("_tNode_",""sqldone"")")=tSql
	Quit tSql
	
opWhere(oper,prop,val)
	Set oper=$S(""'=val:
			$Case(oper
				, "=":oper, "!=":"(@p <> @v OR @p Is Null)"
				, ">":oper, ">=":oper
				, "<":oper, "<=":oper
				, "Contains":"[", "DoesNotContain":"NOT ["
				, "Matches":"0<>Ens_FuncSet.Matches(,)", "DoesNotMatch":"0<>Ens_FuncSet.DoesNotMatch(,)"
				, "In":"IN", "NotIn":"NOT IN"
				, "StartsWith":"%startswith", "DoesNotStartWith":"NOT %startswith"
				, "Like":"LIKE", "NotLike":"NOT LIKE"
				, "InFile":"0<>Ens_Util.InFile(,)", "NotInFile":"0<>Ens_Util.NotInFile(,)"
				, :"")
			,1:$Case(oper
				, "=":"(@p = '' OR @p Is Null)", "!=":"(@p <> '' AND NOT @p IS Null)"
				, ">":oper, ">=":oper
				, "<":oper, "<=":oper
				, "Contains":"[", "DoesNotContain":"NOT ["
				, "Matches":"0<>Ens_FuncSet.Matches(,)", "DoesNotMatch":"0<>Ens_FuncSet.DoesNotMatch(,)"
				, "In":"IN", "NotIn":"NOT IN"
				, "StartsWith":"%startswith", "DoesNotStartWith":"NOT %startswith"
				, "Like":"LIKE", "NotLike":"NOT LIKE"
				, "InFile":"0<>Ens_FuncSet.InFile(,)", "NotInFile":"0<>Ens_FuncSet.NotInFile(,)"
				, :""))
	Quit:(""=oper) ""
	If "LIKE"=$E(oper,*-3,*)&&("%%"=$E(val,*-2,*-1)) { Set val="'"_$E(val,1,*-3)_"' ESCAPE '"_$E(val,*)_"'" }
	ElseIf "IN"=$E(oper,*-1,*) { If ",,"=$E(val,*-2,*-1) { Set sep=$E(val,*), val=$E(val,1,*-3) } Else { Set sep="," } Set nval="" For in=1:1:$L(val,sep) { Set inp=$P(val,sep,in), nval=nval_",'"_inp_"'" } Set val="("_$E(nval,2,*)_")" }
	Else { Set val="'"_val_"'" }
	Quit $S(oper["@p":$$replace^EnsUtil(oper,"@p",prop,"@v",val)
			, "NOT "=$E(oper,1,4):"NOT "_prop_" "_$E(oper,5,*)_" "_val
			, "(,)"=$E(oper,*-2,*):$P(oper,",")_prop_","_val_")"
			, 1:prop_" "_oper_" "_val
			)
getInverseOp(oper)
		Quit $Case(oper
				, "!=":"="
				, "DoesNotContain":"Contains"
				, "DoesNotMatch":"Matches"
				, "NotIn":"In"
				, "DoesNotStartWith":"StartsWith"
				, "NotLike":"Like"
				, "NotInFile":"InFile"
				, :"")
]]></Implementation>
</Method>

<Method name="FilterPostRS">
<Description><![CDATA[
Apply additional filter criteria to determine whether to display the current row returned by the ResultSet.
Return value 1 means display the current row.
pPropVals is an array of calculated property values to extend the display list if the filter passes.]]></Description>
<CodeMode>expression</CodeMode>
<FormalSpec>pRS:%ResultSet,&amp;pPropVals,level=1,tNode="1&quot;,pInOR=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[1
]]></Implementation>
</Method>

<Method name="filtPostRS">
<Description><![CDATA[
Apply additional filter criteria to determine whether to display the current row returned by the ResultSet.
Return value 1 means display the current row.
pPropVals is an array of calculated property values to extend the display list if the filter passes.]]></Description>
<FormalSpec>pFilterObj:CSPX.EnsMsgFilterForm,pRS:%ResultSet,&amp;pPropVals,level=1,tNode="1&quot;,pInOR=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	//M ^data($I(^data))=pRS.Data //!!!
	//S:'$D(..Tree)||('pInOR&&(2=$G(@("..Tree("_tNode_",""sqldone"")")))) ^Dbg($I(^Dbg),"evalPre",tNode)=$G(pRS.Data("BodyId"))_" = "_pInOR_" / "_$G(@("..Tree("_tNode_",""sqldone"")"))
	Kill:1=level ..ValNodes
	Quit:'$D(..Tree)||('pInOR&&(2=$G(@("..Tree("_tNode_",""sqldone"")")))) 1
	Set tType=@("..Tree("_tNode_",""type"")")
	If $Case(tType, "AND":1, "OR":1, :0) {
		Set tVal=1, tOR=(tType="OR")
		Set k="" For { Set k=$O(@("..Tree("_tNode_","""_k_""")")) Quit:""=k  Continue:+k'=k
	//S:'tOR&&(2=$G(@("..Tree("_tNode_","_k_",""sqldone"")"))) ^Dbg($I(^Dbg),"evalSkip",tNode)=pRS.Data("BodyId")_" = "_tOR_" / "_$G(@("..Tree("_tNode_","_k_",""sqldone"")"))
			Continue:'pInOR&&'tOR&&(2=$G(@("..Tree("_tNode_","_k_",""sqldone"")")))
			Set tVal=..filtPostRS(pFilterObj, pRS, .pPropVals, level+1, tNode_","_k, pInOR||tOR)
	//S ^Dbg($I(^Dbg),"evalOp",tNode)=pRS.Data("BodyId")_" = "_tVal_" / "_tType
			#; skip evaluation of further peer nodes if the outcome for this level is now foreordained
			If ('tOR&&'tVal)||(tOR&&tVal) Set @("..ValNodes("_tNode_","_k_")")=1  Quit
		}
	w:$G(^Ens.Debug("UtilEnsMessages","postrs"))&&'pFilterObj.Timeout&&(1=level)&&'tVal !,"<br>Skipping row "_pRS.Data("ID"),!
		Do:1=level&&tVal&&$D(..ValNodes) finishVals()
		Quit tVal
	}
	#; It's a leaf node - evaluate it as Object if not already done in SQL
	Set tClass=@("..Tree("_tNode_",""class"")")
	Set tProp=$G(@("..Tree("_tNode_",""prop"")"))
	Set:""'=tProp tValue=@("..Tree("_tNode_",""val"")")
	If tType="Header Field" {
		Set tPropVal=pRS.Data(tProp)  Set:tPropVal=$C(0) tPropVal="" ; don't distinguish Null from Empty
	} ElseIf tType="Body Property" {
		Set asName=@("..Tree("_tNode_",""asname"")")
		If ""=tProp {
			Quit (pRS.Data("BodyClassname")=tClass) && (pRS.Data("BodyId")=pRS.Data(asName))
		} Else {
			Set tPropVal=pRS.Data(asName)  Set:tPropVal=$C(0) tPropVal="" ; don't distinguish Null
		}
	} ElseIf tType="VDoc SearchTable Field" {
		Set tDocClass=@("..Tree("_tNode_",""docclass"")")
		If ""=tProp {
			Set tDocClass=@("..Tree("_tNode_",""docclass"")")
			Quit $zobjclassmethod(pRS.Data("BodyClassname"),"%IsA",tDocClass)
		} Else {
			Set tPropId=@("..Tree("_tNode_",""propid"")")
			Set asName2=@("..Tree("_tNode_",""asname2"")")
			Quit:tPropId'=pRS.Data(asName2) 0 ; no PropId, i.e no SearchTable entry for this record
			Set asName=@("..Tree("_tNode_",""asname"")")
			Set tPropVal=pRS.Data(asName)  Set:tPropVal=$C(0) tPropVal="" ; don't distinguish Null
			Set tPropType=@("..Tree("_tNode_",""proptype"")")
		}
	} ElseIf $Case(tType,"VDoc Property Path":1, "VDoc Segment Field":1, :0) {
		Set asName=@("..Tree("_tNode_",""asname"")")
		Quit:""=tProp (pRS.Data("BodyClassname")=tClass) && (pRS.Data("BodyId")=pRS.Data(asName))

		Set f=$F(tProp,":{") Set:'f&&(tType="VDoc Segment Field") f=$F(tProp,":[")
		If f {
			Set tDocType=$E(tProp,1,f-3), tPropPath=$E(tProp,f-1,*)
		} ElseIf ":"=$E(tProp,*) {
			Set tDocType=$E(tProp,*-1), tPropPath=""
		} Else {
			Set:":"=$E(tProp) $E(tProp)=""
			Set tPropPath=tProp, tDocType=""
		}
		Set cMatch=$Case($E(tPropPath),"[":"]","{":"}",:"")
		If ""'=cMatch {
			Set $E(tPropPath)=""
			Set:cMatch=$E(tPropPath,*) $E(tPropPath,$L(tPropPath))=""
		}
		Quit:""=tPropPath 1

		Set tObj=$zobjclassmethod(tClass,"%OpenId",pRS.Data("BodyId"))
		Quit:'$IsObject(tObj) 0
		Set tSC=$$$OK
		If tType="VDoc Property Path" {
			Do:""'=tObj.DocType tObj.GetValuesArray(tPropPath,,.tArray,.tSC)
			If tDocType'=tObj.DocType && (tDocType'="") && '$D(tArray) {
				Set tObj.DocType=tDocType ; try again with query's DocType value
				Do tObj.GetValuesArray(tPropPath,,.tArray,.tSC)
			}
		} Else {
			Do tObj.FindSegmentValuesArray(tPropPath,,.tArray,.tSC,tDocType)
		}
		If $$$ISOK(tSC) { Set tPropVal="" } Else { Set:'$D(tArray) tArray=0  Set tPropVal="<"_$TR($$$StatusDisplayString(tSC),"<>","{}")_">" }
		Quit:'$D(tArray) $$match("")
		Set (tMatch,neg)=$$isNegativeOp()
		Set (k,n)="" For { Set k=$O(tArray(k))  Quit:""=k
			Set:tMatch=neg tMatch=$$match(k)
			Quit:tMatch'=neg&&neg
			Set tPropVal=tPropVal_"<"_k_">", n=n+1
		} Set:n=1 tPropVal=$E(tPropVal,2,*-1)
		Set pPropVals(asName)=tPropVal
		Quit ''tMatch
	}
	Quit $$match(tPropVal)
match(propVal)
		Quit $Case(@("..Tree("_tNode_",""op"")")
				, "=":propVal=tValue, "!=":propVal'=tValue
				, ">":propVal>tValue, ">=":propVal>=tValue
				, "<":propVal<tValue, "<=":propVal<=tValue
				, "Contains":..Contains(propVal,tValue), "DoesNotContain":..DoesNotContain(propVal,tValue)
				, "Matches":..Matches(propVal,tValue),"DoesNotMatch":..DoesNotMatch(propVal,tValue)
				, "In":..In(propVal,tValue), "NotIn":..NotIn(propVal,tValue)
				, "StartsWith":..StartsWith(propVal,tValue), "DoesNotStartWith":..DoesNotStartWith(propVal,tValue)
				, "Like":..Like(propVal,tValue), "NotLike":..NotLike(propVal,tValue)
				, "InFile":..InFile(propVal,tValue),"NotInFile":..NotInFile(propVal,tValue)
				, :1) ; default- if filter not supported, don't exclude
isNegativeOp()
		Quit $Case(@("..Tree("_tNode_",""op"")")
				, "=":0, "!=":1
				, ">":0, ">=":0
				, "<":0, "<=":tPropVal<=0
				, "Contains":0, "DoesNotContain":1
				, "Matches":0, "DoesNotMatch":1
				, "In":0, "NotIn":1
				, "StartsWith":0, "DoesNotStartWith":1
				, "Like":0, "NotLike":1
				, "InFile":0,"NotInFile":1
				, :0)
finishVals()
	Set gref0=$Name(@("..ValNodes")), gref=gref0
	For { Set gref=$Query(@gref) Quit:gref=""
		Set tNode=$E(gref,$L(gref0)+1,*-1)  Quit:tNode=""
		Set k=$P(tNode,",",$L(tNode,",")), tNode=$E(tNode,1,*-$L(k)-1)
		Do finishNode(tNode,k)
	}
	Quit
finishNode(pNode,k)
	For { Set k=$O(@("..Tree("_pNode_","""_k_""")")) Quit:""=k  Continue:+k'=k  Set node=pNode_","_k
		Set tType=@("..Tree("_node_",""type"")")
		If $Case(tType, "AND":1, "OR":1, :0) {
			Do finishNode(node,"")
		} Else {
			#; It's a leaf node - evaluate it as Object if not already done in SQL
			Set tClass=@("..Tree("_node_",""class"")")
			Set tProp=$G(@("..Tree("_node_",""prop"")"))
			Set:""'=tProp tValue=@("..Tree("_node_",""val"")")
			If $Case(tType,"VDoc Property Path":1, "VDoc Segment Field":1, :0) {
				Set asName=@("..Tree("_node_",""asname"")")
				Continue:""=tProp||(""'=$G(pPropVals(asName)))

				Set f=$F(tProp,":{") Set:'f&&(tType="VDoc Segment Field") f=$F(tProp,":[")
				If f {
					Set tDocType=$E(tProp,1,f-3), tPropPath=$E(tProp,f-1,*)
				} ElseIf ":"=$E(tProp,*) {
					Set tDocType=$E(tProp,*-1), tPropPath=""
				} Else {
					Set:":"=$E(tProp) $E(tProp)=""
					Set tPropPath=tProp, tDocType=""
				}
				Set cMatch=$Case($E(tPropPath),"[":"]","{":"}",:"")
				If ""'=cMatch {
					Set $E(tPropPath)=""
					Set:cMatch=$E(tPropPath,*) $E(tPropPath,$L(tPropPath))=""
				}
				Continue:""=tPropPath
		
				Set tObj=$zobjclassmethod(tClass,"%OpenId",pRS.Data("BodyId"))
				Continue:'$IsObject(tObj)
			
				If tType="VDoc Property Path" {
					Do tObj.GetValuesArray(tPropPath,,.tArray,.tSC)
					If tDocType'=tObj.DocType && (tDocType'="") && '$D(tArray) {
						Set tObj.DocType=tDocType ; try again with query's DocType value
						Do tObj.GetValuesArray(tPropPath,,.tArray,.tSC)
					}
				} Else {
					Do tObj.FindSegmentValuesArray(tPropPath,,.tArray,.tSC,tDocType)
				}
				If $$$ISOK(tSC) { Set tPropVal="" } Else { Set:'$D(tArray) tArray=0  Set tPropVal="<"_$TR($$$StatusDisplayString(tSC),"<>","{}")_">" }
				Continue:'$D(tArray)
				Set (k,n)="" For { Set k=$O(tArray(k))  Quit:""=k
					Set tPropVal=tPropVal_"<"_k_">", n=n+1
				} Set:n=1 tPropVal=$E(tPropVal,2,*-1)
				Set pPropVals(asName)=tPropVal
			}
			Quit
		}
	}
]]></Implementation>
</Method>

<Method name="DrawHEAD">
<FormalSpec>pInstance:PageInstance</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#; call default behavior
	Set tSC = ##super(pInstance)
	If $$$ISERR(tSC) {
		&html<<!-- error in DrawHEAD method -->>
		Quit tSC
	}
	Set msgOnlyTwo = $$$LocalizeText("Ensemble","msgOnlyTwo","Please select exactly two messages")
	Set msgNoneChecked = $$$LocalizeText("Ensemble","msgNoneChecked","Please select messages to resend")

	#; add extra js functions
	Merge tID = pInstance.IDValues
	
	&html<<script language="JavaScript">
function compareMessages()
{
	// count # of selected messages
	var count = 0;
	var id1 = '';
	var id2 = '';
	
	if (cbEnabled) {
		for (var i = 1; i <= numRows; i++) {
			cb = self.document.getElementById("cb_"+i);
			if (cb && cb.checked) {
				count++;
				if (count == 1) {
					id1 = cb.value;
				}
				else if (count == 2) {
					id2 = cb.value;
				}
			}
		}
	}
	
	if (count != 2) {	
		alert('#(msgOnlyTwo)#');
	}
	else {
		// goto to Msg compare page
		self.top.document.location = '#(##class(%CSP.Page).Link("UtilEnsMsgCompare.csp",,1))#' + '$ID1=' + escape(id1) + '&$ID2=' + escape(id2);
	}
}
function resendMessages()
{
	// count # of selected messages
	var iList=0;
	var id1 = '', qparms = '';
	
	if (cbEnabled) {
		var idlist = new Array();
		var cb;
		for (var i = 1; i <= numRows; i++) {
			cb = self.document.getElementById("cb_"+i);
			if (cb && cb.checked) {
				idlist[iList++]=cb.value;
			}
		}
	}
	if (iList>0) {
		// Go to to Message Resend page
		var hasMore = self.document.getElementById("hasMore").value;
		var qParms = '';
		if (hasMore != 0 && iList == numRows) {
			var ok=confirm('The filter matches more messages than this page is displaying.\nDo you want to resend all matching messages? (Click \'Cancel\' to resend just those currently displayed.)');
			if (!ok) {
				hasMore=0;
			} else {
				qparms = qparms + '&Status=' + document.getElementById('Status').value;
				qparms = qparms + '&StartTime=' + document.getElementById('StartTime').value;
				qparms = qparms + '&EndTime=' + document.getElementById('EndTime').value;
				qparms = qparms + '&StartId=' + document.getElementById('StartId').value;
				qparms = qparms + '&EndId=' + document.getElementById('EndId').value;
				qparms = qparms + '&Type=' + document.getElementById('Type').value;
				qparms = qparms + '&Source=' + document.getElementById('Source').value;
				qparms = qparms + '&IsError=' + document.getElementById('IsError').value;
				qparms = qparms + '&MaxRows=' + document.getElementById('MaxRows').value;
				qparms = qparms + '&SortOrder=' + document.getElementById('SortOrder').value;
				qparms = qparms + '&TimeFormat=' + document.getElementById('TimeFormat').value;
				qparms = qparms + '&ColorBy=' + document.getElementById('ColorBy').value;
				qparms = qparms + '&TermsStr=' + document.getElementById('TermsStr').value;
			}
		} else {
			hasMore=0;
		}
		qparms = qparms + '&$ID1=' + idlist.join(",");
		self.top.document.location = '#(##class(%CSP.Page).Link("UtilEnsMsgResend.csp",,1))#' + '$MORE=' + hasMore + qparms;
	} else {
		alert('#(msgNoneChecked)#');
	}
}
	</script>>
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetColorByColumn">
<Description><![CDATA[
Subclass can override this to specify the name of column used 
to distinctly color rows]]></Description>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit $G(%request.Data("ColorBy",1))
]]></Implementation>
</Method>

<Method name="GetLinks">
<FormalSpec>&amp;pValues,&amp;pLinks</FormalSpec>
<Implementation><![CDATA[
	If $TR(pValues(3),$C(0)) '= "" {
		Set pLinks(3) = "UtilEnsMsgTrace.csp?$ID1="_pValues(3)
	}
]]></Implementation>
</Method>
</Class>
</Export>