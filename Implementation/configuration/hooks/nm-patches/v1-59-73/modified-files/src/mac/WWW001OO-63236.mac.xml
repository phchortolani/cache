<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="Cache for Windows (x86-32) 2008.2 (Build 615U)" ts="2009-07-30 11:40:44">
<Routine name="WWW001OO" type="MAC" languagemode="0" timestamp="61564,37404"><![CDATA[
WWW001OO
#include WWWConst
#include COMSYS
	;-------------------------------------------------------------------------------
	; Description of Function :
	;		WWW001OO
	;		@net-Klassen zu Cache-Klassen mit Hilfe des %Dictionary-Packets konvertieren
	;
	; Inputs : 
	;
	; ByRef :
	;
	; Returns :
	;
	; History :
	; 24-Jul-2007	Frank	BR014485: Comment out the usage of MAXVAL property.
	; 							If we set the MAXVAL of a integer datafield to be
	; 							10, the only allowed values are 0,1,2,3,...,10.
	; 							It has nothing to do with the size of the field. 
	; 11-Jul-2006	RPW		SR11964: If we fail to delete the object, quit with the
	; 							error.
	; 08-Feb-2006	Frank F	SR14278: Keeping the current class import statements in
	; 							the new created class.
	; 28-Oct-2005	Frank F	SR13353: Keeping the current class methods in the new
	; 							created class.
	; 07-Jul-2005	Steve S	SR12854: Added Calc fields for currencies
	; 22-Jun-2005	SCR		SR12755: Added Calculated fields
	; 05-Apr-2005	Paul K	Added comment for change in SR#11714. Counter fields
	; 							can be strings
	; 12.07.2004	OJR
	; 17.04.2004	ARI
	;-------------------------------------------------------------------------------
	QUIT
	
COMPILE(pidClass,NOFORM,&sc)
	;-------------------------------------------------------------------------------
	;	Kompilierung aus Formular WWW001 heraus
	; Inputs:
	; 	pidClass	; Class ID
	;	NOFORM=1	; 1 - don't display messages through browser
	;				; 0 - called from a form - display messages
	;	sc			; By Ref (Status)
	;
	; History:
	; 21-Jul-2009	PPP		SR16757: Added new By Ref Parameter 'sc' - returns status
	; 04-Mar-2009	GRF		SR16410: Stricter enforcement of "Do Not Compile This Class"
	; 23-Feb-2009	shobby	SRAdhoc: Error message is corrupted by characters 13 & 10
	; 05-Jan-2006	SC		SR14136: Don't add strPackName prefix to pidClass when
	; 							pidClass contains a ".", ie "a.b" 
	;-------------------------------------------------------------------------------
	new arrError,blnDontCompile,objANMClass,strClassName,strPackName
	
	set sc = $$$OK
	
	quit:$get(pidClass)=""
	
	set strPackName = "User"  ;will be Parameter ^WWW012(0,YM,1)...
	
	; If WWW001 D21 "No Compile (mapped class)" is ticked, a User.xxxxx class will not be generated from the @nM class.
	; Only where class contains a "." in the name and where NOFORM isn't $$$YES.
	
	set objANMClass = $get(^WWW001(0,pidClass,1))
	set blnDontCompile = $$$WWW001NoCompilemappedclass(objANMClass)
	if blnDontCompile {
		if $get(NOFORM) '= $$$YES {
			do SCRPTAL^WWWTOOLS("Class is mapped. Not compiled.")
			do ^WWWFORM
		}	
		quit
	}
	
	;---------------------------------------
	
	set sc = $$CREATE(pidClass)    ; This will return a simple boolean unless the save process returns a sc error
	set strClassName = $select(pidClass[".":"",1:strPackName_".")_pidClass  //SR14136
 
	if $$$ISOK(sc) set sc = $SYSTEM.OBJ.Compile(strClassName,"-d",.arrError)  
	
	; Display messages if called from a form
	if $get(NOFORM) '= $$$YES {
		if $$$ISERR(sc) {
		;	FIXME : If CREATE returns $$$NO then this will display "ERROR #00: (no error description)"
		;	        This can happen if we try to compile a class with WWW001 but no WWW002 or WWW003. <GRF>
			do $SYSTEM.Status.DecomposeStatus(sc,.arrError)
		;	do SCRPTAL^WWWTOOLS($translate($$^WWWUMLAU(ERROR(1)),"'"))      ;SRAdhoc    ; FIXME : Why is this different from below? <GRF>
			do SCRPTAL^WWWTOOLS($translate(arrError(1),$$$CRLF))      
		} else {
			set sc = $SYSTEM.OBJ.Compile(strClassName,"-d",.arrError) 
			
			if sc {
				do SCRPTAL^WWWTOOLS($$^WWWTEXT("WWW00061")) ; "Compile Done."
			
			} else {   ; Convert each actual double quote to 3 character representation and all $$$CRLF to "new line" instruction
				do SCRPTAL^WWWTOOLS($$SUBSTR^WWWTOOLS($$SUBSTR^WWWTOOLS($$^WWWUMLAU(arrError(1)),"""","#34"),$$$CRLF,"\n"))
			}
		}
		do ^WWWFORM
	}
	quit
	
	
CREATE(iCLASS) ;
	;-------------------------------------------------------------------------------
	; History :
	; 17-Jul-2009	shobby	SR16701: Changed Memo fields to %String from %Stream
	; 06-Mar-2009	GRF		SR16410: Stricter enforcement of "Do Not Compile This
	; 							Class"
	; 19-Dec-2008	shobby	16248: Put back the code that preserves existing methods
	; 						with the exception of any calculated methods which will
	; 						be regenerated anyway.
	; 02-Oct-2008	shobby	BR014985: Make classes inherit from XML.Adaptor
	; 30-Jul-2007	GRF		SR15571: STORAGE not STOARAGE
	; 13-Jul-2007	RPW		SR15571: Use WWW.DiscTimestamp so that object access and
	; 							global access for timestamps are the same
	; 15-May-2007	RPW/GRF	SR15516: Do not worry about customisation on compilation,
	; 							it's not nice.  Naked References
	; 29-Mar-2007	RPW		SR15488: If we are 2007, use SetAt for parameters not
	; 							Data, looks based on Caché4 Syntax not 5.
	;-------------------------------------------------------------------------------
	;#include COMDebug
	;if $$$DevGlen quit $$CREATE^zzWWW001OO($get(iCLASS))
	
	;---------------------------------------
	
	if $get(iCLASS)=""                                        quit $$$NO
	if '$data(^WWW001(0,iCLASS))                              quit $$$NO
	if '$data(^WWW002(0,iCLASS)) && '$data(^WWW003(0,iCLASS)) quit $$$NO
	
	new arrClassMethods,ATNETTYPE,blnIs2007,blnSharedFile,CACHECLASS,CAPTION,CLASS,CLASSX,DATA
	new FELDNR,GLOBAL,GLOBREF,IDFIELD,INDEX,INDEXNR,idxMethod,loop
	new METHNAME,METHOD,objANMClass,objCacheClass,objClassMethods,objClassMethod
	new PACKNAME,PARAMETERS,PROP,PROPNAME,SPRACHE,SQLDATA,SQLMAP,SQLSUBSCRIPT,STORAGE
	new strCaption,strCompany,strDelimiter,strImport,strInclude,strMethodName,strPropList
	new SIZE,SUCCESS,WWWOO1,WWW002,WWW003,YSKEY
	
	; SR16410 vvv
	set SPRACHE    = "EN"           ; guarantees consistent language in object classes
	set strCompany = $$^WWWTEXT("400;Mandant")      ; "Company"
	
	set objANMClass = $get(^WWW001(0,iCLASS,1))
	quit:$$$WWW001NoCompilemappedclass(objANMClass)=$$$YES $$$YES  ; *** DO NOT COMPILE THESE CLASSES ***
	
	set blnIs2007 = $SYSTEM.Version.GetMajor()>"2006" // SR15488
	
	DO
	. NEW ATTNU,ATTX,ATTXX,LF,LFN,OBJECT,RESN,YXCHAR
	. SET YXCHAR=""
	. FOR loop=128:1:255 SET YXCHAR=YXCHAR_$CHAR(loop)
	. if '$DATA(^WWW002(0,iCLASS)) quit
	. quit:iCLASS="WWW000"   ;ROUTINE
	. ;SET YDATA=$GET(^WWW001(0,iCLASS,1))
	. ;set YDATA = objANMClass
	. quit:$$$WWW001NoCompilemappedclass(objANMClass)=$$$YES
	. ;
	. SET NOCOMPILE=0  ;COMPILE OK
	. ;do NEU  ;NEUE ÜBERTRAGUNG ;recent translation 
	. ;SET DELIM  =  $piece(objANMClass,Y,11)
	. ;if +DELIM=0 SET DELIM=126  ;TRENNZEICHNEN
	. SET OBJECT = +$piece(objANMClass,Y,8)
	. if OBJECT'=0 if OBJECT'=4 if OBJECT'=3 quit  ;NICHT AUSWERTEN WENN ROUTINE ODER ABA ODER SONSTIGES ;Not when routine Or Or 
	. ;
	. SET SORT=""
	. DO  ;CHECK IF WORDS ARE DOUBLE ;stand-in 
	. . KILL ^WWWSOR(YUSER)
	. . SET LFN=""
	. . FOR  SET LFN = $order(^WWW003(0,iCLASS,LFN)) quit:LFN=""  DO
	. . . SET LF=$GET(^WWW003(0,iCLASS,LFN,1))
	. . . quit:$$$WWW003PropertyName(LF)=""  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . . ;
	. . . if $DATA(^WWWRESs(0,1,$$^WWWUMLAU($$$WWW003PropertyName(LF),1))) SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1)) = "" quit
	. . . if $DATA(^WWWSOR(YUSER,$$$WWW003PropertyName(LF)))               SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1)) = "" quit
	. . . if ($EXTRACT($$$WWW003PropertyName(LF))=0) || (+$EXTRACT($$$WWW003PropertyName(LF))'=0) SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1)) = "" quit  ;KEINE ZAHLEN AM ANFANG;FIS;21.04.04;25326
	. . . SET ^WWWSOR(YUSER,$$$WWW003PropertyName(LF))                = ""
	. . . SET ^WWWSOR(YUSER,$$^WWWUMLAU($$$WWW003PropertyName(LF),1)) = ""
	. ;
	. DO ^WWWSORTKEY(iCLASS)
	. KILL ^WWWSOR(YUSER)
	. ;
	. ;RESERVIERTE WÖRTER
	. SET ^WWWSOR(YUSER,strCompany)="" 
	. SET RESN=""
	. FOR  SET RESN=$order(^WWWRES(0,RESN)) quit:RESN=""  DO
	. . SET ATTX=$$^WWWUMLAU($GET(^WWWRES(0,RESN,1)),1)
	. . quit:ATTX=""
	. . SET ^WWWSOR(YUSER,ATTX)=""
	. ;
	. SET LFN=""
	. FOR  SET LFN=$order(^WWW002(0,iCLASS,LFN)) quit:LFN=""  DO
	. . SET LF = $GET(^WWW002(0,iCLASS,LFN,1))
	. . quit:$FIND($$$WWW002PropertyName(LF),".")  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . ;
	. . SET ATTX=""
	. . if $GET(^WWW0021(0,iCLASS,LFN,SPRACHE,1))'=""    SET $$$WWW002PropertyDescription(LF) = $TRANSLATE($EXTRACT($$^WWWUMLAU($piece(^WWW0021(0,iCLASS,LFN,SPRACHE,1),Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . if $TRANSLATE($$$WWW002PropertyName(LF)," ")'="" SET $$$WWW002PropertyDescription(LF) = $$$WWW002PropertyName(LF)  ;SCHON EINMAL ÜBERTRAGEN ;yet sometimes transport 
	. . SET ATTX = $TRANSLATE($EXTRACT($$^WWWUMLAU($$$WWW002PropertyDescription(LF),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . if ATTX'="" SET ATTXX = ATTX FOR ATTNU=1:1 DO  if '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) SET ^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))="" SET ^WWWSOR(YUSER,222,LFN)=ATTX quit
	. . . if '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) quit
	. . . SET ATTX = ATTXX_ATTNU
	. . if ATTX'="" if $TRANSLATE($$$WWW002PropertyName(LF)," ")="" SET $$$WWW002PropertyName(^WWW002(0,iCLASS,LFN,1)) = ATTX  ; D25  ; FIXME : Index 3.2 on this piece - Reindex? <GRF>
	. ;
	. SET LFN=""
	. FOR  SET LFN=$order(^WWW003(0,iCLASS,LFN)) quit:LFN=""  DO
	. . SET LF=$GET(^WWW003(0,iCLASS,LFN,1))
	. . quit:$FIND($$$WWW003PropertyName(LF),".")  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . SET ATTX=""
	. . if $GET(^WWW0031(0,iCLASS,LFN,SPRACHE,1))'=""    SET $$$WWW003PropertyDescription(LF) = $TRANSLATE($EXTRACT($$^WWWUMLAU($piece(^WWW0031(0,iCLASS,LFN,SPRACHE,1),Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . if $TRANSLATE($$$WWW003PropertyName(LF)," ")'="" SET $$$WWW003PropertyDescription(LF) = $$$WWW003PropertyName(LF)  ;SCHON EINMAL ÜBERTRAGEN ;yet sometimes transport 
	. . SET ATTX = $TRANSLATE($EXTRACT($$^WWWUMLAU($$$WWW003PropertyDescription(LF),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . if ATTX'="" SET ATTXX = ATTX FOR ATTNU=1:1 DO  if '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) SET ^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))="" SET ^WWWSOR(YUSER,333,LFN)=ATTX quit
	. . . if '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) quit
	. . . SET ATTX = ATTXX_ATTNU
	. . if ATTX'="" if $TRANSLATE($$$WWW003PropertyName(LF)," ")="" SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1)) = ATTX   ; D25  ; FIXME : Index 3.2 on this piece - Reindex? <GRF>
	
	; Package Name
	;---------------------------------------
	SET PACKNAME="User"  ; Package Name    ; will be Parameter ^WWW012(0,YM,1)...
	SET CLASSX=iCLASS
	if $piece($GET(^WWW0011(0,iCLASS,SPRACHE,1)),Y,2)'="" SET CLASSX = $piece(^WWW0011(0,iCLASS,SPRACHE,1),Y,2)
	if iCLASS'["." {
		SET CACHECLASS = PACKNAME_"."_CLASSX
	} else {
		SET CACHECLASS = iCLASS
	}
	
	if ##class(%Dictionary.ClassDefinition).%ExistsId(CACHECLASS) {
		new strName,strClass
		; SR13353
		; Saving all the variables in an array to add them later to a new created class.
		set objCacheClass   = ##class(%Dictionary.ClassDefinition).%OpenId(CACHECLASS)
		; FIXME : May get objCacheClass=$$$NULLOREF if class is locked for editing (?) <GRF>
		set objClassMethods = objCacheClass.Methods
		set strInclude      = objCacheClass.IncludeCode
		set strImport       = objCacheClass.Import                   ;SR14278
		
		;16248 VVV Put this block of code back in
		for idxMethod = 1 : 1 : objClassMethods.Count() {
			set objClassMethod = objClassMethods.GetAt(idxMethod)
			set strName= objClassMethods.GetAt(idxMethod).Name
		;	if $extract(strName,$length(strName)-6,$length(strName))'="BASEGet" {
			if $extract(strName,$length(strName)-2,$length(strName))="Get" {
				set strName=$extract(strName,1,$length(strName)-3)
			}
			set strClass=CACHECLASS
			if $piece(strClass,".",1)="User" {
				set strClass=$piece(strClass,".",2,9999)
			}
			if '$data(^WWW003Calcs(0,1,$$$Index(strName),strClass)) {
				; Don't preserve calculated methods.
				set arrClassMethods(objClassMethod.Name, "Implementation") = objClassMethod.Implementation.Read()
				set arrClassMethods(objClassMethod.Name, "FormalSpec")     = objClassMethod.FormalSpec
				set arrClassMethods(objClassMethod.Name, "ClassMethod")    = objClassMethod.ClassMethod
				set arrClassMethods(objClassMethod.Name, "ReturnType")     = objClassMethod.ReturnType
			}
		}
		;16248 ^^^
 
		SET SUCCESS=##class(%Dictionary.ClassDefinition).%DeleteId(CACHECLASS)
		;SET SUCCESS=##class(%Dictionary.CompiledClass).%DeleteId(CACHECLASS) ; 23-Mar-2005	RobertW		You can not delete this, just raises an error.
		//SR11964
		if $$$ISERR(SUCCESS) {
			quit SUCCESS
		}
	}
	;SET WWW001=$GET(^WWW001(0,iCLASS,1))
	;quit:$piece(WWW001,"~",21) 1                    ; D21   $$$WWW001NoCompilemappedclass()
	
	; General Class Definition
	;---------------------------------------
	set CLASS=##class(%Dictionary.ClassDefinition).%New()
	set CLASS.Description = $$$WWW001ClassDescription(objANMClass)     ; D1
	if $data(^WWW0011(0,iCLASS,SPRACHE,1)) {
		set CLASS.Description = CLASS.Description_"/"_$piece($get(^WWW0011(0,iCLASS,SPRACHE,1)),Y,1)
	}
	set CLASS.Description=CLASS.Description_":"
	if '$$ISEMPTY^WWWMEMO($$$WWW001Description(objANMClass)) {     ; D19
		set CLASS.Description = CLASS.Description_"<br>"_$$TOHTML^WWWMEMO($$$WWW001Description(objANMClass))
	}
	
	set CLASS.Super = "%Library.Persistent,%XML.Adaptor,%Library.Populate"  
	if $$$WWW001InheritsFromSuperClasses(objANMClass)'="" set CLASS.Super = $$$WWW001InheritsFromSuperClasses(objANMClass) ; D20
	if CLASS.Super="Library.Persistent"                   set CLASS.Super = "%Library.Persistent"
	if '$find(CLASS.Super,"%XML.Adaptor")                 set CLASS.Super = CLASS.Super_",%XML.Adaptor" ;BR014985
	
	set CLASS.ClassType = "persistent"
	set CLASS.Name      = CACHECLASS
	
	; Company Property
	;---------------------------------------
	set blnSharedFile = '$$$WWW001SharedFile(objANMClass)     ; D3  [Company = YM or 0]
	
	if blnSharedFile DO
	. SET PROP=##class(%Dictionary.PropertyDefinition).%New()
	. DO CLASS.Properties.Insert(PROP)
	. SET PROP.Name     = strCompany             ;"Company"
	. SET PROP.Type     = "%String"
	. SET PROP.Required = $$$YES
	. if blnIs2007 do  // SR15488
	. . do PROP.Parameters.SetAt(30,"MAXLEN")
	. . do PROP.Parameters.SetAt("attribute","XMLPROJECTION")
	. if 'blnIs2007 do  // SR15488
	. . SET PROP.Parameters.Data("MAXLEN")        = 30
	. . SET PROP.Parameters.Data("XMLPROJECTION") = "attribute"
	
	; Properties : Primary Keys and Data Fields
	;---------------------------------------
	FOR GLOBAL="WWW002","WWW003" DO
	. SET GLOBREF="^"_GLOBAL_"(0,iCLASS)"
	. SET FELDNR=""
	. FOR  SET FELDNR=$order(@GLOBREF@(FELDNR)) quit:FELDNR=""  DO
	. . set SIZE=""                                                  ;SR16701
	. . ;do DisplayError^%apiOBJ(CLASS.%Save())
	. . SET DATA    = @GLOBREF@(FELDNR,1)
	. . SET IDFIELD = (GLOBAL="WWW002")
	. . SET PROP    = ##class(%Dictionary.PropertyDefinition).%New()
	. . DO CLASS.Properties.Insert(PROP)
	. . SET PROP.Name = $$$WWW003PropertyName(DATA)
	. . SET PROP.Type = "%String"
	. . ;
	. . SET ATNETTYPE=$$$WWW003InputType(DATA)
	. . if ATNETTYPE=1  set PROP.Type = "WWW.DiscDate" ;SET PROP.Type="%Date"  ;SET PROP.Type="BEWIDATA.Date"
	. . if ATNETTYPE=2  SET PROP.Type = "%Boolean"
	. .;if ATNETTYPE=3  SET PROP.Type = "%Stream"      ;SET PROP.Type="BEWIDATA.Memo"
	. . if ATNETTYPE=3  SET PROP.Type = "%String" set SIZE=32000     ;SR16701
	. . if ATNETTYPE=4  SET PROP.Type = "%Numeric"
	. . if ATNETTYPE=5  SET PROP.Type = "%String"
	. . if ATNETTYPE=6  SET PROP.Type = "%String"
	. . if ATNETTYPE=7  SET PROP.Type = "%Time"
	. . if ATNETTYPE=8  SET PROP.Type = "%Currency"   ;SET PROP.Type="BEWIDATA.Currency"
	. . if ATNETTYPE=9  SET PROP.Type = "%String"     ;Counter fields can be strings PJK 05-Apr-2005 11714
	. . if ATNETTYPE=10 SET PROP.Type = "%String"
	. . if ATNETTYPE=11 SET PROP.Type = "%String"
	. . if ATNETTYPE=12 SET PROP.Type = "%Float"
	. . if ATNETTYPE=13 SET PROP.Type = "%String"
	. .;if ATNETTYPE=14 SET PROP.Type = "%TimeStamp"  ;SET PROP.Type="%String" ;Im Moment mal String, da sonst die Cache-Validierung nicht klappt. Später sollten wir einen eigenen Datentyp schaffen.
	. . if ATNETTYPE=14 SET PROP.Type = "WWW.DiscTimestamp" // SR15571
	. . if ATNETTYPE=15 SET PROP.Type = "%List"
	. . if 'IDFIELD if ATNETTYPE=16 if $piece($GET(^WWW003(0,iCLASS,FELDNR,1)),Y,26)'="" DO  quit
	. . . SET PROP.Type = $$$WWW003AlternateInputType(^WWW003(0,iCLASS,FELDNR,1))  ; D26
	. . . if $$$WWW003AlternateInputType(^WWW003(0,iCLASS,FELDNR,1))'["." do
	. . . . SET PROP.Type = PACKNAME_"."_$$$WWW003AlternateInputType(^WWW003(0,iCLASS,FELDNR,1)) ; D26
	. . ;
	. . ;ARI 240504 brauchen wir nicht I PROP.Type="%String",$F($$UPCASE^ECVSIMP($$$WWW003xPROPERTYNAME(DATA)),"NAME") S PROP.Type="%Name"
	. . SET PARAMETERS=""
	. . ;ARI 021203 bei PrimaryKey-Feldern muss man die Collation auf EXACT
	. . ;setzen, sonst geht Kompilierung ab Cache 5.0.4 schief.
	. . if IDFIELD && (PROP.Type="%String") || (PROP.Type="%Name") do
	. . . if blnIs2007  do PROP.Parameters.SetAt("EXACT","COLLATION")   // SR15488
	. . . if 'blnIs2007 set PROP.Parameters.Data("COLLATION")="EXACT"   // SR15488
	. . ;
	. . if $CASE(ATNETTYPE,3:1,5:1,6:1,10:1,:0) DO
	. . . if SIZE="" set SIZE = $$$WWW003InputLength(DATA)                   ;SR16701
	. . . if blnIs2007  do PROP.Parameters.SetAt(SIZE,"MAXLEN")   // SR15488 ;SR16701
	. . . if 'blnIs2007 set PROP.Parameters.Data("MAXLEN")=SIZE   // SR15488 ;SR16701
	. . ;BR014485 commented
	. . ;if $CASE(ATNETTYPE,4:1,8:1,:0) DO
	. . ;. if blnIs2007  do PROP.Parameters.SetAt($EXTRACT(999999999,1,$$$WWW003InputLength(DATA)),"MAXVAL") // SR15488
	. . ;. if 'blnIs2007 set PROP.Parameters.Data("MAXVAL")=$EXTRACT(999999999,1,$$$WWW003InputLength(DATA)) // SR15488
	. . SET CAPTION    = $$$WWW003PropertyDescription(DATA)
	. . set strCaption = $GET(@("^"_GLOBAL_"1")@(0,iCLASS,FELDNR,SPRACHE,1)) // SR15516
	. . if strCaption'="" SET CAPTION = strCaption                           // SR15516
	. . if blnIs2007  do PROP.Parameters.SetAt(CAPTION,"CAPTION")               // SR15488
	. . if 'blnIs2007 set PROP.Parameters.Data("CAPTION") = CAPTION             // SR15488
	. . if IDFIELD do
	. . . if blnIs2007  do PROP.Parameters.SetAt("attribute","XMLPROJECTION")   // SR15488
	. . . if 'blnIs2007 set PROP.Parameters.Data("XMLPROJECTION") = "attribute" // SR15488
	. . if IDFIELD || $$$WWW003MandatoryField(DATA) SET PROP.Required=$$$YES
	. . SET PROP.Description = $$$WWW003PropertyDescription(DATA)
	. . if 'IDFIELD && $$$WWW003CachCollection(DATA)=$$$YES DO
	. . . SET PROP.Collection       = "list"
	. . . SET PROP.SqlListDelimiter = """;"""
	. . . SET PROP.SqlListType      = "delimited"
	. . ;
	. . ;  FIXME : Braces inside dot level syntax; NOFORM cf YNOFORM <GRF>
	. . if $get(YNOFORM)=1 set e=CLASS.%Save() if 'e { write !,GLOBAL_"::"_iCLASS_":"_PROP.Name_" "_FELDNR do DisplayError^%apiOBJ(e) quit}
	
	; Add "Calculated, SqlComputeCode" properties (and Methods?) for Calculated Fields
	;---------------------------------------
	do CalcCurrencyFields^WWW001CalcFields(iCLASS)        ; Calc Fields for Currencies SR12854
	do CalcFields^WWW001CalcFields(iCLASS,.CLASS)         ; Calculated Fields SR12755
	
	; Get Primary Key Properties and apply to Index definition
	;---------------------------------------
	set strPropList = ""
	if blnSharedFile do INSERT^WWWPLIST(.strPropList,strCompany)  ; "Company"
	set FELDNR = ""
	for  {
		set FELDNR = $order(^WWW002(0,iCLASS,FELDNR))
		quit:FELDNR=""
		
		set WWW002 = $get(^WWW002(0,iCLASS,FELDNR,1))
		do INSERT^WWWPLIST(.strPropList,$$$WWW002PropertyName(WWW002),$$$NO,$$$COMMA)    ; D25	()
	}
	
	SET INDEX=##class(%Dictionary.IndexDefinition).%New()
	DO CLASS.Indices.Insert(INDEX)
	SET INDEX.Properties      = strPropList
	SET INDEX.Name            = "IDKEY"
	SET INDEX.PrimaryKey      = 1
	SET INDEX.IdKey           = 1
	SET INDEX.Unique          = 1               ;ARI 040704
	
	
	; Identify @nManager tilde-delimited structures for SQL as "map1"
	;---------------------------------------
	SET CLASS.StorageStrategy = "StorageAtNet"
	
	SET STORAGE           = ##class(%Dictionary.StorageDefinition).%New()
	DO CLASS.Storages.Insert(STORAGE)
	SET STORAGE.Type      = "%CacheSQLStorage"
	SET STORAGE.Name      = "StorageAtNet"
	
	SET SQLMAP            = ##class(%Dictionary.StorageSQLMapDefinition).%New()
	DO STORAGE.SQLMaps.Insert(SQLMAP)
	SET SQLMAP.Name       = "map1"
	SET SQLMAP.Type       = "data"
	SET SQLMAP.Global     = "^"_iCLASS
	SET SQLMAP.Structure  = "delimited"
	
	SET SQLSUBSCRIPT      = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	SET SQLSUBSCRIPT.Name = 1
	if blnSharedFile {
		SET SQLSUBSCRIPT.Expression = "{"_strCompany_"}"
	} else {
		SET SQLSUBSCRIPT.Expression = 0
	}
	
	; Add Primary Keys to map
	;---------------------------------------
	SET FELDNR = ""
	FOR  SET FELDNR = $order(^WWW002(0,iCLASS,FELDNR)) quit:FELDNR=""  DO
	. SET SQLSUBSCRIPT = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name       = FELDNR+1
	. SET SQLSUBSCRIPT.Expression = "{"_$$$WWW002PropertyName($get(^WWW002(0,iCLASS,FELDNR,1)))_"}"  ; D25
	
	SET SQLSUBSCRIPT = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	SET SQLSUBSCRIPT.Name       = $order(^WWW002(0,iCLASS,""),-1)+2
	SET SQLSUBSCRIPT.Expression = 1
	
	set strDelimiter = $$$WWW001AltDelimiterASCII(objANMClass)    ; D11
	if +strDelimiter=0 {
		set strDelimiter = Y                     ; "~"
	} else {
		set strDelimiter = $char(strDelimiter)
	}
	
	; Add Data Fields to map
	;---------------------------------------
	SET FELDNR = ""
	FOR  SET FELDNR = $order(^WWW003(0,iCLASS,FELDNR)) quit:FELDNR=""  DO
	. SET SQLDATA = ##class(%Dictionary.StorageSQLMapDataDefinition).%New()
	. DO SQLMAP.Data.Insert(SQLDATA)
	. SET SQLDATA.Name      = $$$WWW003PropertyName($get(^WWW003(0,iCLASS,FELDNR,1)))  ; D25
	. SET SQLDATA.Delimiter = """"_strDelimiter_""""
	. SET SQLDATA.Piece     = FELDNR
	
	; Build list of @nM Indices into YSKEY and transfer
	; them to separate maps "SortIndex#" for SQL
	;---------------------------------------
	DO WWWSORTKEY(iCLASS)  ; sets YSKEY() array
	
	SET INDEXNR=""
	FOR  SET INDEXNR=$order(YSKEY(INDEXNR)) quit:INDEXNR=""  DO
	. SET SQLMAP=##class(%Dictionary.StorageSQLMapDefinition).%New()
	. DO STORAGE.SQLMaps.Insert(SQLMAP)
	. SET SQLMAP.Name="SortIndex"_INDEXNR
	. SET SQLMAP.Type="index"
	. SET SQLMAP.Global="^"_iCLASS_"s"
	. SET SQLMAP.Structure="delimited"
	. SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name=1
	. ;if blnSharedFile SET SQLSUBSCRIPT.Expression="{"_strCompany_"}" if 1  ;"{MANDANT}" if 1
	. ;ELSE  SET SQLSUBSCRIPT.Expression=0
	. if blnSharedFile  SET SQLSUBSCRIPT.Expression="{"_strCompany_"}"    ; "Company"
	. if 'blnSharedFile SET SQLSUBSCRIPT.Expression=0
	. SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name=2
	. SET SQLSUBSCRIPT.Expression=INDEXNR
	. FOR loop=1:1:$LENGTH(YSKEY(INDEXNR),",") DO
	. . SET FELDNR=$piece(YSKEY(INDEXNR),",",loop)
	. . SET IDFIELD=($EXTRACT(FELDNR)="K")
	. . SET FELDNR=$EXTRACT(FELDNR,2,$LENGTH(FELDNR))
	. . quit:FELDNR=""
	. . ;
	. . if 'IDFIELD if $$$WWW003PropertyName($GET(^WWW003(0,iCLASS,FELDNR,1)))="" quit     ; D25
	. . if IDFIELD  if $$$WWW002PropertyName($GET(^WWW002(0,iCLASS,FELDNR,1)))="" quit     ; D25
	. . ;
	. . SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. . DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. . SET SQLSUBSCRIPT.Name = loop+2
	. . if CACHECLASS["zzObjectTest" do
	. . . if IDFIELD  SET SQLSUBSCRIPT.Expression="$$^WWWUMLAU({"_$$$WWW002PropertyName($get(^WWW002(0,iCLASS,FELDNR,1)))_"},1)"  ; D25
	. . . if 'IDFIELD SET SQLSUBSCRIPT.Expression="$$^WWWUMLAU({"_$$$WWW003PropertyName($get(^WWW003(0,iCLASS,FELDNR,1)))_"},1)"  ; D25
	. . if CACHECLASS'["zzObjectTest" do
	. . . if IDFIELD  SET SQLSUBSCRIPT.Expression="$$UPPER({"_$$$WWW002PropertyName($get(^WWW002(0,iCLASS,FELDNR,1)))_"})"  ; D25
	. . . if 'IDFIELD SET SQLSUBSCRIPT.Expression="$$UPPER({"_$$$WWW003PropertyName($get(^WWW003(0,iCLASS,FELDNR,1)))_"})"  ; D25
	. ;
	. SET FELDNR=""
	. FOR  SET FELDNR=$order(^WWW002(0,iCLASS,FELDNR)) quit:FELDNR=""  DO
	. . SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. . DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. . SET SQLSUBSCRIPT.Name       = FELDNR+$LENGTH(YSKEY(INDEXNR),",")+2
	. . SET SQLSUBSCRIPT.Expression = "{"_$$$WWW002PropertyName($get(^WWW002(0,iCLASS,FELDNR,1)))_"}"  ; D25
	
	; (Deprecated?) Calculated Fields (WWWCLASSCALC is not populated)
	;---------------------------------------
	SET PROPNAME = ""
	FOR  SET PROPNAME = $order(^WWWCLASSCALC(0,iCLASS,PROPNAME)) quit:PROPNAME=""  DO
	. SET DATA = $GET(^WWWCLASSCALC(0,iCLASS,PROPNAME,1))
	. SET PROP = ##class(%Dictionary.PropertyDefinition).%New()
	. DO CLASS.Properties.Insert(PROP)
	. SET PROP.Name = PROPNAME
	. SET PROP.Type = "%String"
	. if $piece(DATA,Y,2)'="" SET PROP.Type = $piece(DATA,Y,2)
	. if '$$ISEMPTY^WWWMEMO($piece(DATA,Y,1)) SET PROP.Description=$$TOHTML^WWWMEMO($piece(DATA,Y,1))
	. SET PROP.Calculated=1
	. if '$$ISEMPTY^WWWMEMO($piece(DATA,Y,3)) DO
	. . SET PROP.SqlComputed    = 1
	. . SET $piece(DATA,Y,3)    = $$STRIPEND^WWWMEMO($piece(DATA,Y,3))
	. . SET PROP.SqlComputeCode = $$TOSTREAM^WWWMEMO($piece(DATA,Y,3))
	
	; (Deprecated?) @nM Methods (WWWCLASSMETH is not populated)
	;---------------------------------------
	SET METHNAME=""
	FOR  SET METHNAME=$order(^WWWCLASSMETH(0,iCLASS,METHNAME)) quit:METHNAME=""  DO
	. SET DATA=$GET(^WWWCLASSMETH(0,iCLASS,METHNAME,1))
	. SET METHOD=##class(%Dictionary.MethodDefinition).%New()
	. DO CLASS.Methods.Insert(METHOD)
	. SET METHOD.Name        = METHNAME
	. SET METHOD.ClassMethod =+$piece(DATA,Y,3)
	. SET METHOD.FormalSpec  = $piece(DATA,Y,2)
	. SET METHOD.ReturnType  = $piece(DATA,Y,4)
	. DO METHOD.Implementation.Write($$TOSTREAM^WWWMEMO($piece(DATA,Y,1)))
	
	; Restore existing methods, etc.
	;---------------------------------------                    ; SR13353
	; Adding to the new created class all the existing methods, and the include code as well.
	if $data(strInclude) set CLASS.IncludeCode = strInclude
	if $data(strImport)  set CLASS.Import      = strImport      ; SR14278
	
	if $data(arrClassMethods) {
		set strMethodName = $order(arrClassMethods(""))
		while strMethodName '= "" {
			set objClassMethod = ##class(%Dictionary.MethodDefinition).%New()
		
			set objClassMethod.Name              = strMethodName
			do objClassMethod.Implementation.Write(arrClassMethods(strMethodName, "Implementation")) 
			set objClassMethod.FormalSpec        = arrClassMethods(strMethodName, "FormalSpec")
			set objClassMethod.ClassMethod       = arrClassMethods(strMethodName, "ClassMethod")
			set objClassMethod.ReturnType        = arrClassMethods(strMethodName, "ReturnType")
			
			do CLASS.Methods.Insert(objClassMethod)
			
			set strMethodName = $order(arrClassMethods(strMethodName))
		}
	}
	
	set SUCCESS = CLASS.%Save()     ; FIXME : sc => strStatus?
	
	//Export the related Cache class to the file system if the creation was successful
	if (SUCCESS) {
		do ##class(SourceControl.Exporter).ExportClassByNMClass(iCLASS)
	}
	quit SUCCESS
	
	
CREATEALL ;
	DO ^WWWBACK
	NEW A,OK,START
	SET A="",START=$PIECE($HOROLOG,",",2)
	FOR  SET A=$ORDER(^WWW001(0,A)) QUIT:A=""  DO
	. IF '$DATA(^WWW002(0,A)),'$DATA(^WWW003(0,A)) QUIT
	. SET OK=$$CREATE^WWW001OO(A)
	. IF 'OK DO $SYSTEM.OBJ.DisplayError(OK) 
	. WRITE " ",A,!,YCR,"<BR> "
	
	;WRITE !,$PIECE($HOROLOG,",",2)-START
	QUIT
	
CREATEPART ;
	DO ^WWWBACK
	IF $GET(SPRACHE)="" SET SPRACHE="EN"   ;TYBD;17.05.2004;
	SET VORG(1)=$TRANSLATE($GET(VORG(1)),",",";")
	
	;IF VORG(1)="" IF VORG(3)=1 DO CREATEALL Q  ;COMPILE ALL
	
	SET VORGX="" 
	FOR  SET VORGX=$ORDER(^WWW001(0,VORGX)) QUIT:VORGX=""  DO
	. IF VORG(1)'="" QUIT:'$FIND(";"_VORG(1)_";",";"_VORGX_";")  ;NICHT AUSGEWÄHLT
	. IF '$DATA(^WWW002(0,VORGX)) QUIT
	. QUIT:VORGX="WWW000"                                        ;ROUTINE
	. IF '$DATA(^WWW002(0,VORGX)),'$DATA(^WWW003(0,VORGX)) QUIT
	. SET OK=$$CREATE^WWW001OO(VORGX)
	. WRITE "<BR>",YCR,VORGX," "
	. IF 'OK DO $SYSTEM.OBJ.DisplayError(OK) QUIT
	. WRITE "OK"
	
	QUIT
	
	
WWWSORTKEY(YDATEI) ;
	do ^WWWSORTKEY(YDATEI)
	;YSKEY(1)="1,2,3"   ;VARIABLEN FÜR SORTIERSCHLÜSSEL
	quit
	
	;*******************************************************************************
	
oldCOMPILE(iCLASS,NOFORM)
	;-------------------------------------------------------------------------------
	;	Kompilierung aus Formular WWW001 heraus
	;	
	; Inputs:
	; 	iCLASS		; Class ID
	;	NOFORM=1	; 1 - don't display messages through browser
	;				; 0 - called from a form - display messages
	;
	; History:
	; 23-Feb-2009	shobby	SRAdhoc: Error message is corrupted by characters 13 and 10
	; 05-Jan-2006	SC		SR14136: Added a check, so PACKNAME_"." is not added
	; 						iCLASS when iCLASS contains a ".", ie "a.b" 
	;-------------------------------------------------------------------------------
	/*   Test code for Caché object classes
	If $$$DevAdel {
		set STATUS = ##class(alSYS.Compile.iCompile).compileFix(iCLASS,$get(NOFORM),YUSER)
	 	if STATUS {
			DO SCRPTAL^WWWTOOLS($$^WWWTEXT("WWW00061")) ;Compile Done.
		} else {
			DO SCRPTAL^WWWTOOLS($$SUBSTR^WWWTOOLS($$SUBSTR^WWWTOOLS($$^WWWUMLAU(ERROR(1)),"""","#34"),$CHAR(13,10),"\n"))
		}
		
		do ^WWWFORM
		
	} else {
	*/
	
	QUIT:$GET(iCLASS)=""
	NEW PACKNAME,strClassName
	
	set PACKNAME = "User"  ;will be Parameter ^WWW012(0,YM,1)...
	
	; If WWW001 D21 "No Compile (mapped class)" is ticked, a User.xxxxx class will not be generated from the @nM class.
	; Only where class contains a "." in the name and where NOFORM isn't $$$YES.
	
	IF $GET(NOFORM)'=1 IF iCLASS[".",$PIECE($GET(^WWW001(0,iCLASS,1)),"~",21) DO SCRPTAL^WWWTOOLS("Class is mapped. Not compiled.") DO ^WWWFORM QUIT
	
	; FIXME : What if @nM class is flagged as "no compile" (D21) but we have called
	;         this with NOFORM=1?   Will cause it to compile and then quit (before
	;         the second compile - why is THAT needed?)   <GRF>
	
	NEW STATUS,ERROR
	
	set STATUS = $$CREATE(iCLASS)
	set strClassName = $select(iCLASS[".":"",1:PACKNAME_".")_iCLASS  //SR14136
 
	IF STATUS SET STATUS=$SYSTEM.OBJ.Compile(strClassName,"-d",.ERROR)  
	
	
	IF $GET(NOFORM)=1 QUIT  ;NOSHOW                                       ; *** EARLY EXIT ***
	; DEV1-56 version vvv
	;IF 'STATUS DO $SYSTEM.Status.DecomposeStatus(STATUS,.ERROR) DO SCRPTAL^WWWTOOLS($$^WWWUMLAU(ERROR(1))),^WWWFORM QUIT
	;                 ^^^
	; DEV Version vvv
	;IF 'STATUS DO $SYSTEM.Status.DecomposeStatus(STATUS,.ERROR) DO SCRPTAL^WWWTOOLS($translate($$^WWWUMLAU(ERROR(1)),"'")),^WWWFORM QUIT
	IF 'STATUS DO $SYSTEM.Status.DecomposeStatus(STATUS,.ERROR) DO SCRPTAL^WWWTOOLS($translate(ERROR(1),$$$CRLF)),^WWWFORM QUIT   ;SRAdhoc
	;             ^^^
	
	set STATUS=$SYSTEM.OBJ.Compile(strClassName,"-d",.ERROR) 
	
	;IF STATUS DO SCRPTAL^WWWTOOLS($$^WWWTEXT("Compile Done.")) IF 1
	;ELSE  DO SCRPTAL^WWWTOOLS($$SUBSTR^WWWTOOLS($$SUBSTR^WWWTOOLS($$^WWWUMLAU(ERROR(1)),"""","#34"),$CHAR(13,10),"\n"))
	
	if STATUS {
		DO SCRPTAL^WWWTOOLS($$^WWWTEXT("WWW00061")) ; "Compile Done."
	} else {
		DO SCRPTAL^WWWTOOLS($$SUBSTR^WWWTOOLS($$SUBSTR^WWWTOOLS($$^WWWUMLAU(ERROR(1)),"""","#34"),$CHAR(13,10),"\n"))
	}
	
	do ^WWWFORM
	
	quit
	
	
oldCREATE(iCLASS) ;
	;-------------------------------------------------------------------------------
	; History :
    ; 09-Jun-2008	PPP		SRAdhoc:Updated the Version to Cache 2008
	; 19-Dec-2008	shobby	16248: Put back the code that preserves existing methods
	; 						with the exception of any calculated methods which will
	; 						be regenerated anyway.
	; 02-Oct-2008	shobby	BR014985: Make classes inherit from XML.Adaptor
	; 30-Jul-2007	GRF		SR15571: STORAGE not STOARAGE
	; 13-Jul-2007	RPW		SR15571: Use WWW.DiscTimestamp so that object access and
	; 							global access for timestamps are the same
	; 15-May-2007	RPW/GRF	SR15516: Do not worry about customisation on compilation,
	; 							it's not nice.  Naked References
	; 29-Mar-2007	RPW		SR15488: If we are 2007, use SetAt for parameters not
	; 							Data, looks based on Caché4 Syntax not 5.
	;-------------------------------------------------------------------------------
	QUIT:$GET(iCLASS)="" 0
	QUIT:'$DATA(^WWW001(0,iCLASS)) 0
	IF '$DATA(^WWW002(0,iCLASS)),'$DATA(^WWW003(0,iCLASS)) QUIT 0
	
	new arrClassMethods,ATNETTYPE,blnIs2007,CACHECLASS,CAPTION,CLASS,CLASSX,DATA,DELIM
	new FELDNR,GLOBAL,GLOBREF,I,IDFIELD,INDEX,INDEXNR,idxMethod
	new METHNAME,METHOD,MITMANDANT,objCacheClass,objClassMethods,objClassMethod
	new PACKNAME,PARAMETERS,PROP,PROPERTIES,PROPNAME,SQLDATA,SQLMAP,SQLSUBSCRIPT,STORAGE
	new strCaption,strImport,strInclude,strMethodName,SUCCESS,WWWOO1,WWW002,WWW003,YSKEY
	
	set blnIs2007=$SYSTEM.Version.GetMajor()>"2007" // SR15488
	
	DO
	. NEW YXCHAR,YDATA,DELIM,OBJECT,LFN,LF,RESN,ATTX,ATTXX,ATTNU
	. SET SPRACHE="EN"
	. SET YXCHAR=""
	. FOR I=128:1:255 SET YXCHAR=YXCHAR_$CHAR(I)
	. IF '$DATA(^WWW002(0,iCLASS)) QUIT
	. QUIT:iCLASS="WWW000"   ;ROUTINE
	. SET YDATA=$GET(^WWW001(0,iCLASS,1))
	. QUIT:$PIECE(YDATA,Y,21)=1  ;KEIN COMPILE GEMAPED ;no 
	. ;
	. SET NOCOMPILE=0  ;COMPILE OK
	. ;do NEU  ;NEUE ÜBERTRAGUNG ;recent translation 
	. SET DELIM=$PIECE(YDATA,Y,11)
	. SET OBJECT=+$PIECE(YDATA,Y,8)
	. IF OBJECT'=0 IF OBJECT'=4 IF OBJECT'=3 QUIT  ;NICHT AUSWERTEN WENN ROUTINE ODER ABA ODER SONSTIGES ;Not when routine Or Or 
	. IF +DELIM=0 SET DELIM=126  ;TRENNZEICHNEN
	. SET SORT=""
	. DO  ;CHECK IF WORDS ARE DOUBLE ;stand-in 
	. . KILL ^WWWSOR(YUSER)
	. . SET LFN=""
	. . FOR  SET LFN=$ORDER(^WWW003(0,iCLASS,LFN)) QUIT:LFN=""  DO
	. . . SET LF=$GET(^WWW003(0,iCLASS,LFN,1))
	. . . QUIT:$$$WWW003PropertyName(LF)=""  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . . IF $DATA(^WWWRESs(0,1,$$^WWWUMLAU($PIECE(LF,Y,25),1))) SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1))="" QUIT
	. . . IF $DATA(^WWWSOR(YUSER,$$$WWW003PropertyName(LF)))     SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1))="" QUIT
	. . . IF ($EXTRACT($$$WWW003PropertyName(LF))=0) || (+$EXTRACT($$$WWW003PropertyName(LF))'=0) SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1))="" QUIT  ;KEINE ZAHLEN AM ANFANG;FIS;21.04.04;25326
	. . . SET ^WWWSOR(YUSER,$$$WWW003PropertyName(LF))=""
	. . . SET ^WWWSOR(YUSER,$$^WWWUMLAU($$$WWW003PropertyName(LF),1))=""
	. ;
	. DO ^WWWSORTKEY(iCLASS)
	. KILL ^WWWSOR(YUSER)
	. ;
	. ;RESERVIERTE WÖRTER
	. SET ^WWWSOR(YUSER,$$^WWWTEXT("400;Mandant"))="" 
	. SET RESN=""
	. FOR  SET RESN=$ORDER(^WWWRES(0,RESN)) QUIT:RESN=""  DO
	. . SET ATTX=$$^WWWUMLAU($GET(^WWWRES(0,RESN,1)),1)
	. . QUIT:ATTX=""
	. . SET ^WWWSOR(YUSER,ATTX)=""
	. ;
	. SET LFN=""
	. FOR  SET LFN=$ORDER(^WWW002(0,iCLASS,LFN)) QUIT:LFN=""  DO
	. . SET LF=$GET(^WWW002(0,iCLASS,LFN,1))
	. . QUIT:$FIND($$$WWW002PropertyName(LF),".")  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . SET ATTX=""
	. . IF $GET(^WWW0021(0,iCLASS,LFN,SPRACHE,1))'="" SET $$$WWW002PropertyDescription(LF)=$TRANSLATE($EXTRACT($$^WWWUMLAU($PIECE(^WWW0021(0,iCLASS,LFN,SPRACHE,1),Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . IF $TRANSLATE($$$WWW002PropertyName(LF)," ")'="" SET $$$WWW002PropertyDescription(LF)=$$$WWW002PropertyName(LF)  ;SCHON EINMAL ÜBERTRAGEN ;yet sometimes transport 
	. . SET ATTX=$TRANSLATE($EXTRACT($$^WWWUMLAU($PIECE(LF,Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . IF ATTX'="" SET ATTXX=ATTX FOR ATTNU=1:1 DO  IF '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) SET ^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))="" SET ^WWWSOR(YUSER,222,LFN)=ATTX QUIT
	. . . IF '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) QUIT
	. . . SET ATTX=ATTXX_ATTNU
	. . IF ATTX'="" IF $TRANSLATE($PIECE(LF,Y,25)," ")="" SET $PIECE(^WWW002(0,iCLASS,LFN,1),Y,25)=ATTX
	. ;
	. SET LFN=""
	. FOR  SET LFN=$ORDER(^WWW003(0,iCLASS,LFN)) QUIT:LFN=""  DO
	. . SET LF=$GET(^WWW003(0,iCLASS,LFN,1))
	. . QUIT:$FIND($PIECE(LF,Y,25),".")  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . SET ATTX=""
	. . IF $GET(^WWW0031(0,iCLASS,LFN,SPRACHE,1))'="" SET $PIECE(LF,Y,1)=$TRANSLATE($EXTRACT($$^WWWUMLAU($PIECE(^WWW0031(0,iCLASS,LFN,SPRACHE,1),Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . IF $TRANSLATE($PIECE(LF,Y,25)," ")'="" SET $PIECE(LF,Y,1)=$PIECE(LF,Y,25)  ;SCHON EINMAL ÜBERTRAGEN ;yet sometimes transport 
	. . SET ATTX=$TRANSLATE($EXTRACT($$^WWWUMLAU($PIECE(LF,Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . IF ATTX'="" SET ATTXX=ATTX FOR ATTNU=1:1 DO  IF '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) SET ^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))="" SET ^WWWSOR(YUSER,333,LFN)=ATTX QUIT
	. . . IF '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) QUIT
	. . . SET ATTX=ATTXX_ATTNU
	. . IF ATTX'="" IF $TRANSLATE($PIECE(LF,Y,25)," ")="" SET $PIECE(^WWW003(0,iCLASS,LFN,1),Y,25)=ATTX
	
	SET PACKNAME="User"  ; Package Name    ; will be Parameter ^WWW012(0,YM,1)...
	SET CLASSX=iCLASS
	if $piece($GET(^WWW0011(0,iCLASS,SPRACHE,1)),Y,2)'="" SET CLASSX=$PIECE(^WWW0011(0,iCLASS,SPRACHE,1),Y,2)
	IF iCLASS'["." {
		SET CACHECLASS=PACKNAME_"."_CLASSX
	} else {
		SET CACHECLASS=iCLASS
	}
 
	IF ##class(%Dictionary.ClassDefinition).%ExistsId(CACHECLASS) {
		new strName,strClass
		; SR13353
		; Saving all the variables in an array to add them later to a new created class.
		set objCacheClass   = ##class(%Dictionary.ClassDefinition).%OpenId(CACHECLASS)
		; FIXME : May get objCacheClass=$$$NULLOREF if class is locked for editing (?) <GRF>
		set objClassMethods = objCacheClass.Methods
		set strInclude      = objCacheClass.IncludeCode
		set strImport       = objCacheClass.Import                   ;SR14278
		
		;16248 VVV Put this block of code back in
		for idxMethod = 1 : 1 : objClassMethods.Count() {
			set objClassMethod = objClassMethods.GetAt(idxMethod)
			set strName= objClassMethods.GetAt(idxMethod).Name
			;if $extract(strName,$length(strName)-6,$length(strName))'="BASEGet" {
			if $extract(strName,$length(strName)-2,$length(strName))="Get" {
				set strName=$extract(strName,1,$length(strName)-3)
			}
			set strClass=CACHECLASS
			if $piece(strClass,".",1)="User" {
				set strClass=$piece(strClass,".",2,9999)
			}
			if '$data(^WWW003Calcs(0,1,$$$Index(strName),strClass)) {
				; Don't preserve calculated methods.
				set arrClassMethods(objClassMethod.Name, "Implementation") = objClassMethod.Implementation.Read()
				set arrClassMethods(objClassMethod.Name, "FormalSpec")     = objClassMethod.FormalSpec
				set arrClassMethods(objClassMethod.Name, "ClassMethod")    = objClassMethod.ClassMethod
				set arrClassMethods(objClassMethod.Name, "ReturnType")     = objClassMethod.ReturnType
			}
		}
		;16248 ^^^
 
		SET SUCCESS=##class(%Dictionary.ClassDefinition).%DeleteId(CACHECLASS)
		;SET SUCCESS=##class(%Dictionary.CompiledClass).%DeleteId(CACHECLASS) ; 23-Mar-2005	RobertW		You can not delete this, just raises an error.
		//SR11964
		if $$$ISERR(SUCCESS) {
			quit SUCCESS
		}
	}
	SET WWW001=$GET(^WWW001(0,iCLASS,1))
	QUIT:$PIECE(WWW001,"~",21) 1                    ; D21   $$$WWW001NoCompilemappedclass()
	
	
	; General Class Definition
	;---------------------------------------
	SET CLASS=##class(%Dictionary.ClassDefinition).%New()
	SET CLASS.Description=$PIECE(WWW001,"~",1)
	IF $DATA(^WWW0011(0,iCLASS,SPRACHE,1)) SET CLASS.Description=CLASS.Description_"/"_$PIECE($GET(^WWW0011(0,iCLASS,SPRACHE,1)),"~",1)
	SET CLASS.Description=CLASS.Description_":"
	IF '$$ISEMPTY^WWWMEMO($PIECE(WWW001,"~",19)) {
		SET CLASS.Description=CLASS.Description_"<br>"_$$TOHTML^WWWMEMO($PIECE(WWW001,"~",19))
	}
	
	SET CLASS.Super="%Library.Persistent,%XML.Adaptor,%Library.Populate"  
	IF $PIECE(WWW001,"~",20)'=""          set CLASS.Super=$PIECE(WWW001,"~",20)       ; D20 $$$WWW001InheritsFromSuperClasses()
	IF CLASS.Super="Library.Persistent"   set CLASS.Super="%Library.Persistent"
	if '$find(CLASS.Super,"%XML.Adaptor") set CLASS.Super=CLASS.Super_",%XML.Adaptor" ;BR014985
	
	SET CLASS.ClassType = "persistent"
	SET CLASS.Name      = CACHECLASS
	
	; Company Property
	;---------------------------------------
	SET MITMANDANT='+$PIECE(WWW001,"~",3)     ; D3  $$$WWW001SharedFile()    [Company = YM or 0]
	IF MITMANDANT DO
	. SET PROP=##class(%Dictionary.PropertyDefinition).%New()
	. DO CLASS.Properties.Insert(PROP)
	. SET PROP.Name     = $$^WWWTEXT("400;Mandant")  ;"MANDANT"
	. SET PROP.Type     = "%String"
	. SET PROP.Required = $$$YES
	. if blnIs2007 do  // SR15488
	. . do PROP.Parameters.SetAt(30,"MAXLEN")
	. . do PROP.Parameters.SetAt("attribute","XMLPROJECTION")
	. if 'blnIs2007 do  // SR15488
	. . SET PROP.Parameters.Data("MAXLEN")        = 30
	. . SET PROP.Parameters.Data("XMLPROJECTION") = "attribute"
	
	; Properties : Primary Keys and Data Fields
	;---------------------------------------
	FOR GLOBAL="WWW002","WWW003" DO
	. SET GLOBREF="^"_GLOBAL_"(0,iCLASS)"
	. SET FELDNR=""
	. FOR  SET FELDNR=$ORDER(@GLOBREF@(FELDNR)) QUIT:FELDNR=""  DO
	. . ;do DisplayError^%apiOBJ(CLASS.%Save())
	. . SET DATA    = @GLOBREF@(FELDNR,1)
	. . SET IDFIELD = (GLOBAL="WWW002")
	. . SET PROP    = ##class(%Dictionary.PropertyDefinition).%New()
	. . DO CLASS.Properties.Insert(PROP)
	. . SET PROP.Name = $$$WWW003PropertyName(DATA)
	. . SET PROP.Type = "%String"
	. . ;
	. . SET ATNETTYPE=$$$WWW003InputType(DATA)
	. . IF ATNETTYPE=1  set PROP.Type = "WWW.DiscDate" ;SET PROP.Type="%Date"  ;SET PROP.Type="BEWIDATA.Date"
	. . IF ATNETTYPE=2  SET PROP.Type = "%Boolean"
	. . IF ATNETTYPE=3  SET PROP.Type = "%String"      ;SR16701   ; FIXME : SIZE? <GRF>
	. .;if ATNETTYPE=3  SET PROP.Type = "%Stream"      ;SET PROP.Type="BEWIDATA.Memo"
	. . IF ATNETTYPE=4  SET PROP.Type = "%Numeric"
	. . IF ATNETTYPE=5  SET PROP.Type = "%String"
	. . IF ATNETTYPE=6  SET PROP.Type = "%String"
	. . IF ATNETTYPE=7  SET PROP.Type = "%Time"
	. . IF ATNETTYPE=8  SET PROP.Type = "%Currency"   ;SET PROP.Type="BEWIDATA.Currency"
	. . IF ATNETTYPE=9  SET PROP.Type = "%String"		;Counter fields can be strings PJK 05-Apr-2005 11714
	. . IF ATNETTYPE=10 SET PROP.Type = "%String"
	. . IF ATNETTYPE=11 SET PROP.Type = "%String"
	. . IF ATNETTYPE=12 SET PROP.Type = "%Float"
	. . IF ATNETTYPE=13 SET PROP.Type = "%String"
	. .;IF ATNETTYPE=14 SET PROP.Type = "%TimeStamp" ;SET PROP.Type="%String" ;Im Moment mal String, da sonst die Cache-Validierung nicht klappt. Später sollten wir einen eigenen Datentyp schaffen.
	. . IF ATNETTYPE=14 SET PROP.Type = "WWW.DiscTimestamp" // SR15571
	. . IF ATNETTYPE=15 SET PROP.Type = "%List"
	. . IF 'IDFIELD IF ATNETTYPE=16 IF $PIECE($GET(^WWW003(0,iCLASS,FELDNR,1)),Y,26)'="" DO  QUIT
	. . . SET PROP.Type=$PIECE(^WWW003(0,iCLASS,FELDNR,1),Y,26)
	. . . IF $PIECE(^WWW003(0,iCLASS,FELDNR,1),Y,26)'["." SET PROP.Type=PACKNAME_"."_$PIECE(^WWW003(0,iCLASS,FELDNR,1),Y,26) 
	. . ;
	. . ;ARI 240504 brauchen wir nicht I PROP.Type="%String",$F($$UPCASE^ECVSIMP($$$WWW003xPROPERTYNAME(DATA)),"NAME") S PROP.Type="%Name"
	. . SET PARAMETERS=""
	. . ;ARI 021203 bei PrimaryKey-Feldern muss man die Collation auf EXACT
	. . ;setzen, sonst geht Kompilierung ab Cache 5.0.4 schief.
	. . IF IDFIELD && (PROP.Type="%String") || (PROP.Type="%Name") do
	. . . if blnIs2007 do // SR15488
	. . . . do PROP.Parameters.SetAt("EXACT","COLLATION")
	. . . if 'blnIs2007 do // SR15488
	. . . . SET PROP.Parameters.Data("COLLATION")="EXACT"
	. . ;
	. . IF $CASE(ATNETTYPE,3:1,5:1,6:1,10:1,:0) DO
	. . . if SIZE="" set SIZE = $$$WWW003InputLength(DATA)    ;SR16701
	. . . if blnIs2007 do // SR15488
	. . . . do PROP.Parameters.SetAt(SIZE,"MAXLEN")           ;SR16701
	. . . if 'blnIs2007 do // SR15488
	. . . . SET PROP.Parameters.Data("MAXLEN")=SIZE           ;SR16701
	. . ;
	. . ;BR014485 commented
	. . ;IF $CASE(ATNETTYPE,4:1,8:1,:0) DO
	. . ;. if blnIs2007  do // SR15488
	. . ;. . do PROP.Parameters.SetAt($EXTRACT(999999999,1,$$$WWW003InputLength(DATA)),"MAXVAL")
	. . ;. if 'blnIs2007 do // SR15488
	. . ;. . SET PROP.Parameters.Data("MAXVAL")=$EXTRACT(999999999,1,$$$WWW003InputLength(DATA))
	. . SET CAPTION=$$$WWW003PropertyDescription(DATA)
	. . set strCaption=$GET(@("^"_GLOBAL_"1")@(0,iCLASS,FELDNR,SPRACHE,1)) // SR15516
	. . IF strCaption'="" SET CAPTION=strCaption // SR15516
	. . if blnIs2007 do // SR15488
	. . . do PROP.Parameters.SetAt(CAPTION,"CAPTION")
	. . if 'blnIs2007 do // SR15488
	. . . SET PROP.Parameters.Data("CAPTION")=CAPTION
	. . IF IDFIELD do
	. . . if blnIs2007 do // SR15488
	. . . . do PROP.Parameters.SetAt("attribute","XMLPROJECTION")
	. . . if 'blnIs2007 do // SR15488
	. . . . SET PROP.Parameters.Data("XMLPROJECTION")="attribute"
	. . IF IDFIELD || $$$WWW003MandatoryField(DATA) SET PROP.Required=$$$YES
	. . SET PROP.Description=$$$WWW003PropertyDescription(DATA)
	. . IF 'IDFIELD,$$$WWW003CachCollection(DATA)=$$$YES DO
	. . . SET PROP.Collection       = "list"
	. . . SET PROP.SqlListDelimiter = """;"""
	. . . SET PROP.SqlListType      = "delimited"
	. . ;
	. . if $get(YNOFORM)=1 set e=CLASS.%Save() if 'e { write !,GLOBAL_"::"_iCLASS_":"_PROP.Name_" "_FELDNR do DisplayError^%apiOBJ(e) quit}
	
	; Add "Calculated, SqlComputeCode" properties (and Methods?) for Calculated Fields
	;---------------------------------------
	do CalcCurrencyFields^WWW001CalcFields(iCLASS)        ; Calc Fields for Currencies SR12854
	do CalcFields^WWW001CalcFields(iCLASS,.CLASS)         ; Calculated Fields SR12755
	
	; Get Primary Key Properties and apply to Index definition
	;---------------------------------------
	SET PROPERTIES=""
	IF MITMANDANT DO INSERT^WWWPLIST(.PROPERTIES,$$^WWWTEXT("400;Mandant"))  ;"MANDANT")
	SET FELDNR=""
	FOR  SET FELDNR=$ORDER(^WWW002(0,iCLASS,FELDNR)) QUIT:FELDNR=""  DO
	. SET WWW002=$GET(^WWW002(0,iCLASS,FELDNR,1))
	. DO INSERT^WWWPLIST(.PROPERTIES,$PIECE(WWW002,"~",25))
	
	SET INDEX=##class(%Dictionary.IndexDefinition).%New()
	DO CLASS.Indices.Insert(INDEX)
	SET INDEX.Properties      = PROPERTIES
	SET INDEX.Name            = "IDKEY"
	SET INDEX.PrimaryKey      = 1
	SET INDEX.IdKey           = 1
	SET INDEX.Unique          = 1               ;ARI 040704
	
	
	; Identify @nManager tilde-delimited structures for SQL as "map1"
	;---------------------------------------
	SET CLASS.StorageStrategy = "StorageAtNet"
	
	SET STORAGE               = ##class(%Dictionary.StorageDefinition).%New()
	DO CLASS.Storages.Insert(STORAGE)
	SET STORAGE.Type      = "%CacheSQLStorage"
	SET STORAGE.Name      = "StorageAtNet"
	
	SET SQLMAP            = ##class(%Dictionary.StorageSQLMapDefinition).%New()
	DO STORAGE.SQLMaps.Insert(SQLMAP)
	
	SET SQLMAP.Name       = "map1"
	SET SQLMAP.Type       = "data"
	SET SQLMAP.Global     = "^"_iCLASS
	SET SQLMAP.Structure  = "delimited"
	
	SET SQLSUBSCRIPT      = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	SET SQLSUBSCRIPT.Name = 1
	IF MITMANDANT {
		SET SQLSUBSCRIPT.Expression = "{"_$$^WWWTEXT("400;Mandant")_"}"
	} else {
		SET SQLSUBSCRIPT.Expression = 0
	}
	
	; Add Primary Keys to map
	;---------------------------------------
	SET FELDNR=""
	FOR  SET FELDNR=$ORDER(^WWW002(0,iCLASS,FELDNR)) QUIT:FELDNR=""  DO
	. SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name=FELDNR+1
	. SET SQLSUBSCRIPT.Expression="{"_$PIECE($GET(^WWW002(0,iCLASS,FELDNR,1)),"~",25)_"}"
	
	SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	SET SQLSUBSCRIPT.Name=$ORDER(^WWW002(0,iCLASS,""),-1)+2
	SET SQLSUBSCRIPT.Expression=1
	
	SET DELIM=$PIECE($GET(^WWW001(0,iCLASS,1)),Y,11)
	IF DELIM'="" SET DELIM=$CHAR(DELIM)  ;CHANGE BY ROBERT WUTTKE;20041022, spelling corrected 29/03/2005
	IF DELIM=""  SET DELIM=Y
	
	; Add Data Fields to map
	;---------------------------------------
	SET FELDNR=""
	FOR  SET FELDNR=$ORDER(^WWW003(0,iCLASS,FELDNR)) QUIT:FELDNR=""  DO
	. SET SQLDATA=##class(%Dictionary.StorageSQLMapDataDefinition).%New()
	. DO SQLMAP.Data.Insert(SQLDATA)
	. SET SQLDATA.Name=$PIECE($GET(^WWW003(0,iCLASS,FELDNR,1)),"~",25) ;write SQLDATA.Name,!
	. SET SQLDATA.Delimiter=""""_DELIM_""""
	. SET SQLDATA.Piece=FELDNR
	
	; Build list of @nM Indices into YSKEY and transfer
	; them to separate maps "SortIndex#" for SQL
	;---------------------------------------
	DO WWWSORTKEY(iCLASS)
	
	SET INDEXNR=""
	FOR  SET INDEXNR=$ORDER(YSKEY(INDEXNR)) QUIT:INDEXNR=""  DO
	. SET SQLMAP=##class(%Dictionary.StorageSQLMapDefinition).%New()
	. DO STORAGE.SQLMaps.Insert(SQLMAP)
	. SET SQLMAP.Name="SortIndex"_INDEXNR
	. SET SQLMAP.Type="index"
	. SET SQLMAP.Global="^"_iCLASS_"s"
	. SET SQLMAP.Structure="delimited"
	. SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name=1
	. IF MITMANDANT SET SQLSUBSCRIPT.Expression="{"_$$^WWWTEXT("400;Mandant")_"}" IF 1  ;"{MANDANT}" IF 1
	. ELSE  SET SQLSUBSCRIPT.Expression=0
	. SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name=2
	. SET SQLSUBSCRIPT.Expression=INDEXNR
	. FOR I=1:1:$LENGTH(YSKEY(INDEXNR),",") DO
	. . SET FELDNR=$PIECE(YSKEY(INDEXNR),",",I)
	. . SET IDFIELD=($EXTRACT(FELDNR)="K")
	. . SET FELDNR=$EXTRACT(FELDNR,2,$LENGTH(FELDNR))
	. . QUIT:FELDNR=""
	. . IF 'IDFIELD IF $PIECE($GET(^WWW003(0,iCLASS,FELDNR,1)),Y,25)="" QUIT
	. . IF IDFIELD  IF $PIECE($GET(^WWW002(0,iCLASS,FELDNR,1)),Y,25)="" QUIT
	. . ;IF $P($G(^WWW003(0,iCLASS,FELDNR,1)),"~",25)="" QUIT 
	. . SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. . DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. . SET SQLSUBSCRIPT.Name=I+2
	. . ;CHANGES 22.2.2005 ROBERT WUTTKE AND PAUL KALENJUK; tybd;25,2,2005
	. . if CACHECLASS["zzObjectTest" do
	. . . IF IDFIELD SET SQLSUBSCRIPT.Expression="$$^WWWUMLAU({"_$PIECE($GET(^WWW002(0,iCLASS,FELDNR,1)),"~",25)_"},1)"
	. . . IF 'IDFIELD SET SQLSUBSCRIPT.Expression="$$^WWWUMLAU({"_$PIECE($GET(^WWW003(0,iCLASS,FELDNR,1)),"~",25)_"},1)"
	. . if CACHECLASS'["zzObjectTest" do
	. . . IF IDFIELD SET SQLSUBSCRIPT.Expression="$$UPPER({"_$PIECE($GET(^WWW002(0,iCLASS,FELDNR,1)),"~",25)_"})"
	. . . IF 'IDFIELD SET SQLSUBSCRIPT.Expression="$$UPPER({"_$PIECE($GET(^WWW003(0,iCLASS,FELDNR,1)),"~",25)_"})"
	. ;
	. SET FELDNR=""
	. FOR  SET FELDNR=$ORDER(^WWW002(0,iCLASS,FELDNR)) QUIT:FELDNR=""  DO
	. . SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. . DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. . SET SQLSUBSCRIPT.Name=FELDNR+$LENGTH(YSKEY(INDEXNR),",")+2
	. . SET SQLSUBSCRIPT.Expression="{"_$PIECE($GET(^WWW002(0,iCLASS,FELDNR,1)),"~",25)_"}"
	
	; (Deprecated?) Calculated Fields (WWWCLASSCALC)
	;---------------------------------------
	SET PROPNAME=""
	FOR  SET PROPNAME=$ORDER(^WWWCLASSCALC(0,iCLASS,PROPNAME)) QUIT:PROPNAME=""  DO
	. SET DATA=$GET(^WWWCLASSCALC(0,iCLASS,PROPNAME,1))
	. SET PROP=##class(%Dictionary.PropertyDefinition).%New()
	. DO CLASS.Properties.Insert(PROP)
	. SET PROP.Name=PROPNAME
	. SET PROP.Type="%String"
	. IF $PIECE(DATA,"~",2)'="" SET PROP.Type=$PIECE(DATA,"~",2)
	. IF '$$ISEMPTY^WWWMEMO($PIECE(DATA,"~",1)) SET PROP.Description=$$TOHTML^WWWMEMO($PIECE(DATA,"~",1))
	. SET PROP.Calculated=1
	. IF '$$ISEMPTY^WWWMEMO($PIECE(DATA,"~",3)) DO
	. . SET PROP.SqlComputed=1
	. . SET $PIECE(DATA,"~",3)=$$STRIPEND^WWWMEMO($PIECE(DATA,"~",3))
	. . SET PROP.SqlComputeCode=$$TOSTREAM^WWWMEMO($PIECE(DATA,"~",3))
	
	; (Deprecated?) @nM Methods (WWWCLASSMETH)
	;---------------------------------------
	SET METHNAME=""
	FOR  SET METHNAME=$ORDER(^WWWCLASSMETH(0,iCLASS,METHNAME)) QUIT:METHNAME=""  DO
	. SET DATA=$GET(^WWWCLASSMETH(0,iCLASS,METHNAME,1))
	. SET METHOD=##class(%Dictionary.MethodDefinition).%New()
	. DO CLASS.Methods.Insert(METHOD)
	. SET METHOD.Name        = METHNAME
	. SET METHOD.ClassMethod =+$PIECE(DATA,"~",3)
	. SET METHOD.FormalSpec  = $PIECE(DATA,"~",2)
	. SET METHOD.ReturnType  = $PIECE(DATA,"~",4)
	. DO METHOD.Implementation.Write($$TOSTREAM^WWWMEMO($PIECE(DATA,"~",1)))
	
	; Restore existing methods, etc.
	;---------------------------------------                      ; SR13353
	; Adding to the new created class all the existing methods, and the include code as well.
	if $data(strInclude) {
		set CLASS.IncludeCode = strInclude
	}
	; SR14278
	if $data(strImport) {
		set CLASS.Import = strImport
	}
	if $data(arrClassMethods) {
		set strMethodName = $order(arrClassMethods(""))
		while strMethodName '= "" {
			set objClassMethod = ##class(%Dictionary.MethodDefinition).%New()
		
			set objClassMethod.Name = strMethodName
			do objClassMethod.Implementation.Write(arrClassMethods(strMethodName, "Implementation")) 
			set objClassMethod.FormalSpec  = arrClassMethods(strMethodName, "FormalSpec")
			set objClassMethod.ClassMethod = arrClassMethods(strMethodName, "ClassMethod")
			set objClassMethod.ReturnType  = arrClassMethods(strMethodName, "ReturnType")
			
			do CLASS.Methods.Insert(objClassMethod)
			
			set strMethodName = $order(arrClassMethods(strMethodName))
		}
	}
 
	SET SUCCESS=CLASS.%Save()
	QUIT SUCCESS
	
]]></Routine>
</Export>
