<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="22" zv="Cache for Windows (x86-32) 2008.2 (Build 615U)">
<Routine name="WWW001OO" type="MAC" languagemode="0"><![CDATA[
WWW001OO
#include WWWConst
#include COMSYS
	;-------------------------------------------------------------------------------
	; Description of Function :
	;		WWW001OO
	;		@net-Klassen zu Cache-Klassen mit Hilfe des %Dictionary-Packets konvertieren
	;
	; Inputs : 
	;
	; ByRef :
	;
	; Returns :
	;
	; History :
	; 24-Jul-2007	Frank	BR014485: Comment out the usage of MAXVAL property.
	; 							If we set the MAXVAL of a integer datafield to be
	; 							10, the only allowed values are 0,1,2,3,...,10.
	; 							It has nothing to do with the size of the field. 
	; 11-Jul-2006	RPW		SR11964: If we fail to delete the object, quit with the
	; 							error.
	; 08-Feb-2006	Frank F	SR14278: Keeping the current class import statements in
	; 							the new created class.
	; 28-Oct-2005	Frank F	SR13353: Keeping the current class methods in the new
	; 							created class.
	; 07-Jul-2005	Steve S	SR12854: Added Calc fields for currencies
	; 22-Jun-2005	SCR		SR12755: Added Calculated fields
	; 05-Apr-2005	Paul K	Added comment for change in SR#11714. Counter fields
	; 							can be strings
	; 12.07.2004	OJR
	; 17.04.2004	ARI
	;-------------------------------------------------------------------------------
	QUIT
	
COMPILE(pidClass,NOFORM,&sc)
	;-------------------------------------------------------------------------------
	;	Kompilierung aus Formular WWW001 heraus
	; Inputs:
	; 	pidClass	; Class ID
	;	NOFORM=1	; 1 - don't display messages through browser
	;				; 0 - called from a form - display messages
	;	sc			; By Ref (Status)
	;
	; History:
	; 21-Jul-2009	PPP		SR16757: Added new By Ref Parameter 'sc' - returns status
	; 04-Mar-2009	GRF		SR16410: Stricter enforcement of "Do Not Compile This Class"
	; 23-Feb-2009	shobby	SRAdhoc: Error message is corrupted by characters 13 & 10
	; 05-Jan-2006	SC		SR14136: Don't add strPackName prefix to pidClass when
	; 							pidClass contains a ".", ie "a.b" 
	;-------------------------------------------------------------------------------
	new arrError,blnDontCompile,objANMClass,strClassName,strPackName
	
	set sc = $$$OK
	
	quit:$get(pidClass)=""
	
	set strPackName = "User"  ;will be Parameter ^WWW012(0,YM,1)...
	
	; If WWW001 D21 "No Compile (mapped class)" is ticked, a User.xxxxx class will not be generated from the @nM class.
	; Only where class contains a "." in the name and where NOFORM isn't $$$YES.
	
	set objANMClass = $get(^WWW001(0,pidClass,1))
	set blnDontCompile = $$$WWW001NoCompilemappedclass(objANMClass)
	if blnDontCompile {
		if $get(NOFORM) '= $$$YES {
			do SCRPTAL^WWWTOOLS("Class is mapped. Not compiled.")
			do ^WWWFORM
		}	
		quit
	}
	
	;---------------------------------------
	
	set sc = $$CREATE(pidClass)
	set strClassName = $select(pidClass[".":"",1:strPackName_".")_pidClass  //SR14136
 
	if $$$ISOK(sc) set sc = $SYSTEM.OBJ.Compile(strClassName,"-d",.arrError)  
	
	; Display messages if called from a form
	if $get(NOFORM) '= $$$YES {
		if $$$ISERR(sc) {
		;	FIXME : If CREATE returns $$$NO then this will display "ERROR #00: (no error description)"
		;	        This can happen if we try to compile a class with WWW001 but no WWW002 or WWW003. <GRF>
			do $SYSTEM.Status.DecomposeStatus(sc,.arrError)
		;	do SCRPTAL^WWWTOOLS($translate($$^WWWUMLAU(ERROR(1)),"'"))      ;SRAdhoc    ; FIXME : Why is this different from below? <GRF>
			do SCRPTAL^WWWTOOLS($translate(arrError(1),$$$CRLF))      
		} else {
			set sc = $SYSTEM.OBJ.Compile(strClassName,"-d",.arrError) 
			
			if sc {
				do SCRPTAL^WWWTOOLS($$^WWWTEXT("WWW00061")) ; "Compile Done."
			
			} else {   ; Convert each actual double quote to 3 character representation and all $$$CRLF to "new line" instruction
				do SCRPTAL^WWWTOOLS($$SUBSTR^WWWTOOLS($$SUBSTR^WWWTOOLS($$^WWWUMLAU(arrError(1)),"""","#34"),$$$CRLF,"\n"))
			}
		}
		do ^WWWFORM
	}
	quit
	
	
CREATEALL ;
	DO ^WWWBACK
	NEW A,OK,START
	SET A="",START=$PIECE($HOROLOG,",",2)
	FOR  SET A=$ORDER(^WWW001(0,A)) QUIT:A=""  DO
	. IF '$DATA(^WWW002(0,A)),'$DATA(^WWW003(0,A)) QUIT
	. SET OK = $$CREATE^WWW001OO(A)
	. IF 'OK DO $SYSTEM.OBJ.DisplayError(OK) 
	. WRITE " ",A,!,YCR,"<BR> "
	
	;WRITE !,$PIECE($HOROLOG,",",2)-START
	quit
	
CREATEPART ;
	DO ^WWWBACK
	IF $GET(SPRACHE)="" SET SPRACHE="EN"   ;TYBD;17.05.2004;
	SET VORG(1)=$TRANSLATE($GET(VORG(1)),",",";")
	
	;IF VORG(1)="" IF VORG(3)=1 DO CREATEALL Q  ;COMPILE ALL
	
	SET VORGX="" 
	FOR  SET VORGX=$ORDER(^WWW001(0,VORGX)) QUIT:VORGX=""  DO
	. IF VORG(1)'="" QUIT:'$FIND(";"_VORG(1)_";",";"_VORGX_";")  ;NICHT AUSGEWÄHLT
	. IF '$DATA(^WWW002(0,VORGX)) QUIT
	. QUIT:VORGX="WWW000"                                        ;ROUTINE
	. IF '$DATA(^WWW002(0,VORGX)),'$DATA(^WWW003(0,VORGX)) QUIT
	. SET OK = $$CREATE^WWW001OO(VORGX)
	. WRITE "<BR>",YCR,VORGX," "
	. IF 'OK DO $SYSTEM.OBJ.DisplayError(OK) QUIT
	. WRITE "OK"
	
	quit
	
	
CREATE(pidClass)
	;-------------------------------------------------------------------------------
	; History :
	; 28-Oct-2009	GRF		-: Missing parentheses around IF clause
	; 17-Jul-2009	shobby	SR16701: Changed Memo fields to %String from %Stream
	; 06-Mar-2009	GRF		SR16410: Stricter enforcement of "Do Not Compile This
	; 							Class"; class & boolean macros; reuse class objects;
	; 							get text once as strCompany; separate some processes
	; 19-Dec-2008	shobby	16248: Put back the code that preserves existing methods
	; 						with the exception of any calculated methods which will
	; 						be regenerated anyway.
	; 02-Oct-2008	shobby	BR014985: Make classes inherit from XML.Adaptor
	; 30-Jul-2007	GRF		SR15571: STORAGE not STOARAGE
	; 13-Jul-2007	RPW		SR15571: Use WWW.DiscTimestamp so that object access and
	; 							global access for timestamps are the same
	; 15-May-2007	RPW/GRF	SR15516: Do not worry about customisation on compilation,
	; 							it's not nice.  Naked References
	; 29-Mar-2007	RPW		SR15488: If we are 2007, use SetAt for parameters not
	; 							Data, looks based on Caché4 Syntax not 5.
	;-------------------------------------------------------------------------------
	if $get(pidClass)=""                                          quit $$$NO
	if '$data(^WWW001(0,pidClass))                                quit $$$NO
	if '$data(^WWW002(0,pidClass)) && '$data(^WWW003(0,pidClass)) quit $$$NO
	
	new arrClassMethods,ATNETTYPE,blnIs2007,blnSharedFile,CACHECLASS,CAPTION,CLASS,CLASSX,DATA
	new FELDNR,GLOBAL,GLOBREF,IDFIELD,idReserved,INDEX,INDEXNR,idxMethod,loop
	new METHNAME,METHOD,objANMClass,objCacheClass,objClassMethods,objClassMethod
	new PACKNAME,PARAMETERS,PROP,PROPNAME
	new sc,SIZE,SPRACHE,SQLDATA,SQLMAP,SQLSUBSCRIPT,STORAGE
	new strCaption,strCompany,strDelimiter,strImport,strInclude,strMethodName,strPropList
	new WWWOO1,WWW002,WWW003,YSKEY
	
	; SR16410 vvv
	set SPRACHE    = "EN"           ; guarantees consistent language in object classes
	set strCompany = $$^WWWTEXT("400;Mandant")      ; "Company"
	
	set objANMClass = $get(^WWW001(0,pidClass,1))
	quit:$$$WWW001NoCompilemappedclass(objANMClass)=$$$YES $$$YES  ; *** DO NOT COMPILE THESE CLASSES ***
	
	set blnIs2007 = $SYSTEM.Version.GetMajor()>"2006" // SR15488
	
	DO
	. new OBJECT
	. if '$data(^WWW002(0,pidClass)) quit
	. quit:pidClass="WWW000"   ;ROUTINE
	. ;SET YDATA=$GET(^WWW001(0,pidClass,1))
	. ;set YDATA = objANMClass
	. quit:$$$WWW001NoCompilemappedclass(objANMClass)=$$$YES
	. ;
	. set NOCOMPILE=0  ;COMPILE OK
	. ;do NEU  ;NEUE ÜBERTRAGUNG ;recent translation 
	. ;SET DELIM  =  $piece(objANMClass,Y,11)
	. ;if +DELIM=0 SET DELIM=126  ;TRENNZEICHNEN
	. set OBJECT = +$piece(objANMClass,Y,8)
	. if (OBJECT'=0) && (OBJECT'=4) && (OBJECT'=3) quit  ;NICHT AUSWERTEN WENN ROUTINE ODER ABA ODER SONSTIGES ;Not when routine Or Or 
	. ;
	. ;SET SORT=""    ; Not used
	. do CheckForDoubles(pidClass)
	. do ^WWWSORTKEY(pidClass)  ; sets YSKEY() array ; FIXME : Not used before called again below <GRF>
	. do FixPropNames(pidClass,strCompany)
	
	
	; Package Name
	;---------------------------------------
	set PACKNAME="User"  ; Package Name    ; will be Parameter ^WWW012(0,YM,1)...
	set CLASSX = pidClass
	if $piece($GET(^WWW0011(0,pidClass,SPRACHE,1)),Y,2)'="" SET CLASSX = $piece(^WWW0011(0,pidClass,SPRACHE,1),Y,2)
	if pidClass'["." {
		set CACHECLASS = PACKNAME_"."_CLASSX
	} else {
		set CACHECLASS = pidClass
	}
	
	if ##class(%Dictionary.ClassDefinition).%ExistsId(CACHECLASS) {
		new strName,strClass
		; SR13353
		; Saving all the variables in an array to add them later to a new created class.
		set objCacheClass   = ##class(%Dictionary.ClassDefinition).%OpenId(CACHECLASS)
		; FIXME : May get objCacheClass=$$$NULLOREF if class is locked for editing (?) <GRF>
		set objClassMethods = objCacheClass.Methods
		set strInclude      = objCacheClass.IncludeCode
		set strImport       = objCacheClass.Import                   ;SR14278
		
		;16248 VVV Put this block of code back in
		for idxMethod = 1 : 1 : objClassMethods.Count() {
			set objClassMethod = objClassMethods.GetAt(idxMethod)
			set strName= objClassMethods.GetAt(idxMethod).Name
		;	if $extract(strName,$length(strName)-6,$length(strName))'="BASEGet" {
			if $extract(strName,$length(strName)-2,$length(strName))="Get" {
				set strName=$extract(strName,1,$length(strName)-3)
			}
			set strClass=CACHECLASS
			if $piece(strClass,".",1)="User" {
				set strClass=$piece(strClass,".",2,9999)
			}
			if '$data(^WWW003Calcs(0,1,$$$Index(strName),strClass)) {
				; Don't preserve calculated methods.
				set arrClassMethods(objClassMethod.Name, "Implementation") = objClassMethod.Implementation.Read()
				set arrClassMethods(objClassMethod.Name, "FormalSpec")     = objClassMethod.FormalSpec
				set arrClassMethods(objClassMethod.Name, "ClassMethod")    = objClassMethod.ClassMethod
				set arrClassMethods(objClassMethod.Name, "ReturnType")     = objClassMethod.ReturnType
			}
		}
		;16248 ^^^
 
		set sc = ##class(%Dictionary.ClassDefinition).%DeleteId(CACHECLASS)
		
		if $$$ISERR(sc) quit sc                      ; *** EARLY EXIT ***
	}
	;SET WWW001=$GET(^WWW001(0,pidClass,1))
	;quit:$piece(WWW001,"~",21) 1                    ; D21   $$$WWW001NoCompilemappedclass()
	
	; General Class Definition
	;---------------------------------------
	set CLASS=##class(%Dictionary.ClassDefinition).%New()
	set CLASS.Description = $$$WWW001ClassDescription(objANMClass)     ; D1
	if $data(^WWW0011(0,pidClass,SPRACHE,1)) {
		set CLASS.Description = CLASS.Description_"/"_$piece($get(^WWW0011(0,pidClass,SPRACHE,1)),Y,1)
	}
	set CLASS.Description=CLASS.Description_":"
	if '$$ISEMPTY^WWWMEMO($$$WWW001Description(objANMClass)) {     ; D19
		set CLASS.Description = CLASS.Description_"<br>"_$$TOHTML^WWWMEMO($$$WWW001Description(objANMClass))
	}
	
	set CLASS.Super = "%Library.Persistent,%XML.Adaptor,%Library.Populate"  
	if $$$WWW001InheritsFromSuperClasses(objANMClass)'="" set CLASS.Super = $$$WWW001InheritsFromSuperClasses(objANMClass) ; D20
	if CLASS.Super="Library.Persistent"                   set CLASS.Super = "%Library.Persistent"
	if '$find(CLASS.Super,"%XML.Adaptor")                 set CLASS.Super = CLASS.Super_",%XML.Adaptor" ;BR014985
	
	set CLASS.ClassType = "persistent"
	set CLASS.Name      = CACHECLASS
	
	; Company Property
	;---------------------------------------
	set blnSharedFile = '$$$WWW001SharedFile(objANMClass)     ; D3  [Company = YM or 0]
	
	if blnSharedFile DO
	. SET PROP=##class(%Dictionary.PropertyDefinition).%New()
	. DO CLASS.Properties.Insert(PROP)
	. SET PROP.Name     = strCompany             ;"Company"
	. SET PROP.Type     = "%String"
	. SET PROP.Required = $$$YES
	. if blnIs2007 do  // SR15488
	. . do PROP.Parameters.SetAt(30,"MAXLEN")
	. . do PROP.Parameters.SetAt("attribute","XMLPROJECTION")
	. if 'blnIs2007 do  // SR15488
	. . SET PROP.Parameters.Data("MAXLEN")        = 30
	. . SET PROP.Parameters.Data("XMLPROJECTION") = "attribute"
	
	; Properties : Primary Keys and Data Fields
	;---------------------------------------
	FOR GLOBAL="WWW002","WWW003" DO
	. SET GLOBREF = "^"_GLOBAL_"(0,pidClass)"
	. SET FELDNR  = ""
	. FOR  SET FELDNR = $order(@GLOBREF@(FELDNR)) quit:FELDNR=""  DO
	. . set SIZE = ""                                           ; SR16701
	. . SET DATA    = @GLOBREF@(FELDNR,1)
	. . SET IDFIELD = (GLOBAL="WWW002")
	. . SET PROP    = ##class(%Dictionary.PropertyDefinition).%New()
	. . DO CLASS.Properties.Insert(PROP)
	. . SET PROP.Name = $$$WWW003PropertyName(DATA)
	. . ;
	. . SET ATNETTYPE = $$$WWW003InputType(DATA)
	. . if ATNETTYPE'=16 set PROP.Type = $$TypeDesc(ATNETTYPE)
	. . if ATNETTYPE=3   set SIZE      = 32000                  ; SR16701
	. . if 'IDFIELD if ATNETTYPE=16 if $piece($GET(^WWW003(0,pidClass,FELDNR,1)),Y,26)'="" DO  quit
	. . . SET PROP.Type = $$$WWW003AlternateInputType(^WWW003(0,pidClass,FELDNR,1))  ; D26
	. . . if $$$WWW003AlternateInputType(^WWW003(0,pidClass,FELDNR,1))'["." do
	. . . . SET PROP.Type = PACKNAME_"."_$$$WWW003AlternateInputType(^WWW003(0,pidClass,FELDNR,1)) ; D26
	. . ;
	. . ;ARI 240504 brauchen wir nicht I PROP.Type="%String",$F($$UPCASE^ECVSIMP($$$WWW003xPROPERTYNAME(DATA)),"NAME") S PROP.Type="%Name"
	. . SET PARAMETERS=""
	. . ;ARI 021203 bei PrimaryKey-Feldern muss man die Collation auf EXACT
	. . ;setzen, sonst geht Kompilierung ab Cache 5.0.4 schief.
	. . if IDFIELD && (PROP.Type="%String") || (PROP.Type="%Name") do
	. . . if blnIs2007  do PROP.Parameters.SetAt("EXACT","COLLATION")   // SR15488
	. . . if 'blnIs2007 set PROP.Parameters.Data("COLLATION")="EXACT"   // SR15488
	. . ;
	. . ; Added Type 3 - Memo SRxxxx - Not adding SIZE to Memo field
	. . if $CASE(ATNETTYPE,3:1,5:1,6:1,10:1,:0) DO
	. . . if SIZE="" set SIZE = $$$WWW003InputLength(DATA)                   ;SR16701
	. . . if blnIs2007  do PROP.Parameters.SetAt(SIZE,"MAXLEN")   // SR15488 ;SR16701
	. . . if 'blnIs2007 set PROP.Parameters.Data("MAXLEN")=SIZE   // SR15488 ;SR16701
	. . ;BR014485 commented
	. . ;if $CASE(ATNETTYPE,4:1,8:1,:0) DO
	. . ;. if blnIs2007  do PROP.Parameters.SetAt($EXTRACT(999999999,1,$$$WWW003InputLength(DATA)),"MAXVAL") // SR15488
	. . ;. if 'blnIs2007 set PROP.Parameters.Data("MAXVAL")=$EXTRACT(999999999,1,$$$WWW003InputLength(DATA)) // SR15488
	. . SET CAPTION    = $$$WWW003PropertyDescription(DATA)
	. . set strCaption = $GET(@("^"_GLOBAL_"1")@(0,pidClass,FELDNR,SPRACHE,1)) // SR15516
	. . if strCaption'="" SET CAPTION = strCaption                           // SR15516
	. . if blnIs2007  do PROP.Parameters.SetAt(CAPTION,"CAPTION")               // SR15488
	. . if 'blnIs2007 set PROP.Parameters.Data("CAPTION") = CAPTION             // SR15488
	. . if IDFIELD do
	. . . if blnIs2007  do PROP.Parameters.SetAt("attribute","XMLPROJECTION")   // SR15488
	. . . if 'blnIs2007 set PROP.Parameters.Data("XMLPROJECTION") = "attribute" // SR15488
	. . if IDFIELD || $$$WWW003MandatoryField(DATA) SET PROP.Required=$$$YES
	. . SET PROP.Description = $$$WWW003PropertyDescription(DATA)
	. .;if 'IDFIELD && $$$WWW003CachCollection(DATA)=$$$YES DO   ; 28-Oct-2009
	. . if 'IDFIELD && ($$$WWW003CachCollection(DATA)=$$$YES) DO
	. . . SET PROP.Collection       = "list"
	. . . SET PROP.SqlListDelimiter = """;"""
	. . . SET PROP.SqlListType      = "delimited"
	. . ;
	. . ;  FIXME : Braces inside dot level syntax; NOFORM cf YNOFORM <GRF>
	. . if $get(YNOFORM)=1 set sc = CLASS.%Save() if 'sc { write !,GLOBAL_"::"_pidClass_":"_PROP.Name_" "_FELDNR do DisplayError^%apiOBJ(sc) quit}
	
	; Add "Calculated, SqlComputeCode" properties (and Methods?) for Calculated Fields
	;---------------------------------------
	do CalcCurrencyFields^WWW001CalcFields(pidClass)        ; Calc Fields for Currencies SR12854
	do CalcFields^WWW001CalcFields(pidClass,.CLASS)         ; Calculated Fields SR12755
	
	; Get Primary Key Properties and apply to Index definition
	;---------------------------------------
	set strPropList = ""
	if blnSharedFile do INSERT^WWWPLIST(.strPropList,strCompany)  ; "Company"
	set FELDNR = ""
	for  {
		set FELDNR = $order(^WWW002(0,pidClass,FELDNR))
		quit:FELDNR=""
		
		set WWW002 = $get(^WWW002(0,pidClass,FELDNR,1))
		do INSERT^WWWPLIST(.strPropList,$$$WWW002PropertyName(WWW002),$$$NO,$$$COMMA)    ; D25	()
	}
	
	SET INDEX=##class(%Dictionary.IndexDefinition).%New()
	DO CLASS.Indices.Insert(INDEX)
	SET INDEX.Properties      = strPropList
	SET INDEX.Name            = "IDKEY"
	SET INDEX.PrimaryKey      = 1
	SET INDEX.IdKey           = 1
	SET INDEX.Unique          = 1               ;ARI 040704
	
	
	; Identify @nManager tilde-delimited structures for SQL as "map1"
	;---------------------------------------
	SET CLASS.StorageStrategy = "StorageAtNet"
	
	SET STORAGE               = ##class(%Dictionary.StorageDefinition).%New()
	DO CLASS.Storages.Insert(STORAGE)
	SET STORAGE.Type      = "%CacheSQLStorage"
	SET STORAGE.Name      = "StorageAtNet"
	
	SET SQLMAP            = ##class(%Dictionary.StorageSQLMapDefinition).%New()
	DO STORAGE.SQLMaps.Insert(SQLMAP)
	SET SQLMAP.Name       = "map1"
	SET SQLMAP.Type       = "data"
	SET SQLMAP.Global     = "^"_pidClass
	SET SQLMAP.Structure  = "delimited"
	
	SET SQLSUBSCRIPT      = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	SET SQLSUBSCRIPT.Name = 1
	if blnSharedFile {
		SET SQLSUBSCRIPT.Expression = "{"_strCompany_"}"
	} else {
		SET SQLSUBSCRIPT.Expression = 0
	}
	
	; Add Primary Keys to map
	;---------------------------------------
	SET FELDNR = ""
	FOR  SET FELDNR = $order(^WWW002(0,pidClass,FELDNR)) quit:FELDNR=""  DO
	. SET SQLSUBSCRIPT = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name       = FELDNR+1
	. SET SQLSUBSCRIPT.Expression = "{"_$$$WWW002PropertyName($get(^WWW002(0,pidClass,FELDNR,1)))_"}"  ; D25
	
	SET SQLSUBSCRIPT = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	SET SQLSUBSCRIPT.Name       = $order(^WWW002(0,pidClass,""),-1)+2
	SET SQLSUBSCRIPT.Expression = 1
	
	set strDelimiter = $$$WWW001AltDelimiterASCII(objANMClass)    ; D11
	if +strDelimiter=0 {
		set strDelimiter = Y                     ; "~"
	} else {
		set strDelimiter = $char(strDelimiter)
	}
	
	; Add Data Fields to map
	;---------------------------------------
	SET FELDNR = ""
	FOR  SET FELDNR = $order(^WWW003(0,pidClass,FELDNR)) quit:FELDNR=""  DO
	. SET SQLDATA = ##class(%Dictionary.StorageSQLMapDataDefinition).%New()
	. DO SQLMAP.Data.Insert(SQLDATA)
	. SET SQLDATA.Name      = $$$WWW003PropertyName($get(^WWW003(0,pidClass,FELDNR,1)))  ; D25
	. ;write SQLDATA.Name,!
	. ;if $DATA(^WWW003D(0,pidClass,FELDNR,YM,1)) SET SQLDATA.Name=$piece(^(1),Y,25)
	. SET SQLDATA.Delimiter = """"_strDelimiter_""""
	. SET SQLDATA.Piece     = FELDNR
	
	; Build list of @nM Indices into YSKEY and transfer
	; them to separate maps "SortIndex#" for SQL
	;---------------------------------------
	DO ^WWWSORTKEY(pidClass)  ; sets YSKEY() array e.g. YSKEY(6) = "K1,F2,K3" where index 6 is based on three fields P1, D2 & P3
	
	SET INDEXNR = ""
	FOR  SET INDEXNR = $order(YSKEY(INDEXNR)) quit:INDEXNR=""  DO
	. SET SQLMAP = ##class(%Dictionary.StorageSQLMapDefinition).%New()
	. DO STORAGE.SQLMaps.Insert(SQLMAP)
	. SET SQLMAP.Name      = "SortIndex"_INDEXNR
	. SET SQLMAP.Type      = "index"
	. SET SQLMAP.Global    = "^"_pidClass_"s"
	. SET SQLMAP.Structure = "delimited"
	. SET SQLSUBSCRIPT     = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name = 1
	. ;if blnSharedFile SET SQLSUBSCRIPT.Expression="{"_strCompany_"}" if 1  ;"{MANDANT}" if 1
	. ;ELSE  SET SQLSUBSCRIPT.Expression=0
	. if blnSharedFile  SET SQLSUBSCRIPT.Expression = "{"_strCompany_"}"    ; "Company"
	. if 'blnSharedFile SET SQLSUBSCRIPT.Expression = 0
	. SET SQLSUBSCRIPT = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name       = 2
	. SET SQLSUBSCRIPT.Expression = INDEXNR
	. FOR loop=1:1:$LENGTH(YSKEY(INDEXNR),",") DO
	. . SET FELDNR  = $piece(YSKEY(INDEXNR),",",loop)
	. . SET IDFIELD = ($EXTRACT(FELDNR)="K")
	. . SET FELDNR  = $EXTRACT(FELDNR,2,$LENGTH(FELDNR))
	. . quit:FELDNR=""
	. . ;
	. . if 'IDFIELD if $$$WWW003PropertyName($GET(^WWW003(0,pidClass,FELDNR,1)))="" quit     ; D25
	. . if IDFIELD  if $$$WWW002PropertyName($GET(^WWW002(0,pidClass,FELDNR,1)))="" quit     ; D25
	. . ;
	. . SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. . DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. . SET SQLSUBSCRIPT.Name = loop+2
	. . if CACHECLASS["zzObjectTest" do
	. . . if IDFIELD  SET SQLSUBSCRIPT.Expression = "$$^WWWUMLAU({"_$$$WWW002PropertyName($get(^WWW002(0,pidClass,FELDNR,1)))_"},1)"  ; D25
	. . . if 'IDFIELD SET SQLSUBSCRIPT.Expression = "$$^WWWUMLAU({"_$$$WWW003PropertyName($get(^WWW003(0,pidClass,FELDNR,1)))_"},1)"  ; D25
	. . if CACHECLASS'["zzObjectTest" do
	. . . if IDFIELD  SET SQLSUBSCRIPT.Expression = "$$UPPER({"_$$$WWW002PropertyName($get(^WWW002(0,pidClass,FELDNR,1)))_"})"  ; D25
	. . . if 'IDFIELD SET SQLSUBSCRIPT.Expression = "$$UPPER({"_$$$WWW003PropertyName($get(^WWW003(0,pidClass,FELDNR,1)))_"})"  ; D25
	. ;
	. SET FELDNR=""
	. FOR  SET FELDNR=$order(^WWW002(0,pidClass,FELDNR)) quit:FELDNR=""  DO
	. . SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. . DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. . SET SQLSUBSCRIPT.Name       = FELDNR+$LENGTH(YSKEY(INDEXNR),",")+2
	. . SET SQLSUBSCRIPT.Expression = "{"_$$$WWW002PropertyName($get(^WWW002(0,pidClass,FELDNR,1)))_"}"  ; D25
	
	; (Deprecated?) Calculated Fields (WWWCLASSCALC is not populated - WWW003Calc instead?)
	;---------------------------------------
	SET PROPNAME = ""
	FOR  SET PROPNAME = $order(^WWWCLASSCALC(0,pidClass,PROPNAME)) quit:PROPNAME=""  DO
	. SET DATA = $GET(^WWWCLASSCALC(0,pidClass,PROPNAME,1))
	. SET PROP = ##class(%Dictionary.PropertyDefinition).%New()
	. DO CLASS.Properties.Insert(PROP)
	. SET PROP.Name = PROPNAME
	. SET PROP.Type = "%String"
	. if $piece(DATA,Y,2)'="" SET PROP.Type = $piece(DATA,Y,2)
	. if '$$ISEMPTY^WWWMEMO($piece(DATA,Y,1)) SET PROP.Description=$$TOHTML^WWWMEMO($piece(DATA,Y,1))
	. SET PROP.Calculated=1
	. if '$$ISEMPTY^WWWMEMO($piece(DATA,Y,3)) DO
	. . SET PROP.SqlComputed    = 1
	. . SET $piece(DATA,Y,3)    = $$STRIPEND^WWWMEMO($piece(DATA,Y,3))
	. . SET PROP.SqlComputeCode = $$TOSTREAM^WWWMEMO($piece(DATA,Y,3))
	
	; (Deprecated?) @nM Methods (WWWCLASSMETH is not populated)
	;---------------------------------------
	SET METHNAME = ""
	FOR  SET METHNAME = $order(^WWWCLASSMETH(0,pidClass,METHNAME)) quit:METHNAME=""  DO
	. SET DATA   = $GET(^WWWCLASSMETH(0,pidClass,METHNAME,1))
	. SET METHOD = ##class(%Dictionary.MethodDefinition).%New()
	. DO CLASS.Methods.Insert(METHOD)
	. SET METHOD.Name        = METHNAME
	. SET METHOD.ClassMethod =+$piece(DATA,Y,3)
	. SET METHOD.FormalSpec  = $piece(DATA,Y,2)
	. SET METHOD.ReturnType  = $piece(DATA,Y,4)
	. DO METHOD.Implementation.Write($$TOSTREAM^WWWMEMO($piece(DATA,Y,1)))
	
	; Restore existing methods, etc.
	;---------------------------------------                    ; SR13353
	; Adding to the new created class all the existing methods, and the include code as well.
	if $data(strInclude) set CLASS.IncludeCode = strInclude
	if $data(strImport)  set CLASS.Import      = strImport      ; SR14278
	
	if $data(arrClassMethods) {
		set strMethodName = $order(arrClassMethods(""))
		while strMethodName '= "" {
			set objClassMethod = ##class(%Dictionary.MethodDefinition).%New()
		
			set objClassMethod.Name              = strMethodName
			do objClassMethod.Implementation.Write(arrClassMethods(strMethodName, "Implementation")) 
			set objClassMethod.FormalSpec        = arrClassMethods(strMethodName, "FormalSpec")
			set objClassMethod.ClassMethod       = arrClassMethods(strMethodName, "ClassMethod")
			set objClassMethod.ReturnType        = arrClassMethods(strMethodName, "ReturnType")
			
			do CLASS.Methods.Insert(objClassMethod)
			
			set strMethodName = $order(arrClassMethods(strMethodName))
		}
	}
	
	set sc = CLASS.%Save()
	quit sc
	
	
CheckForDoubles(pidClass)
	;-------------------------------------------------------------------------------
	; Property Name Validation - Strips any problem Property Names to be rebuilt later
	; 1. Is it a reserved SQL word?
	; 2. Has it already been used?
	; 3. Does it start with a numeral? 0-9
	; 
	; As each is read, add to WWWSOR and clear any further occurrences
	; File as case-sensitive and case-insensitive
	; 
	; History :
	; 06-Mar-2009	GRF		SR16410: Separate functionality
	;-------------------------------------------------------------------------------
	new idFldNo,idxPropName,objClassData,strPropName
	
	; FIXME : Index 3.2 on this piece - Reindex? <GRF>
	; FIXME : Doesn't check if WWW003 names are duplicates of WWW002 names. <GRF>
	
	kill ^WWWSOR(YUSER)
	set idFldNo = ""
	for  {
		set idFldNo = $order(^WWW003(0,pidClass,idFldNo))
		quit:idFldNo=""
		
		set objClassData = $get(^WWW003(0,pidClass,idFldNo,1))
		set strPropName  = $$$WWW003PropertyName(objClassData)
		quit:strPropName=""
		
		set idxPropName = $$^WWWUMLAU(strPropName,1)
		if $data(^WWWRESs(0,1,idxPropName)) {
			set $$$WWW003PropertyName(^WWW003(0,pidClass,idFldNo,1)) = ""  
		
		} elseif $data(^WWWSOR(YUSER,strPropName)) {
			set $$$WWW003PropertyName(^WWW003(0,pidClass,idFldNo,1)) = ""
		
		} elseif ($extract(strPropName)=0) || (+$extract(strPropName)'=0) {
			set $$$WWW003PropertyName(^WWW003(0,pidClass,idFldNo,1)) = ""
		
		} else {
			set ^WWWSOR(YUSER,strPropName) = ""
			set ^WWWSOR(YUSER,idxPropName) = ""
		}
	}
	quit
	
	
FixPropNames(pidClass,pstrCompany)
	;-------------------------------------------------------------------------------
	; Reconstruct property names from descriptions - any duplicates get incrementing suffix
	; 
	; 1. Add reserved words to list (incl "Company")
	; 2.
	; 
	; Returns: 
	; 
	; History :
	; 06-Mar-2009	GRF		SR16410: Separate functionality
	;-------------------------------------------------------------------------------
	new idFldNo,idReserved,idxPropName,intSuffix,loop
	new objClassData,objClassKey,objDataLang,objKeyLang
	new strBase,strNewName,strPropName,strXlate
	
	;IF Z=5 {
	;	SET LW5="ÜÄÖüäöß][\}{|~ ,()@#$%^&*_=+<>?/"_$CHAR(128)_""""
	;	                       ^^^^   ^ ^^^ ^   ^      ^
	;	set UP5="UAOUAOSUAOUAOS"
	
	set strXlate = " .-,'`´/+*%&();:!_"
	;               ^  ^   ^^^^^^^   ^   ; Repeated Translation + $CHAR(128)
	for loop=128:1:255 set strXlate = strXlate_$char(loop)
	
	kill ^WWWSOR(YUSER)
	set ^WWWSOR(YUSER,$$^WWWUMLAU(pstrCompany,1)) = ""   ; "Company" is not permitted [as "COMPANY" for comparison]
	
	; List of Reserved SQL Words
	;-------------------------------------
	set idReserved = ""
	for  {
		set idReserved = $order(^WWWRES(0,idReserved))
		quit:idReserved=""
		
		set idxPropName = $$^WWWUMLAU($get(^WWWRES(0,idReserved,1)),1)
		quit:idxPropName=""
		set ^WWWSOR(YUSER,idxPropName) = ""
	}
	
	set idFldNo=""
	for  {
		set idFldNo = $order(^WWW002(0,pidClass,idFldNo))
		quit:idFldNo=""
		
		set objClassKey = $get(^WWW002(0,pidClass,idFldNo,1))
		set strPropName  = $$$WWW002PropertyName(objClassKey)
		quit:$find(strPropName,".")
		
		if $translate(strPropName," ")'="" {     ; FIXME : Prop Name can't have spaces anyway <GRF>
			set strNewName = strPropName
		} else {
			set strNewName = $$$WWW002PropertyDescription(objClassKey)
			set objKeyLang = $get(^WWW0021(0,pidClass,idFldNo,SPRACHE,1))
			if objKeyLang'="" {
				set strNewName = $translate($extract($$^WWWUMLAU($piece(objKeyLang,Y,1),5),1,25),strXlate)
			}
		}
		set strNewName = $translate($extract($$^WWWUMLAU(strNewName,5),1,25),strXlate)
		if strNewName'="" {
			set strBase = strNewName
			for intSuffix=1:1 {     ; "XXX" => "XXX1", "XXX2", etc.
				if $data(^WWWSOR(YUSER,$$^WWWUMLAU(strNewName,1))) set strNewName = strBase_intSuffix
			
				if '$data(^WWWSOR(YUSER,$$^WWWUMLAU(strNewName,1))) {  ; new index required  - strNewName may have had suffix added
					set ^WWWSOR(YUSER,$$^WWWUMLAU(strNewName,1)) = ""
					set ^WWWSOR(YUSER,222,idFldNo)               = strNewName
					quit
				}
			}
		}
		if strNewName'="" && ($translate(strPropName," ")="") {
			set $$$WWW002PropertyName(^WWW002(0,pidClass,idFldNo,1)) = strNewName  ; D25  ; FIXME : Index 3.2 on this piece - Reindex? <GRF>
		}
	}
	
	/*   Remove after peer review ot SR16410
	SET LFN=""
	FOR  SET LFN=$order(^WWW002(0,iCLASS,LFN)) QUIT:LFN=""  DO
	. SET LF=$GET(^WWW002(0,iCLASS,LFN,1))
	. QUIT:$FIND($$$WWW002PropertyName(LF),".")
	. ;
	. SET ATTX=""
	. IF $GET(^WWW0021(0,iCLASS,LFN,SPRACHE,1))'=""    SET $$$WWW002PropertyDescription(LF)=$TRANSLATE($EXTRACT($$^WWWUMLAU($PIECE(^WWW0021(0,iCLASS,LFN,SPRACHE,1),Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. IF $TRANSLATE($$$WWW002PropertyName(LF)," ")'="" SET $$$WWW002PropertyDescription(LF)=$$$WWW002PropertyName(LF)
	. SET ATTX=$TRANSLATE($EXTRACT($$^WWWUMLAU($PIECE(LF,Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. ;
	. IF ATTX'="" SET ATTXX=ATTX FOR ATTNU=1:1 DO  IF '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) SET ^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))="" SET ^WWWSOR(YUSER,222,LFN)=ATTX QUIT
	. . IF '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) QUIT
	. . SET ATTX=ATTXX_ATTNU
	. IF ATTX'="" IF $TRANSLATE($$$WWW002PropertyName(LF)," ")="" SET $$$WWW002PropertyName(^WWW002(0,iCLASS,LFN,1))=ATTX
	*/
	
	set idFldNo=""
	for  {
		set idFldNo = $order(^WWW003(0,pidClass,idFldNo))
		quit:idFldNo=""
		
		set objClassData = $get(^WWW003(0,pidClass,idFldNo,1))
		set strPropName  = $$$WWW003PropertyName(objClassData)
		quit:$find(strPropName,".")
		
		if $translate(strPropName," ")'="" {     ; FIXME : Prop Name can't have spaces anyway <GRF>
			set strNewName = strPropName
		} else {
			set strNewName = $$$WWW003PropertyDescription(objClassData)
			set objDataLang = $get(^WWW0031(0,pidClass,idFldNo,SPRACHE,1))
			if objDataLang'="" {
				set strNewName = $translate($extract($$^WWWUMLAU($piece(objDataLang,Y,1),5),1,25),strXlate)
			}
		}
		set strNewName = $translate($extract($$^WWWUMLAU(strNewName,5),1,25),strXlate)
		if strNewName'="" {
			set strBase = strNewName
			for intSuffix=1:1 {     ; "XXX" => "XXX1", "XXX2", etc.
				if $data(^WWWSOR(YUSER,$$^WWWUMLAU(strNewName,1))) set strNewName = strBase_intSuffix
			
				if '$data(^WWWSOR(YUSER,$$^WWWUMLAU(strNewName,1))) {  ; new index required  - strNewName may have had suffix added
					set ^WWWSOR(YUSER,$$^WWWUMLAU(strNewName,1)) = ""
					set ^WWWSOR(YUSER,333,idFldNo)               = strNewName
					quit
				}
			}
		}
		if strNewName'="" && ($translate(strPropName," ")="") {
			set $$$WWW003PropertyName(^WWW003(0,pidClass,idFldNo,1)) = strNewName  ; D25  ; FIXME : Index 3.2 on this piece - Reindex? <GRF>
		}
	}
	/*   Remove after peer review ot SR16410
	SET LFN=""
	FOR  SET LFN=$order(^WWW003(0,iCLASS,LFN)) QUIT:LFN=""  DO
	. SET LF=$GET(^WWW003(0,iCLASS,LFN,1))
	. QUIT:$FIND($$$WWW003PropertyName(LF),".")
	. ;
	. SET ATTX=""
	. IF $GET(^WWW0031(0,iCLASS,LFN,SPRACHE,1))'="" do
	. . SET $$$WWW003PropertyDescription(LF) = $TRANSLATE($EXTRACT($$^WWWUMLAU($PIECE(^WWW0031(0,iCLASS,LFN,SPRACHE,1),Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. IF $TRANSLATE($$$WWW003PropertyName(LF)," ")'="" SET $$$WWW003PropertyDescription(LF) = $$$WWW003PropertyName(LF)
	. SET ATTX=$TRANSLATE($EXTRACT($$^WWWUMLAU($$$WWW003PropertyDescription(LF),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. ;
	. IF ATTX'="" SET ATTXX=ATTX FOR ATTNU=1:1 DO  IF '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) SET ^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))="" SET ^WWWSOR(YUSER,333,LFN)=ATTX QUIT
	. . IF '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) QUIT
	. . SET ATTX=ATTXX_ATTNU
	. IF ATTX'="" IF $TRANSLATE($$$WWW003PropertyName(LF)," ")="" SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1))=ATTX
	*/
	
	quit
	
	
TypeDesc(penumType)
	;-------------------------------------------------------------------------------
	; Convert Input Types from enum to object type 
	; 
	; History :
	; 06-Mar-2009	GRF		SR16410: Separate functionality
	;-------------------------------------------------------------------------------
	new strResult
	
	set strResult = $case(penumType,
	                       1:"WWW.DiscDate",
	                       2:"%Boolean",
	                       3:"%String",
	                       4:"%Numeric",
	                       5:"%String",
	                       6:"%String",
	                       7:"%Time",
	                       8:"%Currency",
	                       9:"%String",
	                      10:"%String",
	                      11:"%String",
	                      12:"%Float",
	                      13:"%String",
	                      14:"WWW.DiscTimestamp",
	                      15:"%List",
	                        :"%String")
	quit strResult
	;---------------------------------------
	; previously
	; 1:"%Date"
	; 3:"%Stream"        ]]><![CDATA[;SR16701
	; 14:"%TimeStamp"
	
	; not covered - default to %String
	; 16:	Embedded  - special handling when called
	; 17:	Date (YYYYMMDD)
	; 18:	Exchange Rate
	;---------------------------------------
	

	/*	
CREATE(iCLASS) ; SR16410 replaced
	;-------------------------------------------------------------------------------
	; History :
	; 28-Oct-2009	GRF		-: Missing parentheses around IF clause
	; 17-Jul-2009	shobby	SR16701: Changed Memo fields to %String from %Stream
	; 06-Mar-2009	GRF		SR16410: Stricter enforcement of "Do Not Compile This
	; 							Class"
	; 19-Dec-2008	shobby	16248: Put back the code that preserves existing methods
	; 						with the exception of any calculated methods which will
	; 						be regenerated anyway.
	; 02-Oct-2008	shobby	BR014985: Make classes inherit from XML.Adaptor
	; 30-Jul-2007	GRF		SR15571: STORAGE not STOARAGE
	; 13-Jul-2007	RPW		SR15571: Use WWW.DiscTimestamp so that object access and
	; 							global access for timestamps are the same
	; 15-May-2007	RPW/GRF	SR15516: Do not worry about customisation on compilation,
	; 							it's not nice.  Naked References
	; 29-Mar-2007	RPW		SR15488: If we are 2007, use SetAt for parameters not
	; 							Data, looks based on Caché4 Syntax not 5.
	;-------------------------------------------------------------------------------
	if $get(iCLASS)=""                                        quit $$$NO
	if '$data(^WWW001(0,iCLASS))                              quit $$$NO
	if '$data(^WWW002(0,iCLASS)) && '$data(^WWW003(0,iCLASS)) quit $$$NO
	
	new arrClassMethods,ATNETTYPE,blnIs2007,blnSharedFile,CACHECLASS,CAPTION,CLASS,CLASSX,DATA
	new FELDNR,GLOBAL,GLOBREF,IDFIELD,INDEX,INDEXNR,idxMethod,loop
	new METHNAME,METHOD,objANMClass,objCacheClass,objClassMethods,objClassMethod
	new PACKNAME,PARAMETERS,PROP,PROPNAME,SPRACHE,SQLDATA,SQLMAP,SQLSUBSCRIPT,STORAGE
	new strCaption,strCompany,strDelimiter,strImport,strInclude,strMethodName,strPropList
	new SIZE,SUCCESS,WWWOO1,WWW002,WWW003,YSKEY
	
	; SR16410 vvv
	set SPRACHE    = "EN"           ; guarantees consistent language in object classes
	set strCompany = $$^WWWTEXT("400;Mandant")      ; "Company"
	
	set objANMClass = $get(^WWW001(0,iCLASS,1))
	quit:$$$WWW001NoCompilemappedclass(objANMClass)=$$$YES $$$YES  ; *** DO NOT COMPILE THESE CLASSES ***
	
	set blnIs2007 = $SYSTEM.Version.GetMajor()>"2006" // SR15488
	
	DO
	. NEW ATTNU,ATTX,ATTXX,LF,LFN,OBJECT,RESN,YXCHAR
	. SET YXCHAR=""
	. FOR loop=128:1:255 SET YXCHAR=YXCHAR_$CHAR(loop)
	. if '$DATA(^WWW002(0,iCLASS)) quit
	. quit:iCLASS="WWW000"   ;ROUTINE
	. ;SET YDATA=$GET(^WWW001(0,iCLASS,1))
	. ;set YDATA = objANMClass
	. quit:$$$WWW001NoCompilemappedclass(objANMClass)=$$$YES
	. ;
	. SET NOCOMPILE=0  ;COMPILE OK
	. ;do NEU  ;NEUE ÜBERTRAGUNG ;recent translation 
	. ;SET DELIM  =  $piece(objANMClass,Y,11)
	. ;if +DELIM=0 SET DELIM=126  ;TRENNZEICHNEN
	. SET OBJECT = +$piece(objANMClass,Y,8)
	. if OBJECT'=0 if OBJECT'=4 if OBJECT'=3 quit  ;NICHT AUSWERTEN WENN ROUTINE ODER ABA ODER SONSTIGES ;Not when routine Or Or 
	. ;
	. SET SORT=""
	. DO  ;CHECK IF WORDS ARE DOUBLE ;stand-in 
	. . KILL ^WWWSOR(YUSER)
	. . SET LFN=""
	. . FOR  SET LFN = $order(^WWW003(0,iCLASS,LFN)) quit:LFN=""  DO
	. . . SET LF=$GET(^WWW003(0,iCLASS,LFN,1))
	. . . quit:$$$WWW003PropertyName(LF)=""  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . . ;
	. . . if $DATA(^WWWRESs(0,1,$$^WWWUMLAU($$$WWW003PropertyName(LF),1))) SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1)) = "" quit
	. . . if $DATA(^WWWSOR(YUSER,$$$WWW003PropertyName(LF)))               SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1)) = "" quit
	. . . if ($EXTRACT($$$WWW003PropertyName(LF))=0) || (+$EXTRACT($$$WWW003PropertyName(LF))'=0) SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1)) = "" quit  ;KEINE ZAHLEN AM ANFANG;FIS;21.04.04;25326
	. . . SET ^WWWSOR(YUSER,$$$WWW003PropertyName(LF))                = ""
	. . . SET ^WWWSOR(YUSER,$$^WWWUMLAU($$$WWW003PropertyName(LF),1)) = ""
	. ;
	. DO ^WWWSORTKEY(iCLASS)
	. KILL ^WWWSOR(YUSER)
	. ;
	. ;RESERVIERTE WÖRTER
	. SET ^WWWSOR(YUSER,strCompany)="" 
	. SET RESN=""
	. FOR  SET RESN=$order(^WWWRES(0,RESN)) quit:RESN=""  DO
	. . SET ATTX=$$^WWWUMLAU($GET(^WWWRES(0,RESN,1)),1)
	. . quit:ATTX=""
	. . SET ^WWWSOR(YUSER,ATTX)=""
	. ;
	. SET LFN=""
	. FOR  SET LFN=$order(^WWW002(0,iCLASS,LFN)) quit:LFN=""  DO
	. . SET LF = $GET(^WWW002(0,iCLASS,LFN,1))
	. . quit:$FIND($$$WWW002PropertyName(LF),".")  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . ;
	. . SET ATTX=""
	. . if $GET(^WWW0021(0,iCLASS,LFN,SPRACHE,1))'=""    SET $$$WWW002PropertyDescription(LF) = $TRANSLATE($EXTRACT($$^WWWUMLAU($piece(^WWW0021(0,iCLASS,LFN,SPRACHE,1),Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . if $TRANSLATE($$$WWW002PropertyName(LF)," ")'="" SET $$$WWW002PropertyDescription(LF) = $$$WWW002PropertyName(LF)  ;SCHON EINMAL ÜBERTRAGEN ;yet sometimes transport 
	. . SET ATTX = $TRANSLATE($EXTRACT($$^WWWUMLAU($$$WWW002PropertyDescription(LF),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . if ATTX'="" SET ATTXX = ATTX FOR ATTNU=1:1 DO  if '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) SET ^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))="" SET ^WWWSOR(YUSER,222,LFN)=ATTX quit
	. . . if '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) quit
	. . . SET ATTX = ATTXX_ATTNU
	. . if ATTX'="" if $TRANSLATE($$$WWW002PropertyName(LF)," ")="" SET $$$WWW002PropertyName(^WWW002(0,iCLASS,LFN,1)) = ATTX  ; D25  ; FIXME : Index 3.2 on this piece - Reindex? <GRF>
	. ;
	. SET LFN=""
	. FOR  SET LFN=$order(^WWW003(0,iCLASS,LFN)) quit:LFN=""  DO
	. . SET LF=$GET(^WWW003(0,iCLASS,LFN,1))
	. . quit:$FIND($$$WWW003PropertyName(LF),".")  ;DATENFELD ALS KLASSE= NICHT EINTRAGEN ;data item when Not 
	. . SET ATTX=""
	. . if $GET(^WWW0031(0,iCLASS,LFN,SPRACHE,1))'=""    SET $$$WWW003PropertyDescription(LF) = $TRANSLATE($EXTRACT($$^WWWUMLAU($piece(^WWW0031(0,iCLASS,LFN,SPRACHE,1),Y,1),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . if $TRANSLATE($$$WWW003PropertyName(LF)," ")'="" SET $$$WWW003PropertyDescription(LF) = $$$WWW003PropertyName(LF)  ;SCHON EINMAL ÜBERTRAGEN ;yet sometimes transport 
	. . SET ATTX = $TRANSLATE($EXTRACT($$^WWWUMLAU($$$WWW003PropertyDescription(LF),5),1,25)," .-,'`´/+*%&();:!_"_YXCHAR)
	. . if ATTX'="" SET ATTXX = ATTX FOR ATTNU=1:1 DO  if '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) SET ^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))="" SET ^WWWSOR(YUSER,333,LFN)=ATTX quit
	. . . if '$DATA(^WWWSOR(YUSER,$$^WWWUMLAU(ATTX,1))) quit
	. . . SET ATTX = ATTXX_ATTNU
	. . if ATTX'="" if $TRANSLATE($$$WWW003PropertyName(LF)," ")="" SET $$$WWW003PropertyName(^WWW003(0,iCLASS,LFN,1)) = ATTX   ; D25  ; FIXME : Index 3.2 on this piece - Reindex? <GRF>
	
	; Package Name
	;---------------------------------------
	SET PACKNAME="User"  ; Package Name    ; will be Parameter ^WWW012(0,YM,1)...
	SET CLASSX=iCLASS
	if $piece($GET(^WWW0011(0,iCLASS,SPRACHE,1)),Y,2)'="" SET CLASSX = $piece(^WWW0011(0,iCLASS,SPRACHE,1),Y,2)
	if iCLASS'["." {
		SET CACHECLASS = PACKNAME_"."_CLASSX
	} else {
		SET CACHECLASS = iCLASS
	}
	
	if ##class(%Dictionary.ClassDefinition).%ExistsId(CACHECLASS) {
		new strName,strClass
		; SR13353
		; Saving all the variables in an array to add them later to a new created class.
		set objCacheClass   = ##class(%Dictionary.ClassDefinition).%OpenId(CACHECLASS)
		; FIXME : May get objCacheClass=$$$NULLOREF if class is locked for editing (?) <GRF>
		set objClassMethods = objCacheClass.Methods
		set strInclude      = objCacheClass.IncludeCode
		set strImport       = objCacheClass.Import                   ;SR14278
		
		;16248 VVV Put this block of code back in
		for idxMethod = 1 : 1 : objClassMethods.Count() {
			set objClassMethod = objClassMethods.GetAt(idxMethod)
			set strName= objClassMethods.GetAt(idxMethod).Name
		;	if $extract(strName,$length(strName)-6,$length(strName))'="BASEGet" {
			if $extract(strName,$length(strName)-2,$length(strName))="Get" {
				set strName=$extract(strName,1,$length(strName)-3)
			}
			set strClass=CACHECLASS
			if $piece(strClass,".",1)="User" {
				set strClass=$piece(strClass,".",2,9999)
			}
			if '$data(^WWW003Calcs(0,1,$$$Index(strName),strClass)) {
				; Don't preserve calculated methods.
				set arrClassMethods(objClassMethod.Name, "Implementation") = objClassMethod.Implementation.Read()
				set arrClassMethods(objClassMethod.Name, "FormalSpec")     = objClassMethod.FormalSpec
				set arrClassMethods(objClassMethod.Name, "ClassMethod")    = objClassMethod.ClassMethod
				set arrClassMethods(objClassMethod.Name, "ReturnType")     = objClassMethod.ReturnType
			}
		}
		;16248 ^^^
 
		SET SUCCESS=##class(%Dictionary.ClassDefinition).%DeleteId(CACHECLASS)
		;SET SUCCESS=##class(%Dictionary.CompiledClass).%DeleteId(CACHECLASS) ; 23-Mar-2005	RobertW		You can not delete this, just raises an error.
		//SR11964
		if $$$ISERR(SUCCESS) {
			quit SUCCESS
		}
	}
	;SET WWW001=$GET(^WWW001(0,iCLASS,1))
	;quit:$piece(WWW001,"~",21) 1                    ; D21   $$$WWW001NoCompilemappedclass()
	
	; General Class Definition
	;---------------------------------------
	set CLASS=##class(%Dictionary.ClassDefinition).%New()
	set CLASS.Description = $$$WWW001ClassDescription(objANMClass)     ; D1
	if $data(^WWW0011(0,iCLASS,SPRACHE,1)) {
		set CLASS.Description = CLASS.Description_"/"_$piece($get(^WWW0011(0,iCLASS,SPRACHE,1)),Y,1)
	}
	set CLASS.Description=CLASS.Description_":"
	if '$$ISEMPTY^WWWMEMO($$$WWW001Description(objANMClass)) {     ; D19
		set CLASS.Description = CLASS.Description_"<br>"_$$TOHTML^WWWMEMO($$$WWW001Description(objANMClass))
	}
	
	set CLASS.Super = "%Library.Persistent,%XML.Adaptor,%Library.Populate"  
	if $$$WWW001InheritsFromSuperClasses(objANMClass)'="" set CLASS.Super = $$$WWW001InheritsFromSuperClasses(objANMClass) ; D20
	if CLASS.Super="Library.Persistent"                   set CLASS.Super = "%Library.Persistent"
	if '$find(CLASS.Super,"%XML.Adaptor")                 set CLASS.Super = CLASS.Super_",%XML.Adaptor" ;BR014985
	
	set CLASS.ClassType = "persistent"
	set CLASS.Name      = CACHECLASS
	
	; Company Property
	;---------------------------------------
	set blnSharedFile = '$$$WWW001SharedFile(objANMClass)     ; D3  [Company = YM or 0]
	
	if blnSharedFile DO
	. SET PROP=##class(%Dictionary.PropertyDefinition).%New()
	. DO CLASS.Properties.Insert(PROP)
	. SET PROP.Name     = strCompany             ;"Company"
	. SET PROP.Type     = "%String"
	. SET PROP.Required = $$$YES
	. if blnIs2007 do  // SR15488
	. . do PROP.Parameters.SetAt(30,"MAXLEN")
	. . do PROP.Parameters.SetAt("attribute","XMLPROJECTION")
	. if 'blnIs2007 do  // SR15488
	. . SET PROP.Parameters.Data("MAXLEN")        = 30
	. . SET PROP.Parameters.Data("XMLPROJECTION") = "attribute"
	
	; Properties : Primary Keys and Data Fields
	;---------------------------------------
	FOR GLOBAL="WWW002","WWW003" DO
	. SET GLOBREF="^"_GLOBAL_"(0,iCLASS)"
	. SET FELDNR=""
	. FOR  SET FELDNR=$order(@GLOBREF@(FELDNR)) quit:FELDNR=""  DO
	. . set SIZE=""                                                  ;SR16701
	. . ;do DisplayError^%apiOBJ(CLASS.%Save())
	. . SET DATA    = @GLOBREF@(FELDNR,1)
	. . SET IDFIELD = (GLOBAL="WWW002")
	. . SET PROP    = ##class(%Dictionary.PropertyDefinition).%New()
	. . DO CLASS.Properties.Insert(PROP)
	. . SET PROP.Name = $$$WWW003PropertyName(DATA)
	. . SET PROP.Type = "%String"
	. . ;
	. . SET ATNETTYPE=$$$WWW003InputType(DATA)
	. . if ATNETTYPE=1  set PROP.Type = "WWW.DiscDate" ;SET PROP.Type="%Date"  ;SET PROP.Type="BEWIDATA.Date"
	. . if ATNETTYPE=2  SET PROP.Type = "%Boolean"
	. .;if ATNETTYPE=3  SET PROP.Type = "%Stream"      ;SET PROP.Type="BEWIDATA.Memo"
	. . if ATNETTYPE=3  SET PROP.Type = "%String" set SIZE = 32000     ;SR16701
	. . if ATNETTYPE=4  SET PROP.Type = "%Numeric"
	. . if ATNETTYPE=5  SET PROP.Type = "%String"
	. . if ATNETTYPE=6  SET PROP.Type = "%String"
	. . if ATNETTYPE=7  SET PROP.Type = "%Time"
	. . if ATNETTYPE=8  SET PROP.Type = "%Currency"   ;SET PROP.Type="BEWIDATA.Currency"
	. . if ATNETTYPE=9  SET PROP.Type = "%String"     ;Counter fields can be strings PJK 05-Apr-2005 11714
	. . if ATNETTYPE=10 SET PROP.Type = "%String"
	. . if ATNETTYPE=11 SET PROP.Type = "%String"
	. . if ATNETTYPE=12 SET PROP.Type = "%Float"
	. . if ATNETTYPE=13 SET PROP.Type = "%String"
	. .;if ATNETTYPE=14 SET PROP.Type = "%TimeStamp"  ;SET PROP.Type="%String" ;Im Moment mal String, da sonst die Cache-Validierung nicht klappt. Später sollten wir einen eigenen Datentyp schaffen.
	. . if ATNETTYPE=14 SET PROP.Type = "WWW.DiscTimestamp" // SR15571
	. . if ATNETTYPE=15 SET PROP.Type = "%List"
	. . if 'IDFIELD if ATNETTYPE=16 if $piece($GET(^WWW003(0,iCLASS,FELDNR,1)),Y,26)'="" DO  quit
	. . . SET PROP.Type = $$$WWW003AlternateInputType(^WWW003(0,iCLASS,FELDNR,1))  ; D26
	. . . if $$$WWW003AlternateInputType(^WWW003(0,iCLASS,FELDNR,1))'["." do
	. . . . SET PROP.Type = PACKNAME_"."_$$$WWW003AlternateInputType(^WWW003(0,iCLASS,FELDNR,1)) ; D26
	. . ;
	. . ;ARI 240504 brauchen wir nicht I PROP.Type="%String",$F($$UPCASE^ECVSIMP($$$WWW003xPROPERTYNAME(DATA)),"NAME") S PROP.Type="%Name"
	. . SET PARAMETERS=""
	. . ;ARI 021203 bei PrimaryKey-Feldern muss man die Collation auf EXACT
	. . ;setzen, sonst geht Kompilierung ab Cache 5.0.4 schief.
	. . if IDFIELD && (PROP.Type="%String") || (PROP.Type="%Name") do
	. . . if blnIs2007  do PROP.Parameters.SetAt("EXACT","COLLATION")   // SR15488
	. . . if 'blnIs2007 set PROP.Parameters.Data("COLLATION")="EXACT"   // SR15488
	. . ;
	. . if $CASE(ATNETTYPE,3:1,5:1,6:1,10:1,:0) DO
	. . . if SIZE="" set SIZE = $$$WWW003InputLength(DATA)                   ;SR16701
	. . . if blnIs2007  do PROP.Parameters.SetAt(SIZE,"MAXLEN")   // SR15488 ;SR16701
	. . . if 'blnIs2007 set PROP.Parameters.Data("MAXLEN")=SIZE   // SR15488 ;SR16701
	. . ;BR014485 commented
	. . ;if $CASE(ATNETTYPE,4:1,8:1,:0) DO
	. . ;. if blnIs2007  do PROP.Parameters.SetAt($EXTRACT(999999999,1,$$$WWW003InputLength(DATA)),"MAXVAL") // SR15488
	. . ;. if 'blnIs2007 set PROP.Parameters.Data("MAXVAL")=$EXTRACT(999999999,1,$$$WWW003InputLength(DATA)) // SR15488
	. . SET CAPTION    = $$$WWW003PropertyDescription(DATA)
	. . set strCaption = $GET(@("^"_GLOBAL_"1")@(0,iCLASS,FELDNR,SPRACHE,1)) // SR15516
	. . if strCaption'="" SET CAPTION = strCaption                           // SR15516
	. . if blnIs2007  do PROP.Parameters.SetAt(CAPTION,"CAPTION")               // SR15488
	. . if 'blnIs2007 set PROP.Parameters.Data("CAPTION") = CAPTION             // SR15488
	. . if IDFIELD do
	. . . if blnIs2007  do PROP.Parameters.SetAt("attribute","XMLPROJECTION")   // SR15488
	. . . if 'blnIs2007 set PROP.Parameters.Data("XMLPROJECTION") = "attribute" // SR15488
	. . if IDFIELD || $$$WWW003MandatoryField(DATA) SET PROP.Required=$$$YES
	. . SET PROP.Description = $$$WWW003PropertyDescription(DATA)
	. .;if 'IDFIELD && $$$WWW003CachCollection(DATA)=$$$YES DO           ; 28-Oct-2009
	. . if 'IDFIELD && ($$$WWW003CachCollection(DATA)=$$$YES) DO
	. . . SET PROP.Collection       = "list"
	. . . SET PROP.SqlListDelimiter = """;"""
	. . . SET PROP.SqlListType      = "delimited"
	. . ;
	. . ;  FIXME : Braces inside dot level syntax; NOFORM cf YNOFORM <GRF>
	. . if $get(YNOFORM)=1 set e=CLASS.%Save() if 'e { write !,GLOBAL_"::"_iCLASS_":"_PROP.Name_" "_FELDNR do DisplayError^%apiOBJ(e) quit}
	
	; Add "Calculated, SqlComputeCode" properties (and Methods?) for Calculated Fields
	;---------------------------------------
	do CalcCurrencyFields^WWW001CalcFields(iCLASS)        ; Calc Fields for Currencies SR12854
	do CalcFields^WWW001CalcFields(iCLASS,.CLASS)         ; Calculated Fields SR12755
	
	; Get Primary Key Properties and apply to Index definition
	;---------------------------------------
	set strPropList = ""
	if blnSharedFile do INSERT^WWWPLIST(.strPropList,strCompany)  ; "Company"
	set FELDNR = ""
	for  {
		set FELDNR = $order(^WWW002(0,iCLASS,FELDNR))
		quit:FELDNR=""
		
		set WWW002 = $get(^WWW002(0,iCLASS,FELDNR,1))
		do INSERT^WWWPLIST(.strPropList,$$$WWW002PropertyName(WWW002),$$$NO,$$$COMMA)    ; D25	()
	}
	
	SET INDEX=##class(%Dictionary.IndexDefinition).%New()
	DO CLASS.Indices.Insert(INDEX)
	SET INDEX.Properties      = strPropList
	SET INDEX.Name            = "IDKEY"
	SET INDEX.PrimaryKey      = 1
	SET INDEX.IdKey           = 1
	SET INDEX.Unique          = 1               ;ARI 040704
	
	
	; Identify @nManager tilde-delimited structures for SQL as "map1"
	;---------------------------------------
	SET CLASS.StorageStrategy = "StorageAtNet"
	
	SET STORAGE           = ##class(%Dictionary.StorageDefinition).%New()
	DO CLASS.Storages.Insert(STORAGE)
	SET STORAGE.Type      = "%CacheSQLStorage"
	SET STORAGE.Name      = "StorageAtNet"
	
	SET SQLMAP            = ##class(%Dictionary.StorageSQLMapDefinition).%New()
	DO STORAGE.SQLMaps.Insert(SQLMAP)
	SET SQLMAP.Name       = "map1"
	SET SQLMAP.Type       = "data"
	SET SQLMAP.Global     = "^"_iCLASS
	SET SQLMAP.Structure  = "delimited"
	
	SET SQLSUBSCRIPT      = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	SET SQLSUBSCRIPT.Name = 1
	if blnSharedFile {
		SET SQLSUBSCRIPT.Expression = "{"_strCompany_"}"
	} else {
		SET SQLSUBSCRIPT.Expression = 0
	}
	
	; Add Primary Keys to map
	;---------------------------------------
	SET FELDNR = ""
	FOR  SET FELDNR = $order(^WWW002(0,iCLASS,FELDNR)) quit:FELDNR=""  DO
	. SET SQLSUBSCRIPT = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name       = FELDNR+1
	. SET SQLSUBSCRIPT.Expression = "{"_$$$WWW002PropertyName($get(^WWW002(0,iCLASS,FELDNR,1)))_"}"  ; D25
	
	SET SQLSUBSCRIPT = ##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	SET SQLSUBSCRIPT.Name       = $order(^WWW002(0,iCLASS,""),-1)+2
	SET SQLSUBSCRIPT.Expression = 1
	
	set strDelimiter = $$$WWW001AltDelimiterASCII(objANMClass)    ; D11
	if +strDelimiter=0 {
		set strDelimiter = Y                     ; "~"
	} else {
		set strDelimiter = $char(strDelimiter)
	}
	
	; Add Data Fields to map
	;---------------------------------------
	SET FELDNR = ""
	FOR  SET FELDNR = $order(^WWW003(0,iCLASS,FELDNR)) quit:FELDNR=""  DO
	. SET SQLDATA = ##class(%Dictionary.StorageSQLMapDataDefinition).%New()
	. DO SQLMAP.Data.Insert(SQLDATA)
	. SET SQLDATA.Name      = $$$WWW003PropertyName($get(^WWW003(0,iCLASS,FELDNR,1)))  ; D25
	. SET SQLDATA.Delimiter = """"_strDelimiter_""""
	. SET SQLDATA.Piece     = FELDNR
	
	; Build list of @nM Indices into YSKEY and transfer
	; them to separate maps "SortIndex#" for SQL
	;---------------------------------------
	DO WWWSORTKEY(iCLASS)  ; sets YSKEY() array
	
	SET INDEXNR=""
	FOR  SET INDEXNR=$order(YSKEY(INDEXNR)) quit:INDEXNR=""  DO
	. SET SQLMAP=##class(%Dictionary.StorageSQLMapDefinition).%New()
	. DO STORAGE.SQLMaps.Insert(SQLMAP)
	. SET SQLMAP.Name="SortIndex"_INDEXNR
	. SET SQLMAP.Type="index"
	. SET SQLMAP.Global="^"_iCLASS_"s"
	. SET SQLMAP.Structure="delimited"
	. SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name=1
	. ;if blnSharedFile SET SQLSUBSCRIPT.Expression="{"_strCompany_"}" if 1  ;"{MANDANT}" if 1
	. ;ELSE  SET SQLSUBSCRIPT.Expression=0
	. if blnSharedFile  SET SQLSUBSCRIPT.Expression="{"_strCompany_"}"    ; "Company"
	. if 'blnSharedFile SET SQLSUBSCRIPT.Expression=0
	. SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. SET SQLSUBSCRIPT.Name=2
	. SET SQLSUBSCRIPT.Expression=INDEXNR
	. FOR loop=1:1:$LENGTH(YSKEY(INDEXNR),",") DO
	. . SET FELDNR=$piece(YSKEY(INDEXNR),",",loop)
	. . SET IDFIELD=($EXTRACT(FELDNR)="K")
	. . SET FELDNR=$EXTRACT(FELDNR,2,$LENGTH(FELDNR))
	. . quit:FELDNR=""
	. . ;
	. . if 'IDFIELD if $$$WWW003PropertyName($GET(^WWW003(0,iCLASS,FELDNR,1)))="" quit     ; D25
	. . if IDFIELD  if $$$WWW002PropertyName($GET(^WWW002(0,iCLASS,FELDNR,1)))="" quit     ; D25
	. . ;
	. . SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. . DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. . SET SQLSUBSCRIPT.Name = loop+2
	. . if CACHECLASS["zzObjectTest" do
	. . . if IDFIELD  SET SQLSUBSCRIPT.Expression="$$^WWWUMLAU({"_$$$WWW002PropertyName($get(^WWW002(0,iCLASS,FELDNR,1)))_"},1)"  ; D25
	. . . if 'IDFIELD SET SQLSUBSCRIPT.Expression="$$^WWWUMLAU({"_$$$WWW003PropertyName($get(^WWW003(0,iCLASS,FELDNR,1)))_"},1)"  ; D25
	. . if CACHECLASS'["zzObjectTest" do
	. . . if IDFIELD  SET SQLSUBSCRIPT.Expression="$$UPPER({"_$$$WWW002PropertyName($get(^WWW002(0,iCLASS,FELDNR,1)))_"})"  ; D25
	. . . if 'IDFIELD SET SQLSUBSCRIPT.Expression="$$UPPER({"_$$$WWW003PropertyName($get(^WWW003(0,iCLASS,FELDNR,1)))_"})"  ; D25
	. ;
	. SET FELDNR=""
	. FOR  SET FELDNR=$order(^WWW002(0,iCLASS,FELDNR)) quit:FELDNR=""  DO
	. . SET SQLSUBSCRIPT=##class(%Dictionary.StorageSQLMapSubDefinition).%New()
	. . DO SQLMAP.Subscripts.Insert(SQLSUBSCRIPT)
	. . SET SQLSUBSCRIPT.Name       = FELDNR+$LENGTH(YSKEY(INDEXNR),",")+2
	. . SET SQLSUBSCRIPT.Expression = "{"_$$$WWW002PropertyName($get(^WWW002(0,iCLASS,FELDNR,1)))_"}"  ; D25
	
	; (Deprecated?) Calculated Fields (WWWCLASSCALC is not populated)
	;---------------------------------------
	SET PROPNAME = ""
	FOR  SET PROPNAME = $order(^WWWCLASSCALC(0,iCLASS,PROPNAME)) quit:PROPNAME=""  DO
	. SET DATA = $GET(^WWWCLASSCALC(0,iCLASS,PROPNAME,1))
	. SET PROP = ##class(%Dictionary.PropertyDefinition).%New()
	. DO CLASS.Properties.Insert(PROP)
	. SET PROP.Name = PROPNAME
	. SET PROP.Type = "%String"
	. if $piece(DATA,Y,2)'="" SET PROP.Type = $piece(DATA,Y,2)
	. if '$$ISEMPTY^WWWMEMO($piece(DATA,Y,1)) SET PROP.Description=$$TOHTML^WWWMEMO($piece(DATA,Y,1))
	. SET PROP.Calculated=1
	. if '$$ISEMPTY^WWWMEMO($piece(DATA,Y,3)) DO
	. . SET PROP.SqlComputed    = 1
	. . SET $piece(DATA,Y,3)    = $$STRIPEND^WWWMEMO($piece(DATA,Y,3))
	. . SET PROP.SqlComputeCode = $$TOSTREAM^WWWMEMO($piece(DATA,Y,3))
	
	; (Deprecated?) @nM Methods (WWWCLASSMETH is not populated)
	;---------------------------------------
	SET METHNAME=""
	FOR  SET METHNAME=$order(^WWWCLASSMETH(0,iCLASS,METHNAME)) quit:METHNAME=""  DO
	. SET DATA=$GET(^WWWCLASSMETH(0,iCLASS,METHNAME,1))
	. SET METHOD=##class(%Dictionary.MethodDefinition).%New()
	. DO CLASS.Methods.Insert(METHOD)
	. SET METHOD.Name        = METHNAME
	. SET METHOD.ClassMethod =+$piece(DATA,Y,3)
	. SET METHOD.FormalSpec  = $piece(DATA,Y,2)
	. SET METHOD.ReturnType  = $piece(DATA,Y,4)
	. DO METHOD.Implementation.Write($$TOSTREAM^WWWMEMO($piece(DATA,Y,1)))
	
	; Restore existing methods, etc.
	;---------------------------------------                    ; SR13353
	; Adding to the new created class all the existing methods, and the include code as well.
	if $data(strInclude) set CLASS.IncludeCode = strInclude
	if $data(strImport)  set CLASS.Import      = strImport      ; SR14278
	
	if $data(arrClassMethods) {
		set strMethodName = $order(arrClassMethods(""))
		while strMethodName '= "" {
			set objClassMethod = ##class(%Dictionary.MethodDefinition).%New()
		
			set objClassMethod.Name              = strMethodName
			do objClassMethod.Implementation.Write(arrClassMethods(strMethodName, "Implementation")) 
			set objClassMethod.FormalSpec        = arrClassMethods(strMethodName, "FormalSpec")
			set objClassMethod.ClassMethod       = arrClassMethods(strMethodName, "ClassMethod")
			set objClassMethod.ReturnType        = arrClassMethods(strMethodName, "ReturnType")
			
			do CLASS.Methods.Insert(objClassMethod)
			
			set strMethodName = $order(arrClassMethods(strMethodName))
		}
	}
	
	set SUCCESS = CLASS.%Save()     ; FIXME : sc => strStatus?
	quit SUCCESS
	
	
WWWSORTKEY(YDATEI) ;
	do ^WWWSORTKEY(YDATEI)
	;YSKEY(1)="1,2,3"   ;VARIABLEN FÜR SORTIERSCHLÜSSEL
	quit
	*/ ;SR16410 ^^^
	
]]></Routine>
</Export>