<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="9" zv="CACHE" ts="2001-01-01 00:00:00">
<Class name="SourceControl.Importer">
<Description><![CDATA[
Imports artifacts into Cache (mac, inc, cls and globals - forms, data and metadata)

If you want to include anything here, use just:
 Include COMSYS (without the leading #)
 ]]></Description>
<ClassType/>
<Import>SourceControl.control,SourceControl.data,SourceControl.data.global,VAR.infra.util,%Studio</Import>
<ProcedureBlock>1</ProcedureBlock>
<Super>Base</Super>

<Property name="cacheClasses">
<Description><![CDATA[
Keeps track of imported files]]></Description>
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheViewClasses">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheTableClasses">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheMacs">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheIncs">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheCsps">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cachePrjs">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="nmClasses">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="nmClassesReindex">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="nmClassesReconst">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="nmOthers">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheClassesErrors">
<Description><![CDATA[
These properties keeps track of errors that might have been
caused by missing dependencies]]></Description>
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheViewClassesErrors">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheTableClassesErrors">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheMacsErrors">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheIncsErrors">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="cacheCspsErrors">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="nmClassesErrors">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="nmOthersErrors">
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="errors">
<Description><![CDATA[
All errors that ocurred during import and compiling time]]></Description>
<Type>VAR.infra.util.Hashtable</Type>
</Property>


<Property name="errorCount">
<Description><![CDATA[
Regular counter]]></Description>
<Type>%Integer</Type>
</Property>


<Method name="%OnNew">
<Description><![CDATA[
Constructor]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set ..cacheClasses = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheViewClasses = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheTableClasses = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheMacs = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheIncs = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheCsps = ##class(VAR.infra.util.Hashtable).%New()
    set ..cachePrjs = ##class(VAR.infra.util.Hashtable).%New()
    set ..nmClasses = ##class(VAR.infra.util.Hashtable).%New()
    set ..nmClassesReindex = ##class(VAR.infra.util.Hashtable).%New()
    set ..nmClassesReconst = ##class(VAR.infra.util.Hashtable).%New()
    set ..nmOthers = ##class(VAR.infra.util.Hashtable).%New()

    set ..cacheClassesErrors = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheViewClassesErrors = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheTableClassesErrors = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheMacsErrors = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheCspsErrors = ##class(VAR.infra.util.Hashtable).%New()
    set ..cacheIncsErrors = ##class(VAR.infra.util.Hashtable).%New()
    set ..nmClassesErrors = ##class(VAR.infra.util.Hashtable).%New()
    set ..nmOthersErrors = ##class(VAR.infra.util.Hashtable).%New()
    set ..errors = ##class(VAR.infra.util.Hashtable).%New()

    set ..errorCount = 0

    quit $$$OK
]]></Implementation>
</Method>

<Method name="Help">
<Description><![CDATA[
Display a help message]]></Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
    write !, "This class is used to get external file system files inside Cache."
    write !, "The main purpose is o provide SourceControl, builds and easy deployments."
    write !, "The following methods are available, but are not recommended:"
    write !, "##class(SourceControl.Importer).AddExternalFile(externalFileName As %String) As %Status"
    write !, "##class(SourceControl.Importer).ProcessAllFiles() As %Status"
    write !
    write !, "The recommended way of using this class follows:"
    write !, "do ##class(SourceControl.Importer).JobImportAll(""e:\projects\listOfFiles.txt"")"
    write !
    write !
    write !, "or (manually doing things):"
    write !
    write !, "set obj=##class(SourceControl.Importer).%New()"
    write !, "set status=obj.addExternalFile(""fileNameWithPath"")"
    write !
    write !, "or"
    write !
    write !, "set status=obj.addAllFromFile(""fileNameWithPath"")" //On filename per line int that file
    write !, "do obj.ProcessAllFiles()"
    write !, "do obj.ShowErrors()"
]]></Implementation>
</Method>

<Method name="JobCompareAll">
<Description><![CDATA[
Imports all files, then processes all of them and finally show errors.
This method creates a job so that it can run in background.
In the beginning it sets SourceControl("runStatus")="start" and SourceControl("runStatus")="finished"]]]]><![CDATA[></Description>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>externalFileList:%String,externalOkFile:%String="&quot;</FormalSpec>
<Implementation><![CDATA[
    write !, "Process started at "_$zdatetime($horolog_"."_
        $piece($ztimestamp, ".", 2), 3, 1, 6)

    set importer = ##class(Importer).%New()
    do importer.CompareAllFromFile(externalFileList)    

    write !, "Process finished at "_$zdatetime($horolog_"."_
        $piece($ztimestamp, ".", 2), 3, 1, 6)

    do ..WriteOkFile(externalOkFile)

    // The following string will be the key to close the Cache
    // Terminal Window
    write !, "Comparing process finished."
]]></Implementation>
</Method>

<Method name="JobImportAll">
<Description><![CDATA[
Imports all files, then processes all of them and finally show errors.
This method creates a job so that it can run in background.
In the beginning it sets SourceControl("runStatus")="start" and SourceControl("runStatus")="finished"]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>externalFileList:%String,externalOkFile:%String="&quot;</FormalSpec>
<Implementation><![CDATA[
    write !, "Process started at "_$zdatetime($horolog_"."_
        $piece($ztimestamp, ".", 2), 3, 1, 6)

    set importer = ##class(Importer).%New()
    do importer.AddAllFromFile(externalFileList)    
    do importer.ProcessAllFiles()
    do importer.ShowErrors()

    write !, "Process finished at "_$zdatetime($horolog_"."_
        $piece($ztimestamp, ".", 2), 3, 1, 6)

    do ..WriteOkFile(externalOkFile)

    // The following string will be the key to close the Cache
    // Terminal Window
    write !, "Importing process finished."
]]></Implementation>
</Method>

<Method name="UpdateVersion">
<Description><![CDATA[
Updates the system's version using the updater framework.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>externalOkFile:%String="&quot;</FormalSpec>
<Implementation><![CDATA[
    	; History
	; 08-Jan-2014	shobby	CORE-304: IN.updateAll.ScriptRelease
	
	write !, "Update started at "_$zdatetime($horolog_"."_$piece($ztimestamp, ".", 2), 3, 1, 6)

   	do ##class(SourceControl.update.VersionUpdater).UpdateVersion("SourceControl.update")

	if (##class(Config).IsBuildOnlyNonVAR()) {
    	do ##class(VAR.update.VersionUpdater).UpdateVersion("IN.update")
	}
	else {
    	do ##class(VAR.update.VersionUpdater).UpdateVersion()
    }
    if ##class(%Dictionary.CompiledClass).%ExistsId("IN.updateAll.ScriptRelease") do ##class(IN.updateAll.ScriptRelease).%New().Update() ;CORE-304 ;Problem checking in

    write !!, "Flush pending exports ..."
    do ##class(Exporter).FlushExports()

    write !!, "Update finished at "_$zdatetime($horolog_"."_
        $piece($ztimestamp, ".", 2), 3, 1, 6)

    do ..WriteOkFile(externalOkFile)

    // The following string will be the key to close the Cache
    // Terminal Window
    write !, "Update process finished."
]]></Implementation>
</Method>

<Method name="CorrectProjectCsps">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set changed = 0

    set project = ##class(Project).%OpenId(projectName)
    set itemIndex = project.Items.Next("")
    while ($length(itemIndex) > 0) {
        set item = project.Items.GetAt(itemIndex)

        if (##class(Strings).LowerCase(item.Type) =
            ##class(FileType).%GetParameter("TXTCSP")) {
            set name = ##class(DirectoryFile).FixUnixPathSymbol(item.Name)
            if ($extract(name, 1, 1) '= "/") {
                set name = "/"_name
            }
            set namespace = $piece(name, "/", 3)

            if (##class(Strings).LowerCase(namespace) '=
                ##class(Strings).LowerCase($znspace)) {
                set name = "/csp/"_##class(Strings).LowerCase($znspace)_"/"_
                           $piece(name, "/", 4, $length(name, "/"))
                do project.RemoveItem(item.Name, item.Type)
                write !, item.Name_" => "_name
                do project.RemoveItem(name, item.Type)
                do project.AddItem(name, item.Type)
                set changed = 1

                set itemIndex = project.Items.Next("")
                continue
            }
        }

        set itemIndex = project.Items.Next(itemIndex)
    }

    if (changed) {
        do project.%Save(1)
    }

    quit $$$OK
]]></Implementation>
</Method>

<Method name="CompareAllFromFile">
<Description><![CDATA[
Compares all external files reading them from a list contained in a filename.
The list must contain one entry for each line. Every entry must have the full
path to the file. This is important because a Cache Terminal Script must be
much smaller than 1MB in size (it get's truncated).

Ex (e:\projetos\AlphalincA\build\update.lst):
e:\projetos\AlhpalincA\src\mac\zTest.mac.xml
e:\projetos\AlhpalincA\src\cls\SourceControl.Importer.cls.xml
e:\projetos\AlhpalincA\globals\nm\globals\classes\ADRCBANAC.nmclass]]></Description>
<FormalSpec>listFileName:%String="&quot;</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set sc = $$$OK
    set counter = 0
    set errors = 0
    kill ^bufferFile

    write !, "Adding all files listed in '"_listFileName_"'..."

    // If no file then skip the import
    if ('##class(%File).Exists(listFileName)) {
        set msg = "The file '"_listFileName_" was not found."
        write !, msg
        quit ##class(Errors).MakeErrorStatus(msg)
    }

    // Open the file
    set file = ##class(%File).%New(listFileName)
    if (file = "") {
        set msg = "The file '"_listFileName_" could not be opened "_
            "to be read."
        write !, msg
        quit ##class(Errors).MakeErrorStatus(msg)
    }
    else {
        set sc = file.Open("RS")
        if (##class(Errors).IsError(sc)) {
            quit sc
        }
    }

    set sc = ..ListSourceControlFiles(.excludeList)

    //////////////////////
    w !,!,!
    w !, "FileName"
    w !, "DateTime SystemFile [<|>] DateTime CACHÃ"

    // Read all lines
    for {
        set lengthRead = 32000

        // Reads a line of text up to lengthRead 
        set line = ##class(DirectoryFile).FixPathSymbol(
            file.Read(.lengthRead))
        if (lengthRead < 0) {
            quit
        }
        // Only lines that are not empty
        elseif (lengthRead > 0) {
            if ($data(excludeList(line)) '= 0){
                continue
            }

            // Get the file timestamp
            set externalTimeStamp = ##class(%File).GetFileDateModified(line)
            
            // Check for wrong timestamps and skip those files
            if ((externalTimeStamp = "") || (externalTimeStamp <= 0)) {
                continue
            }
            
            // Check if the import is really needed
            do ##class(FileControl).IsArtifactOutdated(line,
                    externalTimeStamp, .internalTimeStamp)

            // Some info to make it easier to read the log file
            if (internalTimeStamp '= "") {
                if (externalTimeStamp '= internalTimeStamp) {
                    // outdated 
                    set fileName = ##class(FileControl).RemoveProjectFromFullPath(line)
                    set ^bufferFile($i(bufferFile)) = fileName
                    set ^bufferFile($i(bufferFile)) = $zdatetime(externalTimeStamp, 3, 1)_" "_
                        $justify(..PrintWhichIsOutdated(internalTimeStamp, externalTimeStamp),3)_"  "_
                        " "_$zdatetime(internalTimeStamp, 3, 1)
                }
            }
            else {
                // obj is not controlled by asde
                set fileName = ##class(FileControl).RemoveProjectFromFullPath(line)
                set ^bufferFile($i(bufferFile)) = fileName
                set ^bufferFile($i(bufferFile)) =  $zdatetime(externalTimeStamp, 3, 1)_" "_
                    $justify(..PrintWhichIsOutdated(internalTimeStamp, externalTimeStamp),3)_"  "_
                    " "_"empty"
            }
        }
    }

    do file.Close()

    /// printing output on file "output.txt"
    set externalPrintFile = ##class(DirectoryFile).ConcatPath(
        ##class(Config).GetProjectDir(),
        ##class(DirectoryFile).ConcatPath("build", "cache-compare-output.txt"))

    ;##class(DirectoryFile).ConcatPath(
    ;   ^SourceControl("projectDir"), "\build\output.txt")
    set file = ##class(%File).%New(externalPrintFile)
    if ('file) {
        write !, "There was an error preparing the OkFile ("_
            externalPrintFile_") for writing!"
        quit
    }

    set r = file.Open("WSN")
    set r = file.WriteLine("FileName")
    set r = file.WriteLine("    DateTime SystemFile [<|>] DateTime CACHE")
    if ('r) {
        write !, "There was an error opening the OkFile ("_
            externalPrintFile_") for writing!"
        quit
    }

    set next = $order(^bufferFile(""))
    for {
        if (next = "") {
            quit    
        }
        if ((next # 2) = 1) {
            set indent = ""
        } else {
            set indent = "    "
        }

        set r = file.WriteLine(indent_^bufferFile(next))
        set next = $order(^bufferFile(next))
    }

    if ('r) {
        write !,"There was an error writing to the OkFile ("_
            externalPrintFile_")!"
        quit
    }

    do file.Close()
    kill ^bufferFile

    quit sc
]]></Implementation>
</Method>

<Method name="PrintWhichIsOutdated">
<FormalSpec>i:%String,e:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set output = ""

    // Compare both
    if (##class(DateTime).DateTimeCmp(i, e) = -1) {
        set output = ">"
    }
    elseif (##class(DateTime).DateTimeCmp(i, e) = 1) {
        set output = "<"
    }

    quit output
]]></Implementation>
</Method>

<Method name="AddAllFromFile">
<Description><![CDATA[
Adds all external files reading them from a list contained in a filename.
The list must contain one entry for each line. Every entry must have the full
path to the file. This is important because a Cache Terminal Script must be much smaller
than 1MB in size (it get's truncated).

Ex (e:\projetos\AlphalincA\build\update.lst):
e:\projetos\AlhpalincA\src\mac\zTest.mac.xml
e:\projetos\AlhpalincA\src\cls\SourceControl.Importer.cls.xml
e:\projetos\AlhpalincA\globals\nm\globals\classes\ADRCBANAC.nmclass]]></Description>
<FormalSpec>listFileName:%String="&quot;</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set sc = $$$OK
    set counter = 0
    set errors = 0

    write !, "Adding all files listed in '"_listFileName_"'..."

    // If no file then skip the import
    if ('##class(%File).Exists(listFileName)) {
        set msg = "The file '"_listFileName_" was not found."
        write !, msg
        quit ##class(Errors).MakeErrorStatus(msg)
    }

    // Open the file
    set file = ##class(%File).%New(listFileName)
    if (file = "") {
        set msg = "The file '"_listFileName_" could not be opened "_
            "to be read."
        write !, msg
        quit ##class(Errors).MakeErrorStatus(msg)
    }
    else {
        set sc = file.Open("RS")
        if (##class(Errors).IsError(sc)) {
            quit sc
        }
    }
    
    set sc = ..ListSourceControlFiles(.excludeList)

    // Read all lines
    for {
        set lengthRead = 32000

        // Reads a line of text up to lengthRead 
        set line = ##class(DirectoryFile).FixPathSymbol(
            file.Read(.lengthRead))

        if (lengthRead < 0) {
            quit
        }
        // Only lines that are not empty
        elseif (lengthRead > 0) {
            if ($data(excludeList(line)) '= 0){
                continue
            }

            // Get the file timestamp
            set externalTimeStamp = ##class(%File).GetFileDateModified(line)

            // Check for wrong timestamps and skip those files
            if ((externalTimeStamp = "") || (externalTimeStamp <= 0)) {
                write !,"Skipping file "_line_" since it has an invalid "_
                    "time stamp ("_externalTimeStamp_")"
                continue
            }

            // Check if the import is really needed
            if (##class(FileControl).IsArtifactOutdated(line,
                    externalTimeStamp, .internalTimeStamp)) {
                // Some info to make it easier to read the log file
                if (internalTimeStamp '= "") {
                    write !, "Adding "_line_" because it is outdated"_
                        "(ext.: "_$zdatetime(externalTimeStamp, 3, 1, 6)_
                        ",int.: "_$zdatetime(internalTimeStamp, 3, 1, 6)_")."
                }
                else {
                    write !, "Adding "_line_" because it is outdated"_
                        "(ext.: "_$zdatetime(externalTimeStamp, 3, 1, 6)_
                        ",int.: empty)"
                }

                // AddExternalFile 
                if (##class(Errors).IsError(..AddExternalFile(line))) {
                    set errors = errors + 1
                }
                else {
                    set counter = counter + 1
                }
            }
            else {
                if (internalTimeStamp '= "") {
                    write !, "Skipping file "_line_" since it is uptodate "_
                        "(ext.: "_$zdatetime(externalTimeStamp, 3, 1, 6)_
                        ",int.: "_$zdatetime(internalTimeStamp, 3, 1, 6)_")."
                } else {
                    write !, "Skipping file "_line_" because its "_
                        "internal timestamp is empty! This is wrong. "_
                        "Please fix the importer code."
                }
            }
        }
    }

    write !, "Total files loaded correctly: "_counter
    write !, "Total files with errors: "_errors

    quit sc
]]></Implementation>
</Method>

<Method name="ListSourceControlFiles">
<FormalSpec>&amp;list</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    kill list
    set sc = ..ListSourceControlProject("Common", .list)
    set sc = ..ListSourceControlProject("Log4C", .list)
    set sc = ..ListSourceControlProject("CosUnit", .list)
    set sc = ..ListSourceControlProject("SourceControl", .list)

    quit sc
]]></Implementation>
</Method>

<Method name="ListSourceControlProject">
<FormalSpec>projectName:%String,&amp;list</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set list(##class(FileControl).GetExternalFileName(
        projectName_"."_##class(FileType).%GetParameter("TXTPRJ"))) = ""

    set project = ##class(Project).%OpenId(projectName)
    set itemIndex = project.Items.Next("")
    while ($length(itemIndex) > 0) {
        set item = project.Items.GetAt(itemIndex)
        set name = item.Name
        if (##class(Strings).LowerCase(item.Type) =
            ##class(FileType).%GetParameter("TXTCLS")) {
            set name = name_"."_item.Type
        }

        set list(##class(FileControl).GetExternalFileName(name)) = ""

        set itemIndex = project.Items.Next(itemIndex)
    }

    quit $$$OK
]]></Implementation>
</Method>

<Method name="AddExternalFile">
<Description><![CDATA[
Adds an external file to the process queue for later compilation (if possible).
Since there are dependecies that must be taken into consideration, the system only loads
INClude files now, leaving all ohter types for later imoprt/compile operations. This way we
can guarantee that there will be no unmet dependencies.

When the user calls 

Possible file types are: mac,cls,inc,gbl]]></Description>
<FormalSpec>externalFileName:%String="&quot;</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set sc = $$$OK

    // Check
    if (externalFileName = "") {
        quit ##class(Errors).MakeErrorStatus("The external file name "_
            "can't be empty!")
    }

    // Get the type
    set type = ##class(FileType).GetTypeByExternalName(externalFileName)

    //set ^zLuis("AddExternalFile", "file") = externalFileName_",type="_type

    // The file is only loaded right now if it is an INCLUDE type of file.
    if (type = ##class(FileType).%GetParameter("INC")) {
	    write !

        // Import the file right away
        set sc = ..ImportCacheSourceFile(externalFileName)
        if (##class(Errors).IsError(sc)) {
            do ..AddImportError(externalFileName, "File could not be "_
                "imported into Cache", sc)
            quit sc
        }
    }

    // Debug
    //set ^zLuis("AddExternalFile","error")=$get(sc)

    // Append it to the correct list (mac,inc,cls,gbl). If the file is
    // a global or @NM object, it will be loaded at the compile time
    // because of dependencies that might exist.
    do ..AddToList(externalFileName, type)

    quit sc
]]></Implementation>
</Method>

<Method name="ImportCacheSourceFile">
<Description><![CDATA[
This method loads an internal file into cache. Optionally, you can
specify $System.OBJ.ShowFlafs() flags.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>externalFileName:%String,flags:%String="d&quot;</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set r = $$$NO

    // If no file then skip the import
    if ('##class(%File).Exists(externalFileName)) {
        set s = "The file '_"_externalFileName_" was not found, "_
            "ignoring it."
        write !, s
        quit ##class(Errors).MakeErrorStatus(s)
    }

    // Use the system to import XML artifacts
    if (##class(Strings).EndsWith(externalFileName, ".xml")) {
        // Call the function to do the load (d: display, f: force,
        //     c: compile)
        set r = ..ImportCacheSourceFileHelper(externalFileName, flags)

        if (r = 0) {
            set s = "Last (runtime) at: '"_externalFileName
            write !, s
            quit ##class(Errors).MakeErrorStatus(s)
        }
        elseif (r = -1) {
            // It was already printed
            quit $$$NO
        }
    }

    quit $$$OK
]]></Implementation>
</Method>

<Method name="ImportCacheSourceFileHelper">
<Description><![CDATA[
This is a wrapper for Cache's internal function. Cache's routine fails with runtime
error on many situations. We need to bypass that to keep loading other files and report the
error.
This routines returns 1 if it was OK, 0 - runtime error or -1: status error found and printed
TODO: figure out how to build a correct Status code from whithin $etrap code. [Private]]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>externalFileName:%String,flags:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    new $etrap

    // The following code forces Cache to stop error hadling at
    // this contect of execution
    set $etrap = "write !, ""Runtime error found:""_$ZERROR_"" - "_
        "stck=""_$ESTACK set $ECODE = """" quit:$quit 0 quit"

    quit ##class(SourceBase).ImportCacheSourceFileHelperMore(
        externalFileName, flags)
]]></Implementation>
</Method>

<Method name="AddToList">
<Description><![CDATA[
This method adds a new file to the list of sucessfully imported items. Equal
names overwrite existing names.]]></Description>
<FormalSpec>externalFileName:%String,type:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set slash = ##class(DirectoryFile).GetPathSymbol()
    set internalName = ""
    set error = ""
    set sc = $$$OK

    // Debug
    //write !,"AddToList, type="_type_", file="_externalFileName

    // We have to subdivide CLS into "pure CLS", "report CLS" and
    // "view CLS"
    if (type = ##class(FileType).%GetParameter("CLS")) {
        // This routine must open the file and read its contents
        set sc = ##class(FileControl).GetInternalNameFromXmlFile(
            externalFileName, .internalName)
        if ('##class(Errors).IsError(sc)) {
            if (##class(Strings).StartsWith(internalName, "Report.")) {
                do ..cacheViewClasses.Put(externalFileName, internalName)
            }
            elseif (##class(Strings).StartsWith(internalName, "User.") ||
            	##class(Strings).StartsWith(internalName, "al")) {
                // Save user (Table)
                do ..cacheTableClasses.Put(externalFileName, internalName)
            }
            else {
                // Pure class
                do ..cacheClasses.Put(externalFileName, internalName)
            }
        }
    }
    elseif (type = ##class(FileType).%GetParameter("MAC")) {
        // This routine must open the file and read its contents
        set sc = ##class(FileControl).GetInternalNameFromXmlFile(
            externalFileName, .internalName)
        if ('##class(Errors).IsError(sc)) {
            //mac routine
            do ..cacheMacs.Put(externalFileName, internalName)
        }
    }
    elseif ((type = ##class(FileType).%GetParameter("CSP")) ||
    		(type = ##class(FileType).%GetParameter("CSR"))) {
        set sc = ##class(FileControl).GetInternalCspUrl(externalFileName,
        	.internalName)
        if ('##class(Errors).IsError(sc)) {
            // CSP file
            do ..cacheCsps.Put(externalFileName, internalName)
        }
    }
    elseif (type = ##class(FileType).%GetParameter("PRJ")) {
        // This routine must open the file and read its contents
        set sc = ##class(FileControl).GetInternalNameFromXmlFile(
            externalFileName, .internalName)
        if ('##class(Errors).IsError(sc)) {
            // PRJ file
            do ..cachePrjs.Put(externalFileName, internalName)
        }
    }
    elseif (type = ##class(FileType).%GetParameter("INC")) {
        set sc = ##class(FileControl).GetInternalNameFromXmlFile(
            externalFileName, .internalName)
        if ('##class(Errors).IsError(sc)) {
            // Include files
            do ..cacheIncs.Put(externalFileName, internalName)
        }
    }
    elseif (type = ##class(FileType).%GetParameter("NMCLASS")) {
        set sc = ##class(FileControl).GetInternalNameFromGlobalFile(
            externalFileName, .internalName)
        //write !, "internalName="_internalName
        if ('##class(Errors).IsError(sc)) {
            do ..nmClasses.Put(externalFileName, internalName)
        }
    }
    else {
        // All the rest
        set sc = ##class(FileControl).GetInternalNameFromGlobalFile(
            externalFileName, .internalName)
        if ('##class(Errors).IsError(sc)) {
            do ..nmOthers.Put(externalFileName, internalName)
        }
    }

    if ((error '= "") || ('+sc)) {
        do ..AddImportError(externalFileName, error, sc)
    }

    quit $$$YES
]]></Implementation>
</Method>

<Method name="AddImportError">
<Description><![CDATA[
Adds a new error to the error holder global
equal names overwrites older names]]></Description>
<FormalSpec>artifactName:%String,error:%String,status:%Status</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[   do ..AddError("importError", artifactName, error, $get(status))
]]></Implementation>
</Method>

<Method name="AddError">
<Description><![CDATA[
Adds the error type to the list of errors]]></Description>
<FormalSpec>type:%String,artifactName:%String,error:%String="&quot;,status:%Status="&quot;</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    set errorDescription = ##class(Errors).GetErrorFromErrorStatus(status)

    // Counter
    set ..errorCount = ..errorCount + 1

    // Save it for statistics
    set msg = $get(artifactName)_","_$get(error)
    do ..errors.Add($get(type)_","_msg_",ST="_status_","_
        $get(errorDescription))

    // Print it out if there is any new information
    if ($length(errorDescription) > 2) {
        write !, msg, ", decomposed status code="_errorDescription
    }
]]></Implementation>
</Method>

<Method name="ProcessAllFiles">
<Description><![CDATA[
Compiles all cache source files and @NM artifacts that can be generated and compiled. All
other globals are actually imported at this stage too, because they may require some MACs and CLSs.

The following order is used:
INC, MAC, CLS (no reports, no views), @NM properties, @NMClass, CLS (reports), CLS (views),
@NM generated reports and @NM generated views]]></Description>
<Implementation><![CDATA[
    set ^SourceControl("runStatus") = "pass one"
    do ..ProcessPassOne()

    set ^SourceControl("runStatus") = "pass two"
    do ..ProcessPassTwo()

    // Mark that the run is finished
    set ^SourceControl("runStatus") = "finished"
]]></Implementation>
</Method>

<Method name="ProcessPassOne">
<Description><![CDATA[
Compiles all cache source files and @NM artifacts that can be generated and compiled. All
other globals are actually imported at this stage too, because they may require some MACs and CLSs.
All errors resulting from this pass are stored.

The following order is used:
INC, MAC, CLS (no reports, no views), @NM properties, @NMClass, CLS (reports), CLS (views),
@NM generated reports and @NM generated views]]></Description>
<Implementation><![CDATA[
    set ..errorCount = 0

    set ^SourceControl("runStatus", "pass 1", "total errors") = 0

    write !, "1111111111111111111111111111111111111111111111111111111111111111"
    write !, "Processing all files, pass one..."

    // No need to process INCs: not compiled but already imported (loaded)

    // Loops through all MACs, loading and compiling them
    // (d: display message, f: force c: compile)
    set ^SourceControl("runStatus") = "Importing Mac routines"
    do ..LoadCacheSourceFiles(..cacheMacs, ..cacheMacsErrors,
        "MAC", "cfkv")

    // Loops through all cache classes (pure, view and report) and
    // *only* loads them (it is necessary to have all of them loaded
    // for the latter compilation process)
    set ^SourceControl("runStatus") = "Importing Cache classes"
    do ..LoadCacheSourceFiles(..cacheClasses, ..cacheClassesErrors,
        "regular CLS", "fkv")

    set ^SourceControl("runStatus") = "Importing Cache Table definition "_
        "classes"
    do ..LoadCacheSourceFiles(..cacheTableClasses, ..cacheTableClassesErrors,
        "CLS table definition", "fkv")

    set ^SourceControl("runStatus") = "Importing Cache View definition "_
        "classes"
    do ..LoadCacheSourceFiles(..cacheViewClasses, ..cacheViewClassesErrors,
        "CLS view definitions", "fkv")

    // Loops through all cache pure cache classes and compiles them,
    // with dependencies (r:recursive, b:subclasses)
    set ^SourceControl("runStatus") = "Compiling pure Cache classes"
    do ..CompileCacheClasses(..cacheClasses, ..cacheClassesErrors,
        "regular CLS classes", "cfkvo3byr")

    // Loops through all cache classes that represent sql tables
    // (not views) . (y: sql dependencies)
    set ^SourceControl("runStatus") = "Compiling Cache Table definition "_
        "classes"
    do ..CompileCacheClasses(..cacheTableClasses, ..cacheTableClassesErrors,
        "CLS table definition classes", "cfkvo3byr")

    // Loops through all cache classes that represent sql views
    set ^SourceControl("runStatus") = "Compiling Cache View definition "_
        "classes"
    do ..CompileCacheClasses(..cacheViewClasses, ..cacheViewClassesErrors,
        "CLS view definition classes", "cfkvo3byr")

    // Loops through all csp pages
    set ^SourceControl("runStatus") = "Compiling Cache CSP pages"
    do ..CompileCacheCsps(..cacheCsps, ..cacheCspsErrors,
        "CSP pages", "cfkvo3byr")

    // Loops through all NM artifacts that are not classes
    set ^SourceControl("runStatus") = "Importing @NM globals (forms, "_
        "menus, etc)"
    do ..ImportNMGlobals(..nmOthers, ..nmOthersErrors)

    //Loops through all NM classes and imports them
    set ^SourceControl("runStatus") = "Importing @NM classes"
    do ..ImportNMClasses(..nmClasses, ..nmClassesErrors)

    set ^SourceControl("runStatus", "pass 1", "total errors") =
        ..errorCount
    write !, "Pass 1 total errors: "_..errorCount
]]></Implementation>
</Method>

<Method name="LoadCacheSourceFiles">
<Description><![CDATA[
This method imports and compiles all things (CLS,MACS,INC) in the hashtable.
It also generates error messages and stores them in the errors property.
Flags are defined in $system.OBJ.ShowFlags()]]></Description>
<FormalSpec>lstFiles:VAR.infra.util.Hashtable,lstFilesErrors:VAR.infra.util.Hashtable,msgType:%String="&quot;,flags:%String="&quot;</FormalSpec>
<Implementation><![CDATA[
    // Let's loop through all items and use the current index (the
    // external file name) to load and compile the Cache source file
    write !, "Loading "_lstFiles.GetSize()_" "_msgType_" files..."
    do lstFiles.StartIterator()
    while (lstFiles.Next()) {
        set externalFileName = lstFiles.GetCurrentIndex()

        write !

        // Import using the desired flags
        set error = ""
        set sc = ..ImportCacheSourceFile(externalFileName, flags)
        if (##class(Errors).IsError(sc)) {
            do ..AddCompileError(externalFileName, error, sc)
            write !, "File import error: "_externalFileName

            // Save it for pass two
            do lstFilesErrors.Put(externalFileName,
                lstFiles.GetCurrentValue())
        }
        else {
            write !, "File imported ok: "_externalFileName
        }
    }
]]></Implementation>
</Method>

<Method name="AddCompileError">
<Description><![CDATA[
Adds a new error to the error holder global
equal names overwrites older names]]></Description>
<FormalSpec>artifactName:%String,error:%String,status:%Status="&quot;</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[   do ..AddError("compileError", artifactName, error, status)
]]></Implementation>
</Method>

<Method name="CompileCacheClasses">
<Description><![CDATA[
This method compiles cache classes(CLS) in the hashtable.
It also generates error messages and stores them in the errors property.
Flags are defined in $system.OBJ.ShowFlags()]]></Description>
<FormalSpec>lstFiles:VAR.infra.util.Hashtable,lstFilesErrors:VAR.infra.util.Hashtable,msgType:%String="&quot;,flags:%String="fc&quot;</FormalSpec>
<Implementation><![CDATA[
    // Let's loop through all items and use the current value (the
    // internal name) to load and compile the Cache source file
    write !, "Compiling "_lstFiles.GetSize()_" "_msgType
    do lstFiles.StartIterator()
    while (lstFiles.Next()) {
        set internalName = lstFiles.GetCurrentValue()
        set externalName = lstFiles.GetCurrentIndex()

		write !

        set sc = ..CompileCacheClass(internalName, flags)
        if (sc = 0) {
            // Runtime error detection
            write !, "Runtime error at: "_externalName_" ("_internalName_")"
            do lstFilesErrors.Put(externalName, internalName)
        }
        elseif (sc = -1) {
            // Save it for pass two
            do lstFilesErrors.Put(externalName, internalName)
        }
    }
]]></Implementation>
</Method>

<Method name="CompileCacheClass">
<Description><![CDATA[
This method does the actual compilation, but traps any errors.
Returns 0: runtime error 1: ok, -1: processing error]]></Description>
<FormalSpec>internalName:%String,flags:%String="&quot;</FormalSpec>
<Implementation><![CDATA[
    // Turn on error traping
    new $etrap

    // The following code forces Cache to stop error hadling at this
    // contect of execution
    set $etrap = "write !, ""Runtime error found:""_$ZERROR_"" - "_
        "stck=""_$ESTACK set $ECODE = """" quit:$quit 0 quit"

    quit ..CompileCacheClassHelper(internalName, flags)
]]></Implementation>
</Method>

<Method name="CompileCacheClassHelper">
<Description><![CDATA[
This method does the actual compilation, but traps any errors.
Returns 0: runtime error 1: ok, -1: processing error]]></Description>
<FormalSpec>internalName:%String,flags:%String="&quot;</FormalSpec>
<Implementation><![CDATA[
    // Turn on error traping
    new $etrap
    set $etrap = "quit:$quit 0 quit"

    // Force Compile and Display messages
    set error = ""
    set sc = $System.OBJ.Compile(internalName, flags)
    if (##class(Errors).IsError(sc)) {
        do ..AddCompileError(internalName, error, sc)
        write !, "Class compile error: "_internalName
        quit -1
    }
    else {
        write !, "Class ok:    "_internalName
    }

	set $ztrap = "exception"

	// Rebuild individual indexes
	if (##class(Strings).StartsWith(internalName, "al") &&
		##class(%Dictionary.ClassDefinition).%ExistsId(internalName) &&
		##class(%Library.CompiledMethod).%ExistsId(internalName_".%IsA") &&
		$zobjClassMethod(internalName, "%IsA", "%Persistent") &&
		..IsClassIndicesChanged(internalName)) {
		do $zobjClassMethod(internalName, "%PurgeIndices")
		do $zobjClassMethod(internalName, "%BuildIndices")
	}

	// Clean cached queries for the corresponding table
	if ((##class(Strings).StartsWith(internalName, "User.") ||
		 ##class(Strings).StartsWith(internalName, "al")) &&
		##class(%Dictionary.ClassDefinition).%ExistsId(internalName) &&
		##class(%Library.CompiledMethod).%ExistsId(internalName_".%IsA") &&
		$zobjClassMethod(internalName, "%IsA", "%Persistent")) {
		set cdef = ##class(%Dictionary.ClassDefinition).%OpenId(internalName)

		set tableName = cdef.SqlTableName
		if ($length(tableName) = "") {
			set tableName = internalName
			if (##class(Strings).StartsWith(internalName, "User.")) {
				set tableName = "SQL"_tableName
			}
		}

		if (##class(%Library.SQLAPI).FindClassName(tableName) = internalName) {
			do $System.SQL.PurgeForTable(tableName)
		}
	}

finally
    quit 1

exception
 	set $ztrap = ""
 	set $ecode = ""
 	
	goto finally
]]></Implementation>
</Method>

<Method name="IsClassIndicesChanged">
<Description><![CDATA[
Checks if the Class indices changed.]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>internalName:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set blnChanged = $$$NO
 
	set objClass = ##class(%Library.ClassDefinition).%OpenId(internalName)
	if ($isObject(objClass)) {
		for intCnt = 1:1:objClass.Indices.Count() {
			set objIndex = objClass.Indices.GetAt(intCnt)
			set strProperties = objIndex.Properties
			set strName = objIndex.Name
			set arrIndexProperties(strName) = strProperties
 
			if ('$data(^COMClassIndexSave(internalName, strName))) {
				set blnChanged = $$$YES
			}
		}

		if (blnChanged = $$$NO) {
			// Check for Changed and Removed Indices
			set strName = $order(^COMClassIndexSave(internalName, ""))
			while ($length(strName) > 0) {
				if (('$data(arrIndexProperties(strName))) ||
					($get(arrIndexProperties(strName)) '=
						$get(^COMClassIndexSave(internalName, strName)))) {
					set blnChanged = $$$YES
					quit
				}

				set strName = $order(^COMClassIndexSave(internalName, strName))
			}
		}
	}

	if (blnChanged) {
		kill ^COMClassIndexSave(internalName)

		set strName = $order(arrIndexProperties(""))
		while ($length(strName) > 0) {
			set ^COMClassIndexSave(internalName, strName) =
				$get(arrIndexProperties(strName))

			set strName = $order(arrIndexProperties(strName))
		}
	}
 
	quit blnChanged
]]></Implementation>
</Method>

<Method name="CompileCacheCsps">
<Description><![CDATA[
This method compiles cache server pages(CSP) in the hashtable.
It also generates error messages and stores them in the errors property.
Flags are defined in $system.OBJ.ShowFlags()]]></Description>
<FormalSpec>lstFiles:VAR.infra.util.Hashtable,lstFilesErrors:VAR.infra.util.Hashtable,msgType:%String="&quot;,flags:%String="fc&quot;</FormalSpec>
<Implementation><![CDATA[
    // Let's loop through all items and use the current value (the
    // internal name) to load and compile the Cache source file
    write !, "Compiling "_lstFiles.GetSize()_" "_msgType
    do lstFiles.StartIterator()
    while (lstFiles.Next()) {
        set internalName = lstFiles.GetCurrentValue()
        set externalName = lstFiles.GetCurrentIndex()

		write !

        set sc = ..CompileCacheCsp(internalName, flags)
        if (sc = 0) {
            // Runtime error detection
            write !, "Runtime error at: "_externalName_" ("_internalName_")"
            do lstFilesErrors.Put(externalName, internalName)
        }
        elseif (sc = -1) {
            // Save it for pass two
            do lstFilesErrors.Put(externalName, internalName)
        }
    }
]]></Implementation>
</Method>

<Method name="CompileCacheCsp">
<Description><![CDATA[
This method does the actual compilation, but traps any errors.
Returns 0: runtime error 1: ok, -1: processing error]]></Description>
<FormalSpec>internalName:%String,flags:%String="&quot;</FormalSpec>
<Implementation><![CDATA[
    // Turn on error traping
    new $etrap

    // The following code forces Cache to stop error hadling at this
    // contect of execution
    set $etrap = "write !, ""Runtime error found:""_$ZERROR_"" - "_
        "stck=""_$ESTACK set $ECODE = """" quit:$quit 0 quit"

    quit ..CompileCacheCspHelper(internalName, flags)
]]></Implementation>
</Method>

<Method name="CompileCacheCspHelper">
<Description><![CDATA[
This method does the actual compilation, but traps any errors.
Returns 0: runtime error 1: ok, -1: processing error]]></Description>
<FormalSpec>internalName:%String,flags:%String="&quot;</FormalSpec>
<Implementation><![CDATA[
    // Turn on error traping
    new $etrap
    set $etrap = "quit:$quit 0 quit"

    // Get the type
    set type = ##class(FileType).GetTypeByExternalName(internalName)

    // Force Compile and Display messages
    set error = ""
    if (type = ##class(FileType).%GetParameter("CSP")) {
    	set sc = $System.CSP.LoadPage(internalName, flags)
    }
    elseif (type = ##class(FileType).%GetParameter("CSR")) {
    	set sc = $System.CSP.LoadRule(internalName, flags)
    }
    if (##class(Errors).IsError(sc)) {
        do ..AddCompileError(internalName, error, sc)
        write !, "CSP compile error: "_internalName
        quit -1
    }
    else {
        write !, "CSP ok:    "_internalName
    }

    quit 1
]]></Implementation>
</Method>

<Method name="ImportNMGlobals">
<Description><![CDATA[
Imports a list of @NM globals from filenames. ]]></Description>
<FormalSpec>lstFiles:VAR.infra.util.Hashtable,lstFilesErrors:VAR.infra.util.Hashtable</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    // mark this point as the current running stack
    new $ESTACK

    // Runtime error flag
    set sc = $$$YES

    write !, "Importing "_lstFiles.GetSize()_" @NM global (metadata) "_
        "definition files..."

    do lstFiles.StartIterator()
    while (lstFiles.Next()) {
        set fileName = lstFiles.GetCurrentIndex()
        set type = ##class(FileType).GetTypeByExternalName(fileName)

        if (type = ##class(FileType).%GetParameter("LANGUAGETEXT")) {
            // The routine will work if we disable erase before loading.
            set sc = ..ImportNMMetadata(fileName, 0)
        }
        else {
            // Call an especific routine to load as execute statements
            // (1=erase before loading)
            set sc = ..ImportNMMetadata(fileName, 1)
        }

        if (sc = 0) {
            write !, "Runtime error location: "_lstFiles.GetCurrentIndex()
            do lstFilesErrors.Put(fileName, lstFiles.GetCurrentValue())
        }
        elseif (sc = -1) {
            // Just save the location
            do lstFilesErrors.Put(fileName, lstFiles.GetCurrentValue())
        }
        elseif (sc >= 1) {
            // Update the timestamp
            do ##class(FileControl).UpdateTimeStamp(fileName)
        }
    }
]]></Implementation>
</Method>

<Method name="ImportNMClasses">
<Description><![CDATA[
this method imports a list of @NM classes from filenames. ]]></Description>
<FormalSpec>lstFiles:VAR.infra.util.Hashtable,lstFilesErrors:VAR.infra.util.Hashtable</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
    write !, "Importing "_lstFiles.GetSize()_" @NM classes..."
    do lstFiles.StartIterator()
    while (lstFiles.Next()) {
        set fileName = lstFiles.GetCurrentIndex()
        set value = lstFiles.GetCurrentValue()

        // Import the metadata into globals
        // Call an especific routine to load as execute statements
        // (1=erase before loading)
		kill arrKeyTreeBefore
		kill arrPropertyTreeBefore
		set className = value
		do ##class(NetManagerClass).GenerateArrKeys(className, .arrKeyTreeBefore)
		do ##class(NetManagerClass).GenerateArrPropertyName(className, .arrPropertyTreeBefore)

        set sc = ..ImportNMMetadata(fileName, 1)
        if (sc = 0) {
            set error = "Runtime error!"
            do ..AddCompileError(value, error, sc)

            write !, "Last NM Class import error (runtime): "_value

            // Save the value
            do lstFilesErrors.Put(fileName, value)
        }
        elseif (sc = -1) {
            // Save the value
            do lstFilesErrors.Put(fileName, value)
        }
        elseif (sc >= 1) {
            // Update the timestamp
            do ##class(FileControl).UpdateTimeStamp(fileName)

            kill arrKeyTreeAfter
	        kill arrPropertyTreeAfter
			do ##class(NetManagerClass).GenerateArrKeys(className, .arrKeyTreeAfter)
			do ##class(NetManagerClass).GenerateArrPropertyName(className, .arrPropertyTreeAfter)

			if (##class(NetManagerClass).IsIndexDirty(className) ||
				('##class(NetManagerClass).CompareArrKeys(.arrKeyTreeBefore, .arrKeyTreeAfter))) {
				// Guarda as classes que tiveram alteracao no indice
				do ..nmClassesReindex.Put(fileName, value)
			}
			if ('##class(NetManagerClass).CompareArrKeys(.arrPropertyTreeBefore, .arrPropertyTreeAfter)) {
				// Guarda as classes que tiveram alteracao no "inc"
				do ..nmClassesReconst.Put(##class(NetManagerClass).GetIdModule(className), className)
			}
        }
    }

    // Reindex classes
    do ##class(RunAlphalincMac).RunWWWSORT(..nmClassesReindex)
    // Generate incs
    do ##class(RunAlphalincMac).RunGenerateCOMConst(..nmClassesReconst)
]]></Implementation>
</Method>

<Method name="ImportNMMetadata">
<Description><![CDATA[
Imports @NM metadata. This is a wrapper that traps runtime errors.

TODO: figure out how to build a correct Status code from whithin $etrap code.
Meanwhile, this method returns 3 possible codes: 0: runtime error, 1: good, -1: processing error]]></Description>
<FormalSpec>externalFileName:%String,eraseBeforeLoading:%Boolean</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
    // Turn on error traping: this method will return 0 if a runtime
    // error happens
    new $etrap

    // The following code forces Cache to stop error hadling at this
    // contect of execution
    set $etrap = "write !, ""Runtime error found:""_$ZERROR_"" - "_
        "stck=""_$ESTACK set $ECODE = """" quit:$quit 0 quit"

    // Block the Exporter (we don't want WWWSPEI do export anything
    // right now)
    set sc = ##class(Exporter).BlockExporter()
    if (##class(Errors).IsError(sc)) {
        quit -1
    }

    write !, "Importing: "_externalFileName_" (eraseBeforeLoading="_eraseBeforeLoading_")"
	set sc = ..ImportNMMetadataType(externalFileName, eraseBeforeLoading,
		##class(FileType).IsCustomByExternalName(externalFileName))
    if (sc >= 1) {
        // Update the timestamp
        do ##class(FileControl).UpdateTimeStamp(externalFileName)
    }

    // Get the type
    set type = ##class(FileType).GetTypeByExternalName(externalFileName)

    if (('##class(Config).IsBuildOnlyNonVAR()) &&
        ((type = ##class(FileType).%GetParameter("NMCLASS")) ||
         (type = ##class(FileType).%GetParameter("FORM")) ||
         (type = ##class(FileType).%GetParameter("FAVORITES"))) &&
        ('##class(FileType).IsCustomByExternalName(externalFileName))) {
		if (type = ##class(FileType).%GetParameter("NMCLASS")) {
			set externalFileName = $piece(externalFileName, ".", 1,
				$length(externalFileName, ".") - 1)_"."_
				##class(FileType).%GetParameter("TXTCUSTOMNMCLASS")
		}
		elseif (type = ##class(FileType).%GetParameter("FORM")) {
			set externalFileName = $piece(externalFileName, ".", 1,
				$length(externalFileName, ".") - 1)_"."_
				##class(FileType).%GetParameter("TXTCUSTOMFORM")
		}
		elseif (type = ##class(FileType).%GetParameter("FAVORITES")) {
			set externalFileName = $piece(externalFileName, ".", 1,
				$length(externalFileName, ".") - 1)_"."_
				##class(FileType).%GetParameter("TXTCUSTOMFAVORITES")
		}

		write !, "Importing: "_externalFileName_" (eraseBeforeLoading="_eraseBeforeLoading_")"
		set sc = ..ImportNMMetadataType(externalFileName, eraseBeforeLoading, 1)
		if (sc >= 1) {
			// Update the timestamp
			do ##class(FileControl).UpdateTimeStamp(externalFileName)
		}
	}

    // Release the Exporter 
    set sc = ##class(Exporter).ReleaseExporter()
    if (##class(Errors).IsError(sc)) {
        quit -1
    }

    quit sc
]]></Implementation>
</Method>

<Method name="ImportNMMetadataType">
<Description><![CDATA[
Imports @NM metadata specific type.]]></Description>
<FormalSpec>externalFileName:%String,eraseBeforeLoading:%Boolean,custom:%Boolean</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set id = $piece(externalFileName, ".", $length(externalFileName, "."))

	if ((id = ##class(FileType).%GetParameter("TXTFORM")) ||
		(id = ##class(FileType).%GetParameter("TXTCUSTOMFORM"))) {
	    set sc = ##class(NetManagerForm).ImportNMMetadataHelper(
	    	externalFileName, eraseBeforeLoading, custom)
	}
	elseif ((id = ##class(FileType).%GetParameter("TXTNMCLASS")) ||
			(id = ##class(FileType).%GetParameter("TXTCUSTOMNMCLASS"))) {
	    set sc = ##class(NetManagerClass).ImportNMMetadataHelper(
	    	externalFileName, eraseBeforeLoading, custom)
	}
	elseif (id = ##class(FileType).%GetParameter("TXTMENU")) {
	    set sc = ##class(NetManagerMenu).ImportNMMetadataHelper(
	    	externalFileName, eraseBeforeLoading, custom)
	}
	elseif ((id = ##class(FileType).%GetParameter("TXTPARAMETERS")) ||
			(id = ##class(FileType).%GetParameter("TXTCUSTOMPARAMETERS"))) {
		set fileName = ##class(DirectoryFile).FixUnixPathSymbol(externalFileName)
		set specialDir = $piece(fileName, "/", $length(fileName, "/") - 1)

		if (specialDir = ##class(FileType).%GetParameter("TXTCHARPARAMETERS")) {
		    set sc = ##class(NetManagerCharParameter).ImportNMMetadataHelper(
		    	externalFileName, eraseBeforeLoading, custom)
		}
		elseif (specialDir = ##class(FileType).%GetParameter("TXTAPPPARAMETERS")) {
		    set sc = ##class(NetManagerApplicationParameter).ImportNMMetadataHelper(
		    	externalFileName, eraseBeforeLoading, custom)
		}
		elseif (specialDir = ##class(FileType).%GetParameter("TXTSYSPARAMETERS")) {
		    set sc = ##class(NetManagerSystemParameter).ImportNMMetadataHelper(
		    	externalFileName, eraseBeforeLoading, custom)
		}
		elseif ((id = ##class(FileType).%GetParameter("TXTPARAMETERS")) &&
				(specialDir = ##class(FileType).%GetParameter("TXTUSERPARAMETERS"))) {
		    set sc = ##class(NetManagerUserParameter).ImportNMMetadataHelper(
		    	externalFileName, eraseBeforeLoading, custom)
		}
		elseif ((id = ##class(FileType).%GetParameter("TXTCUSTOMPARAMETERS")) &&
				(specialDir = ##class(FileType).%GetParameter("TXTUSERPARAMETERS"))) {
		    set sc = ##class(NetManagerCustomUserParameter).ImportNMMetadataHelper(
		    	externalFileName, eraseBeforeLoading, custom)
		}
		elseif (specialDir = ##class(FileType).%GetParameter("TXTDICTIONARY")) {
		    set sc = ##class(NetManagerDictionary).ImportNMMetadataHelper(
		    	externalFileName, eraseBeforeLoading, custom)
		}
	}
	elseif (id = ##class(FileType).%GetParameter("TXTLANGUAGETEXT")) {
	    set sc = ##class(NetManagerLanguageText).ImportNMMetadataHelper(
	    	externalFileName, eraseBeforeLoading, custom)
	}
	elseif (id = ##class(FileType).%GetParameter("TXTMETADATA")) {
	    set sc = ##class(NetManagerGeneralMetadata).ImportNMMetadataHelper(
	    	externalFileName, eraseBeforeLoading, custom)
	}
	elseif ((id = ##class(FileType).%GetParameter("TXTFAVORITES")) ||
			(id = ##class(FileType).%GetParameter("TXTCUSTOMFAVORITES"))) {
	    set sc = ##class(NetManagerFavorite).ImportNMMetadataHelper(
	    	externalFileName, eraseBeforeLoading, custom)
	}
	else {
		set sc = 0
	}

	quit sc
]]></Implementation>
</Method>

<Method name="ProcessPassTwo">
<Description><![CDATA[
Compiles all cache source files and @NM artifacts that had an error during pass one.
We assume that some of those errors were the result of missing dependencies, which maybe
met now.]]></Description>
<Implementation><![CDATA[
    set ..errorCount = 0

    set ^SourceControl("runStatus", "pass 2", "total errors") = 0

    write !, "22222222222222222222222222222222222222222222222222222222222222222"
    write !, "Processing all files, pass two (files with errors on pass one and PRJ files)..."

    // Loops through all MACs, loading and compiling them (d: display
    // message, f: force c: compile)
    // Just recompile them 
    set ^SourceControl("runStatus") = "Importing and compiling MAC "_
        "routines"
    do ..LoadCacheSourceFiles(..cacheMacsErrors, ..cacheMacsErrors,
        "MAC", "cfkv")

    // Loops through all cache pure cache classes and compiles them, with
    // dependencies (r:recursive, b:subclasses )
    set ^SourceControl("runStatus") = "Compiling pure Cache classes"
    do ..CompileCacheClasses(..cacheClassesErrors, ..cacheClassesErrors,
        "regular CLS classes", "cfkvo3byr")

    // Loops through all cache classes that represent sql tables (not
    // views) . (y: sql dependencies)
    set ^SourceControl("runStatus")="Compiling Cache Table definition "_
        "classes"
    do ..CompileCacheClasses(..cacheTableClassesErrors, ..cacheTableClassesErrors,
        "CLS table definition classes", "cfkvo3byr")

    // Loops through all cache classes that represent sql views
    set ^SourceControl("runStatus")="Compiling Cache View definition "_
        "classes"
    do ..CompileCacheClasses(..cacheViewClassesErrors, ..cacheViewClassesErrors,
        "CLS view definition classes", "cfkvo3byr")

    // Loops through all csp pages
    set ^SourceControl("runStatus") = "Compiling Cache CSP pages"
    do ..CompileCacheCsps(..cacheCsps, ..cacheCspsErrors,
        "CSP pages", "cfkvo3byr")

    // Should use it on ASDE?
    //do ##class(Alphalinc).GrantAllObjectsToJasper()

    // Loops through all NM artifacts that are not classes
    set ^SourceControl("runStatus") = "Importing @NM aartifacts (forms, "_
        "menus, etc)"
    do ..ImportNMGlobals(..nmOthersErrors, ..nmOthersErrors)

    // Loops through all NM classes and imports them
    set ^SourceControl("runStatus") = "Importing @NM classes"
    do ..ImportNMClasses(..nmClassesErrors, ..nmClassesErrors)

    // Import the project definition files (PRJ) 
    set ^SourceControl("runStatus") = "Importing PRJ files"
    do ..LoadCacheSourceFiles(..cachePrjs, ..cacheMacsErrors, "PRJ", "")

    set ^SourceControl("runStatus", "pass 2", "total errors") =
        ..errorCount
]]></Implementation>
</Method>

<Method name="ShowErrors">
<Description><![CDATA[
Displays all errors to the console]]></Description>
<Implementation><![CDATA[
    write !, "========================================================================", !
    write !, "========================================================================", !
    if (..errorCount = 0) {
        write !, "No errors were found after the second pass!"
    }
    else {
        write !, "There were "_..errorCount_" errors found after the "_
            "second pass."
        write !, " Please review this log file for additional information."
    }
]]></Implementation>
</Method>
</Class>
</Export>